<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="十早九木"><meta name="copyright" content="十早九木"><title>十早九木のBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7681d949619b1341034a17f1337d10ec";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="十早九木のBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">十早九木</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/szjmhxd">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">122</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">60</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">十早九木のBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">时间线</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="site-info"><div id="site-title">十早九木のBlog</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/szjmhxd" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="http://weibo.com/szjmhxd" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-weibo fab"></i></a><a class="social-icon" href="https://www.zhihu.com/people/szjmhxd" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-zhihu fab"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1554764876&amp;website=www.oicqzone.com" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-qq fab"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.09/2022%E5%B9%B49%E6%9C%8807%E6%97%A5/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><div class="content"><h3 id="57-“服务详情”页面，用来显示服务信息和过程记录"><a href="#57-“服务详情”页面，用来显示服务信息和过程记录" class="headerlink" title="57 “服务详情”页面，用来显示服务信息和过程记录"></a>57 “服务详情”页面，用来显示服务信息和过程记录</h3><p>问题： 服务管理当中看不到每一个服务的被服务者，因为“服务”这里可以进行“一对一”和“一对多”两种，因此这里可以做一个“服务详情”页面，用来显示服务信息和过程记录，过程记录里包括谁、什么时间购买的服务、什么时间接入和结束的服务。入口可以放在“操作”列。</p>
<p>解决过程：</p>
<p>做的和需求不一致</p>
<p>结果：重新编写</p>
<h3 id="公益人员查询"><a href="#公益人员查询" class="headerlink" title="公益人员查询"></a>公益人员查询</h3><p>问题： 公益人员不能查询</p>
<p>解决过程：</p>
<p>接口好像崩了</p>
<p>结果：先问一下李哥 不行准备重写一个</p>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>帮助任燕解决打包问题 暂时只是能打 但是不是想要的</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.09/2022%E5%B9%B49%E6%9C%8806%E6%97%A5/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><div class="content"><h3 id="106-流水类型要分类"><a href="#106-流水类型要分类" class="headerlink" title="106 流水类型要分类"></a>106 流水类型要分类</h3><p>问题：没有流水类型的筛选</p>
<p>解决过程：</p>
<ol>
<li>查找相关界面 看不到</li>
<li>搜索相关代码 </li>
<li>尝试修改目录显示</li>
<li>页面自动跳转到另一个界面</li>
<li>删除相关代码 显示无数据</li>
<li>查找有数据的用户 但是用户不是管理员无法登陆</li>
<li>修改为管理员 登陆 但是查询报错</li>
<li>问题未能解决 正在询问李泰来</li>
</ol>
<p>结果： 页面无法显示 正在询问李泰来</p>
<h3 id="61-从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据"><a href="#61-从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据" class="headerlink" title="61 从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据"></a>61 从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据</h3><p>问题： 从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据，李哥说要设置前端防刷</p>
<p>解决过程：</p>
<ol>
<li><p>上网查看相关思路 </p>
</li>
<li><p>选择存储用户ip、访问接口命、访问时间，然后通过计算两次接口访问时间差来判断是否是在刷接口</p>
</li>
<li><p>优化 因为数据是存储在本地的，所以不需要获取ip，只需要把接口名作为变量名，把访问时间作为值存储在window就可以了</p>
</li>
<li><p>报错，查询发现uni-app没有window存储</p>
</li>
<li><p>查看开发者文档，使用<code>uni.setStorageSync</code>代替</p>
</li>
<li><p>计算时间差 找了一圈教程发现<code>Date()</code>可以直接计算 返回的是相差的毫秒值</p>
</li>
<li><p>使用<code>Math.abs</code>返回时间差的绝对值 使用if语句判断 初始设定为60000毫秒 也就是1min</p>
</li>
<li><p>容错 如果第一次访问，<code>uni.setStorageSync</code>没有数据 不知道会不会报错</p>
</li>
<li><p>对<code>uni.setStorageSync</code>进行为空判断，使用<code>typeof</code>查看类型为<code>Object</code></p>
</li>
<li><p>上网查询，使用在线js编译器验证，最终选择<code>JSON.stringify(uni.getStorageSync(&#39;issueService&#39;)) === &#39;&#123;&#125;&#39;</code>判断是否为空</p>
</li>
<li><p>修改<code>Publishing</code>的代码，先使用<code>timeDiff()</code>判断，再执行<code>savePublishing()</code>代码</p>
</li>
<li><p>在开发者手册查询uni-app可以用的提示框 选择</p>
</li>
<li><pre><code class="javascript">uni.showToast(&#123;
    title: &#39;频繁 请稍后再试&#39;,
    icon: &#39;error&#39;
&#125;);
</code></pre>
</li>
<li><p>验证 成功</p>
</li>
</ol>
<p>结果： 达到了防刷效果 1min内服务或者需求只能发布一次</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.09/2022%E5%B9%B49%E6%9C%8805%E6%97%A5/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><div class="content"><h3 id="52-1-筛选栏当中没有需求名称、需求状态、所在地的筛选项"><a href="#52-1-筛选栏当中没有需求名称、需求状态、所在地的筛选项" class="headerlink" title="52.1 筛选栏当中没有需求名称、需求状态、所在地的筛选项"></a>52.1 筛选栏当中没有需求名称、需求状态、所在地的筛选项</h3><p>问题：筛选栏当中没有需求名称、需求状态、所在地的筛选项，9.02我只写出来了前端界面，没有写后端接口</p>
<p>解决过程：</p>
<ol>
<li>控制台查看查询接口</li>
<li>按照查询接口找到后端接口</li>
<li>了解后端运行机制</li>
<li>尝试新增变量 对变量进行null判断 修改sql语句</li>
<li>报错 </li>
<li>更改思路 修改为变量直接写入sql语句</li>
<li>成功 但是有sql注入的风险</li>
<li>询问李哥 发现问题</li>
<li>修改问题 能成功查询</li>
<li>新增另外两个变量</li>
</ol>
<p>结果：可以查询</p>
<h3 id="52-1-筛选栏当中没有需求名称、需求状态、所在地的筛选项-1"><a href="#52-1-筛选栏当中没有需求名称、需求状态、所在地的筛选项-1" class="headerlink" title="52.1 筛选栏当中没有需求名称、需求状态、所在地的筛选项"></a>52.1 筛选栏当中没有需求名称、需求状态、所在地的筛选项</h3><p>问题：筛选栏当中没有需求名称、需求状态、所在地的筛选项，9.02我只仿照写出来了前端界面，下拉菜单这里不是真正的菜单</p>
<p>解决过程：</p>
<ol>
<li>查看自己之前写的项目 查询相关代码</li>
<li>找到相关代码 cv并稍加修改</li>
<li>尝试运行 成功</li>
</ol>
<p>结果：可以查询</p>
<h3 id="54-限制单元格长度-悬停显示全部"><a href="#54-限制单元格长度-悬停显示全部" class="headerlink" title="54 限制单元格长度 悬停显示全部"></a>54 限制单元格长度 悬停显示全部</h3><p>问题：需求管理列表中，需求名称和需求描述列要对字数显示有限制，加大这两列的宽度，数据内容只显示一行，如果字数超过一行，则在行尾显示省略号，鼠标悬停的时候显示全部数据。</p>
<p>解决过程：</p>
<ol>
<li>上网搜索相关解决方案</li>
<li>找到一些方案准备使用</li>
<li>发现地址栏有相关代码 </li>
<li>使用与地址栏一样的代码统一风格</li>
<li>顺便美化其他单元格长度 修改元素之间的间隔</li>
</ol>
<p>结果：单行显示 超出省略号悬停显示 界面更加美观</p>
<h3 id="55-需求管理列表当中，接单人和发布人列当中要把用户昵称和账号都显示上"><a href="#55-需求管理列表当中，接单人和发布人列当中要把用户昵称和账号都显示上" class="headerlink" title="55 需求管理列表当中，接单人和发布人列当中要把用户昵称和账号都显示上"></a>55 需求管理列表当中，接单人和发布人列当中要把用户昵称和账号都显示上</h3><p>问题： 需求管理列表当中，接单人和发布人列当中要把用户昵称和账号都显示上，以便后续运营管理上好查询。</p>
<p>解决过程：</p>
<ol>
<li>控制台查看查询接口</li>
<li>按照查询接口找到后端接口</li>
<li>根据变量名称全局搜索找到相关代码</li>
<li>新增两个变量并新增相关赋值语句</li>
<li>修改前端展示代码</li>
<li>能够显示</li>
</ol>
<p>结果： 能够查询</p>
<h3 id="56-同样出现了上述需求管理的问题52-55相同的问题"><a href="#56-同样出现了上述需求管理的问题52-55相同的问题" class="headerlink" title="56 同样出现了上述需求管理的问题52-55相同的问题"></a>56 同样出现了上述需求管理的问题52-55相同的问题</h3><p>问题： 同样出现了上述需求管理的问题52-55相同的问题</p>
<p>解决过程： 按照之前的思路再来一遍</p>
<p>结果： 解决了问题</p>
<h3 id="59-底部的“备案信息”不用悬浮与页面底部，这样会遮挡主要内容"><a href="#59-底部的“备案信息”不用悬浮与页面底部，这样会遮挡主要内容" class="headerlink" title="59 底部的“备案信息”不用悬浮与页面底部，这样会遮挡主要内容"></a>59 底部的“备案信息”不用悬浮与页面底部，这样会遮挡主要内容</h3><p>问题： 底部的“备案信息”不用悬浮与页面底部，这样会遮挡主要内容</p>
<p>解决过程： </p>
<ol>
<li>全局搜索相关文字找到相关代码</li>
<li>查看前端页面布局</li>
<li>修改布局</li>
<li>询问宋经理界面是否符合要求</li>
</ol>
<p>结果： 已经解决问题</p>
<h3 id="60-后台的这些图标都没有显示出来"><a href="#60-后台的这些图标都没有显示出来" class="headerlink" title="60 后台的这些图标都没有显示出来"></a>60 后台的这些图标都没有显示出来</h3><p>问题：后台的这些图标都没有显示出来</p>
<p>解决过程：</p>
<ol>
<li>发现应该是fa样式的图标 一般为网络或者打包问题</li>
<li>询问李哥确认为vue打包问题</li>
</ol>
<p>结果：需要相关人修改打包机制</p>
<h3 id="61-从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据"><a href="#61-从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据" class="headerlink" title="61 从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据"></a>61 从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据</h3><p>问题：从需求管理和服务管理当中可见，需求和服务发布的时候会产生重复数据</p>
<p>解决过程：</p>
<ol>
<li>感觉是网络问题</li>
<li>询问李哥 需要在前端设置防刷</li>
</ol>
<p>结果：正在研究前端防刷</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.09/2022%E5%B9%B49%E6%9C%8802%E6%97%A5/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><div class="content"><h3 id="app端无法登陆"><a href="#app端无法登陆" class="headerlink" title="app端无法登陆"></a>app端无法登陆</h3><p>问题：在模拟器中运行小程序之后一直在登录界面转圈</p>
<p>解决过程： 查看前端后端数据库都没有问题，修改ip也无法解决，重置了模拟器网络能进去了</p>
<p>结果：能够正常进入小程序</p>
<h3 id="51前后台数据数量不一致"><a href="#51前后台数据数量不一致" class="headerlink" title="51前后台数据数量不一致"></a>51前后台数据数量不一致</h3><p>问题：前后台数据明显不一致</p>
<p>解决过程： </p>
<ol>
<li>监听后台接口 查看到后台查询地址</li>
<li>通过代理抓包模拟器数据 得到前台插叙地址</li>
<li>尝试查看对应的sql语句 hibernate框架看不太懂…</li>
<li>尝试修改sql语句 报错</li>
<li>使用祝哥提供的方法进行排序 没有作用</li>
<li>查看mysql数据库查询日志<a target="_blank" rel="noopener" href="https://blog.csdn.net/biyating/article/details/107894125">mysql如何开启日志</a>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangkongming/p/3684950.html">mysql日志详细解析</a></li>
<li>发现sql语句没有问题</li>
<li>找到sql字段注释 了解了前后台数据为什么不一样多</li>
<li>摸索中发现前台数据排序规律是地址远近</li>
</ol>
<p>结果：因为后台显示的是所有数据 而app上能接取的只能是未被别人接单的数据和没有指定接单人的数据 而数据顺序杂乱是因为这是按照发布位置离当前位置的距离进行排序的</p>
<h3 id="51前后台数据不一致"><a href="#51前后台数据不一致" class="headerlink" title="51前后台数据不一致"></a>51前后台数据不一致</h3><p>问题：前后台数据对应不上</p>
<p>解决过程：</p>
<ol>
<li>由于已经大致了解了这个数据库，猜测问题是前后台用的不是一个数据库</li>
<li>在公网的前端和后端分别修改数据 发现没有同步</li>
<li>找祝哥确认 确实是前后台数据库不是一个</li>
</ol>
<p>结果：前后台数据库不一致所以数据不同步</p>
<h3 id="52-1筛选栏当中没有需求名称、需求状态、所在地的筛选项"><a href="#52-1筛选栏当中没有需求名称、需求状态、所在地的筛选项" class="headerlink" title="52.1筛选栏当中没有需求名称、需求状态、所在地的筛选项"></a>52.1筛选栏当中没有需求名称、需求状态、所在地的筛选项</h3><p>问题： 筛选栏当中没有需求名称、需求状态、所在地的筛选项，这在以后运营管理上会造成很大的困扰。</p>
<p>解决过程：仿照之前的界面写出来看界面，并修改了填充块大小</p>
<p>结果：只有界面 暂时没有功能</p>
<h3 id="52-2需求类型列的数据是死数据"><a href="#52-2需求类型列的数据是死数据" class="headerlink" title="52.2需求类型列的数据是死数据"></a>52.2需求类型列的数据是死数据</h3><p>问题：需求类型列的数据是死数据</p>
<p>解决过程：</p>
<ol>
<li>查看数据 数据非常随机不像是写死的死数据</li>
<li>控制台查看接口 确认是后端返回的值</li>
<li>数据库查看表 确定是表里的数据</li>
<li>应该是公网没有更新</li>
</ol>
<p>结果：没有问题 应该是公网没有更新</p>
<h3 id="52-3时长列标题出现错别字"><a href="#52-3时长列标题出现错别字" class="headerlink" title="52.3时长列标题出现错别字"></a>52.3时长列标题出现错别字</h3><p>问题：时长列标题出现错别字</p>
<p>解决过程： 修改相关文字</p>
<p>结果：修改完成</p>
<h3 id="52-4接单人列里没有接单人的时候，应该显示“无人接单”"><a href="#52-4接单人列里没有接单人的时候，应该显示“无人接单”" class="headerlink" title="52.4接单人列里没有接单人的时候，应该显示“无人接单”"></a>52.4接单人列里没有接单人的时候，应该显示“无人接单”</h3><p>问题：后端的默认数据不对</p>
<p>解决过程：</p>
<ol>
<li>在前端界面全局搜索相关字“测试数据”</li>
<li>根据变量名称辨认需要修改的文字</li>
<li>修改无接单人为“无人接单”，无需求类型为“未设置类型”</li>
<li>再次与经理沟通后，为了防止有人起“无人接单”这种奇怪的名字，修改为无接单人为“—-”</li>
</ol>
<p>结果：修改完成</p>
<h3 id="53-1-用户自己设置的需求类型没有显示"><a href="#53-1-用户自己设置的需求类型没有显示" class="headerlink" title="53.1 用户自己设置的需求类型没有显示"></a>53.1 用户自己设置的需求类型没有显示</h3><p>问题：用户自己设置的需求类型没有显示</p>
<p>解决过程：</p>
<ol>
<li>查看网页端和app端均未发现用户可以自己设置需求类型的功能 </li>
<li>与宋经理沟通，又是版本同步的问题</li>
</ol>
<p>结果：没有问题</p>
<h3 id="53-2-时长标题错别字"><a href="#53-2-时长标题错别字" class="headerlink" title="53.2 时长标题错别字"></a>53.2 时长标题错别字</h3><p>问题：时长列标题出现错别字</p>
<p>解决过程： 修改相关文字</p>
<p>结果：修改完成</p>
<h3 id="53-3-详细地址没有数据"><a href="#53-3-详细地址没有数据" class="headerlink" title="53.3 详细地址没有数据"></a>53.3 详细地址没有数据</h3><p>问题： 详细地址没有数据</p>
<p>解决过程： </p>
<ol>
<li>控制台查看接口 发现相关字段为address</li>
<li>查看前端代码 发现字段对应不上</li>
<li>修改相关字段名称 成功</li>
</ol>
<p>结果： 修改能正常显示</p>
<h3 id="53-4-保存后，点击提交没有保存并退出该页面"><a href="#53-4-保存后，点击提交没有保存并退出该页面" class="headerlink" title="53.4 保存后，点击提交没有保存并退出该页面"></a>53.4 保存后，点击提交没有保存并退出该页面</h3><p>问题：保存后，点击提交没有保存并退出该页面</p>
<p>解决过程：</p>
<ol>
<li>测试发现：点击取消可以返回，点击确认不可以</li>
<li>查看界面代码 发现确认和取消的对应方法</li>
<li>发现确认按钮没有相关的<code>this.$router</code>语句</li>
<li>参照<a target="_blank" rel="noopener" href="https://blog.csdn.net/vvv3171071/article/details/121636195">教程</a>添加代码<code>this.$router.back()</code></li>
</ol>
<p>结果：点击确认后可以返回，且数据已经被修改</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.09/2022%E5%B9%B49%E6%9C%8801%E6%97%A5/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><div class="content"><h3 id="小程序端无法登陆"><a href="#小程序端无法登陆" class="headerlink" title="小程序端无法登陆"></a>小程序端无法登陆</h3><p>问题：在模拟器中运行小程序之后一直在登录界面转圈</p>
<p>解决过程： 查看前端后端数据库都没有问题，查看ip地址发现因为使用的动态ip所以ip地址发生了变化，修改为静态ip192.168.1.116，修改前端设置的ip</p>
<p>结果：能够正常进入小程序</p>
<h3 id="隐藏认证接口"><a href="#隐藏认证接口" class="headerlink" title="隐藏认证接口"></a>隐藏认证接口</h3><p>问题：需要隐藏小程序中人脸认证和资质认证的入口</p>
<p>解决过程： </p>
<ol>
<li>因为界面有文字，所以在整个文件项目中搜索相关文字<code>资质认证</code></li>
<li>排除发发现相关页面是<code>Mycertification.vue</code></li>
<li>注释掉相关代码</li>
</ol>
<p>结果：已经无法看见相关入口了</p>
<p><img src="/2022%E5%B9%B49%E6%9C%8801%E6%97%A5/image-20220901094933508.png" alt="image-20220901094933508"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.08/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%202022%E5%B9%B48%E6%9C%8830%E6%97%A5%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><div class="content"><h2 id="6-3-接口和实现"><a href="#6-3-接口和实现" class="headerlink" title="6.3 接口和实现"></a>6.3 接口和实现</h2><p>访问权限的控制常被称为是具体实现的隐藏。</p>
<p>把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是封装。其结果是一个同时带有特征和行为的数据类型。</p>
<p>出于两个很重要的原因，访问权限控制将权限的边界划在了数据类型的内部。</p>
<ol>
<li>要设定客户端程序员可以使用和不可以使用的界限。可以在结构中建立自己的内部机制，而<br>不必担心客户端程序员会偶然地将内部机制当作是他们可以使用的接口的一部分。这个原因直接引出了第二个原因。</li>
<li>即将接口和具体实现进行分离。如果结构是用于一组程序之中，而客户端程序员除了可以向接口发送信息之外什么也不可以做的话，那么就可以随意更改所有不是public的东西( 例如有包访问权限、protected 和private的成员)，而不会破坏客户端代码。</li>
</ol>
<p>为了清楚起见，可能会采用一种将public成员置于开头，后面跟着protected.包访问权限和private成员的创建类的形式。这样做的好处是类的使用者可以从头读起，首先阅读对他们而言最为重要的部分(即public成员， 因为可以从文件外部调用它们)，等到遇见作为内部实现细节的非public成员时停止阅读:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class OrganizedByAccess &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pub1</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pub2</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pub3</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">priv1</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">priv2</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> vo1d <span class="title function_">priv3</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做仅能使程序阅读起来稍微容易一些，因为接口和具体实现仍旧混在一起。也就是说，仍能看到源代码的实现部分，因为它就在类中。另外，javadoc所提供的注释文档功能降低了程序代码的可读性对客户端程序员的重要性。将接口展现给某个类的使用者实际上是类浏览器的任务。</p>
<p>类浏览器是一种以非常有用的方式来查阅所有可用的类，并告诉你用它们可以做些什么(也就是显示出可用成员)的工具。在Java中，用Web浏览器浏览JDK文档可以得到使用类浏览器的相同效果。</p>
<h2 id="6-4-类的访问权限"><a href="#6-4-类的访问权限" class="headerlink" title="6.4 类的访问权限"></a>6.4 类的访问权限</h2><p>在Java中，访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。如果希望某个类可以为某个客户端程序员所用，就可以通过把关键字public作用于整个类的定义来达到目的。这样做甚至可以控制客户端程序员是否能创建一个该类的对象。</p>
<p>为了控制某个类的访问权限，修饰词必须出现于关键字class之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br></pre></td></tr></table></figure>

<p>现在如果库的名字是access，那么任何客户端程序员都可以通过下面的声明访问Widget</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access .Widget;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">import</span> access.*;</span><br></pre></td></tr></table></figure>

<p>然而，这里还有一些额外的限制:</p>
<ol>
<li>每个编译单元(文件)都只能有一个public类。这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出出错信息。</li>
<li>public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。所以对于Widget而言，文件的名称必须是Widget.java，而不是widget.java或WIDGET.java。如果不匹配，同样将得到编译时错误。</li>
<li>虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。(尽管随意命名会使得人们在阅读和维护代码时产生混淆。)</li>
</ol>
<p>如果获取了一个在access内部的类，用来完成Widget或是其他在access中的public类所要执行的任务，将会出现什么样的情况呢?你不想自找麻烦去为客户端程序员创建说明文档，而且你认为不久可能会想要完全改变原有方案并将旧版本一起删除，代之以一种不同的版本。为了保留此灵活性，需要确保客户端程序员不会依赖于隐藏在access之中的任何特定实现细节。为了达到这一点，只需将关键字public从类中拿掉，这个类就拥有了包访问权限。(该类只可以用于该包之中。)</p>
<p>在创建一个包访问权限的类时，仍旧是在将该类的域声明为private时才有意义，应尽可能地总是将域指定为私有的，但是通常来说，将与类(包访问权限)相同的访问权限赋予方法也是很合理的。</p>
<p>既然一个有包访问权限的类通常只能被用于包内，那么如果对你有强制要求，在此种情况下，编译器会告诉你，你只需要将这样的类的方法设定为public就可以了。</p>
<p>请注意，类既不可以是private的(这样会使得除该类之外，其他任何类都不可以访向它)，也不可以是protected的。所以对于类的访问权限，仅有两个选择:包访问权限或public。 </p>
<p>如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而阻止任何人<br>创建该类的对象，但是有一个例外，就是你在该类的static成员内部可以创建。</p>
<p>如果我们把构造器定义为private，那就谁也无法创建这个类型的对象。这种情况下还是有方法使用这两个类。</p>
<p>在Soup1中创建一个static方法，创建一个新的Soup1对象并返回一个对它的引用。这样如果想在返回引用之前做一些额外的工作，或者是记录创建了多少个Soup1对象都可以。</p>
<p>Soup2用到了所谓的设计模式，这种模式被称之为singleton（单例），这是因为你始终只能创建它的一个对象。Soup2类的对象是作为Soup2的一个static private成员而创建的，所以有且只有一个，除非是通过public方法access()，否则无法访问到。</p>
<p>之前提到过，如果没有为类访问权限指定一个修饰符，那么会默认得到包访问权限，意味着该类的对象可以由包内任何其他类来创建，而包外是不行的。如果某个static成员是public的话，客户端程序员仍然可以调用这个static成员，尽管他们并不能生成该类的对象。</p>
<h2 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h2><p>无论什么关系，为各成员创建需要遵守的界限是很重要的。当创建了类库之后，也就与该类库的用户建立了某种关系。客户端程序员会用你的类库聚合成一个应用程序或者创建更大的类库。</p>
<p>如果不指定规则，客户端程序员就可以对类的所有成员为所欲为。</p>
<p>控制对成员的访问权限有两个原因。</p>
<ul>
<li>第一是为了使用户不要碰触那些他们不该碰触的部分，这些部分对于类内部的操作是必要的，但是它并不属于客户端程序员所需接口的一部分。 因此，将方法和域指定成private，对客户端程序员而言是一种服务。 因为这样他们可以很清楚地看到什么对他们重要，什么是他们可以忽略的。这样简化了他们对类的理解。</li>
<li>第二个原因，也是最重要的原因，是为了让类库设计者可以更改类的内部工作方式，而不必担心这样会对客户端程序员产生重大的影响。例如，最初可能会以某种方式创建一个类，然后发现如果更改程序结构，可以大大提高运行速度。如果接口和实现可以被明确地隔离和加以保护，那么就可以实现这一目的，而不必强制客户端程序员重新编写代码。访问权限控制可以确保不会有任何客户端程序员依赖于某个类的底层实现的任何部分。</li>
</ul>
<p>类的公共接口是用户真正能够看到的，所以这一部分是在分析和设计的过程中决定该类是否正确的最重要的部分。</p>
<p>尽管如此，你仍然有进行改变的空间。如果在最初无法创建出正确的接口，那么只要不删除任何客户端程序员在他们的程序中已经用到的东西,就可以在以后添加更多的方法。</p>
<p>注意，访问权限控制专注于类库创建者和该类库的外部使用者之间的关系，这种关系也是一种通信方式。 然而，在许多情况下事情并非如此。例如，你自己编写了所有的代码，或者你在一个组员聚集在一起的项目组中工作，所有的东西都放在同一个包中。这些情况是另外一种不同的通信方式，因此严格地遵循访问权限规则并不一定是最佳选择，默认(包)访问权限也许只是可行而已。</p>
<p><strong>一：什么是POJO</strong><br>“Plain Ordinary Java Object”（或者是Plain Old Java Object）“简单java对象”。POJO的内在含义是指那些没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。</p>
<p><strong>二：为什么会有POJO？</strong><br>主要是Java的开发者被EJB的繁杂搞怕了，大家经过反思，又回归“纯洁老式”的JavaBean，即有无参构造函数，每个字段都有getter和setter的java类。</p>
<p><strong>三：POJO的意义</strong><br>POJO让开发者可专注于业务逻辑和脱离框架的单元测试。除此之外， 由于POJO并不须要继承框架的类或实现其接口，开发者能够极其灵活地搭建继承结构和建造应用。<br>POJO的意义就在于它的简单而灵活性，因为它的简单和灵活，使得POJO能够任意扩展，从而胜任多个场合，也就让一个模型贯穿多个层成为现实。<br>先写一个核心POJO，然后实现业务逻辑接口和持久化接口，就成了Domain Model； UI需要使用时，就实现数据绑定接口，变成VO（View Object）</p>
<p><strong>四：POJO与PO、VO的区别</strong></p>
<p>PO是指持久对象（persistant object持久对象）。</p>
<p>VO是指值对象或者View对象（Value Object、View Object）。View Object。</p>
<p><strong>持久对象实际上必须对应数据库中的entity（与数据库中的字段一致）</strong>，实体类与数据库表中字段不一致时，可以通过如下方法解决：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 与数据库表对应的PO.class</span><br><span class="line">@Transient</span><br><span class="line">不是数据库表字段的属性必须加@Transient注解（import javax.persistence.Transient）</span><br><span class="line"></span><br><span class="line">@Column</span><br><span class="line">数据库表字段与result不一致时用@Column注解，例如：</span><br><span class="line">@Column(name = &quot;t_schema&quot;)</span><br><span class="line">private String schema;</span><br><span class="line"></span><br><span class="line">2. 传入参数与数据库表字段不一致：</span><br><span class="line">@Param</span><br><span class="line">举个例子</span><br><span class="line">表字段f_schema与实体schema不一致 错误代码：</span><br><span class="line">  public int update(UserExtraInfo info);</span><br><span class="line">表字段f_schema与实体schema不一致 正确代码:</span><br><span class="line">  public int update(@Param(&quot;info&quot;) UserExtraInfo info);</span><br></pre></td></tr></table></figure>

<p>所以和POJO有所区别。比如说POJO是由new创建，由GC回收。但是持久对象是insert数据库创建，由数据库delete删除的。基本上持久对象生命周期和数据库密切相关。另外持久对象往往只能存在一个数据库Connection之中，Connnection关闭以后，持久对象就不存在了，而POJO只要不被GC回收，总是存在的。</p>
<p>由于存在诸多差别，因此持久对象PO(Persistent Object)在代码上肯定和POJO不同，起码PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。而ORM追求的目标就是要PO在使用上尽量和POJO一致，对于程序员来说，他们可以把PO当做POJO来用，而感觉不到PO的存在。</p>
<p><strong>五： 关于PO类（持久化类）</strong></p>
<p>PO：Persistent Object 持久化对象。</p>
<p>持久化对象，在Hibernate经常会遇见这样的概念。Hibernate实体状态有三种状态：瞬时态，持久态，游离态。</p>
<p>1）瞬时态（暂态）：（Transient）实体在内存中自由存在，它与数据库记录无关。po在DB中无记录（无副本），po和session无关（手工管理同步）。</p>
<p>eg. Customer customer&#x3D;New Customer();</p>
<p>customer.setName(“eric”);这里的Customer对象与数据库中的数据没有任何关联。</p>
<p>2）持久态(Persistent):实体对象处于Hibernate框架的管理之中。 po在DB中有记录，po和session有关（session自动管理同步）。</p>
<p>3 ) 游离态（脱管态）:（Detached）处于Persistent状态的实体对象，其对应的session实例关闭后，那么此时的实体对象处于Detached态。</p>
<p>po在DB中有记录，po和session无关（手工同步管理）</p>
<p>无名态：po处于游离态时被垃圾站回收了（垃圾回收机制），没有正本，只有DB中的副本。</p>
<p>po处于瞬时态时被垃圾站回收了，则死亡。（唯一可以死亡的状态）</p>
<p>代码如下： 需要jar包：ejb3-persistence.jar</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package com.rcoginion.test;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import javax.persistence.Column;</span><br><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.GeneratedValue;</span><br><span class="line">import javax.persistence.Table;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.annotation.Id;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;USER&quot;)</span><br><span class="line">public class ContractAttachPO  implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 序列号版本</span><br><span class="line">     */</span><br><span class="line">    private static final long serialVersionUID = 1393027357708703114L;</span><br><span class="line">    </span><br><span class="line">    // Fields</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 合同id.</span><br><span class="line">     */</span><br><span class="line">    private Long userId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户名.</span><br><span class="line">     */</span><br><span class="line">    private String userName;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取 .</span><br><span class="line">     */</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(generator = &quot;S_USER_ID&quot;)</span><br><span class="line">    @Column(name = &quot;USER_ID&quot;, precision = 16, scale = 0)</span><br><span class="line">    public Long getUserId() &#123;</span><br><span class="line">        return userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置 .</span><br><span class="line">     */</span><br><span class="line">    public void setUserId(Long userId) &#123;</span><br><span class="line">        this.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取 .</span><br><span class="line">     */</span><br><span class="line">    @Column(name = &quot;USER_NAME&quot;)</span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置 .</span><br><span class="line">     */</span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释说明：<br> 1.@Entity  &#x2F;&#x2F;说明此java类是实体类<br> <a href="mailto:&#50;&#x2e;&#x40;&#x6f;&#114;&#x67;&#x2e;&#x68;&#x69;&#98;&#x65;&#x72;&#x6e;&#97;&#x74;&#101;&#46;&#97;&#110;&#x6e;&#x6f;&#x74;&#x61;&#116;&#105;&#111;&#110;&#115;&#46;&#x47;&#101;&#110;&#101;&#114;&#x69;&#x63;&#71;&#101;&#x6e;&#101;&#x72;&#97;&#x74;&#x6f;&#114;">&#50;&#x2e;&#x40;&#x6f;&#114;&#x67;&#x2e;&#x68;&#x69;&#98;&#x65;&#x72;&#x6e;&#97;&#x74;&#101;&#46;&#97;&#110;&#x6e;&#x6f;&#x74;&#x61;&#116;&#105;&#111;&#110;&#115;&#46;&#x47;&#101;&#110;&#101;&#114;&#x69;&#x63;&#71;&#101;&#x6e;&#101;&#x72;&#97;&#x74;&#x6f;&#114;</a>(name &#x3D; “S_USER_ID”, strategy &#x3D; “sequence”,parameters<br>    &#x3D; { @Parameter(name &#x3D; “sequence”, value &#x3D; “S_USER_ID”) }) 导入import org.hibernate.annotations.<br>    Parameter,是自动生成oracle序列的方法。调用创建好的序列：S_USER_ID来自动生成。<br>3.@Id &#x2F;&#x2F;说明是主键（@Id此注解不能省略，不然Hibernate在调用po进行ORM操作的时候，会出现错误，千万不要<br>    认为主键不是自增，就不用指定主键了） @GeneratedValue(generator &#x3D; “S_USER_ID”)  &#x2F;&#x2F;主键的生成方式<br> 4.@Table(name &#x3D; “USER”)           &#x2F;&#x2F;指定数据库对应的表<br> 5.@Column(name &#x3D; “USER_NAME”)     &#x2F;&#x2F;数据库字段和类属性对应关系<br>   @Column注解配置项还有很多，具体可以了解javax.persistence的注解说明</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.08/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%202022%E5%B9%B48%E6%9C%8826%E6%97%A5%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><div class="content"><pre><code>    复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。
    Java中所有的实物一样，问题解决都是围绕着类展开的。可以通过创建新类来复用代码，而不必再重头开始编写。可以使用别人已经开发并调试好的类。 在Java中有两种方法来达到代码复用的目的。
   第一种：这种方法非常直观，只需要在新的类中产生现有类的对象。由于新类是有现有类的对象所组成，所以这种方法称为组合。
   第二种：这种方法更细致一些，它按照现有类的类型来创建新类。无需改变现有类的形式，采用现有类的形式并在其中添加新代码。这种神奇的方式称为继承，并且编译器可以完成其中大部分工作。继承是面向对象程序设计的基石之一。
</code></pre>
<p>7.1  组合语法<br>     只需要将对象的引用置于新类中即可。<br>     编译器并不是简单地为每一个引用都创建默认对象，这一点是很有意义的，因为若真要那样做的话，就会在许多情况下增加不必要的负担，如果想初始化这些引用，可以在代码中的下列位置进行：<br>      1、在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。<br>      2、在类的构造器中。<br>      3、就在正要使用这些对象之前，这种方式称为惰性初始化。在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外的负担。<br>      4、使用实例初始化。<br>7.2  继承语法<br>      继承是所有OOP语言和Java语言不可缺少的组成部分。当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是在隐式地从Java的标准根类Object进行继承。<br>      在继承过程中，并不一定非得使用基类的方法。也可以在导出类中添加新方法，其添加方式与在类中添加任意方法一样，即对其加以定义即可。<br>7.2.1  初始化基类<br>      由于现在涉及基类和导出类这两个类，而不是只有一个类，所以要试着想象导出类所产生的结果对象，会有点困惑。从外部看，它就像是一个与基类具有相同接口的新类，或许还会有一些额外的方法和域。但继承并不只是复制基类的接口。当创建了一个导出类的对象时，该对象包含了一个基类的自对象。这个子对象与你用基类直接创建的对象是一样的。二者区别在于，后者来自于外部，而基类的子对象被包装在导出类对象内部。<br>      当然，对基类子对象的正确初始化也是至关重要的，而且也仅有一种方法来保证这一点：在构造器中调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需的所有知识和能力。<br>     下面看懂这段代码就明白上述所讲的内容了：<br>     class Art{<br>     Art(){<br>          System.out.println(“art contructor”);<br>     }<br>}<br>class Drawing extends Art{<br>          Drawing(){<br>               System.out.println(“drawing contructor”);<br>          }<br>}<br>public class Cartoon extends Drawing{<br>     public Cartoon(){<br>          System.out.println(“Cartoon contructor”);<br>     }<br>     public static void main(String[] args) {<br>          Cartoon x &#x3D; new Cartoon();</p>
<pre><code> &#125;
</code></pre>
<p>}<br>运行结果：<br>art contructor<br>drawing contructor<br>Cartoon contructor</p>
<p>带参数的构造器<br>上列中各个类均含有默认的构造器，即这些构造器都不带参数。编译器可以轻松地调用它们是因为不必考虑要传递什么样的参数问题。但是，如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字super显式地编写基类构造器的语句，并且配以适当的参数列表：<br>   class Game{<br>     Game(int i){<br>          System.out.println(“Game contructor”);<br>     }<br>}<br>class BoardGame extends Game{<br>     BoardGame(int i) {<br>          super(11);<br>          System.out.println(“BoardGame contructor”);<br>     }<br>}<br>public class Chess extends BoardGame{<br>     Chess() {<br>          super(11);<br>          System.out.println(“Chess contructor”);<br>     }<br>     public static void main(String[] args) {<br>          new Chess();<br>     }<br>}<br>运行结果：<br>Game contructor<br>BoardGame contructor<br>Chess contructor</p>
<p>其实联想到我在android开发中，当你继承一个activity时，在方法中就会看到super这个关键字。</p>
<p>7.3  代理<br>      第三种关系称为代理，Java并没有提供对它的直接支持。这是继承与组合之间的中庸之道，因为我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该成员对象的所有方法（就像继承）。例如，太空船需要一个控制模块：<br>     public class SpaceShipControls {<br>     void up(int velocity){}<br>     void down(int velocity){}<br>     void left(int velocity){}<br>     void right(int velocity){}<br>}<br>构造太空船的一种方式是使用继承：<br>     public class SpaceShip extends SpaceShipControls{<br>     private String name;<br>     public SpaceShip(String name){<br>          this.name&#x3D;name;<br>     }<br>     public String toString(){<br>          return name;<br>     }<br>     public static void main(String[] args) {<br>          SpaceShip spaceShip &#x3D; new SpaceShip(“NSEA “);<br>          spaceShip.down(1);<br>     }<br>}<br>然而，SpaceShip并非真正的SpaceShipControls类型，即便你可以操作这些方法。更准确地讲，SpaceShip包含SpaceShipControls，与此同时，SpaceShipControls的所有方法在SpaceShip中都暴露了出来。这里如果使用组合也是一样会暴露。但是代理解决了此难题：<br>      public class SpaceShipDelegation {<br>     private String name;<br>     private SpaceShipControls controls&#x3D;new SpaceShipControls();<br>     public SpaceShipDelegation(String name){<br>          this.name&#x3D;name;<br>     }<br>     public void down(int velocity){<br>          controls.down(velocity);<br>     }<br>     public void up(int velocity){<br>          controls.up(velocity);<br>     }<br>     public void left(int velocity){<br>          controls.left(velocity);<br>     }<br>     public void right(int velocity){<br>          controls.right(velocity);<br>     }<br>     public static void main(String[] args) {<br>          SpaceShipDelegation delegation &#x3D; new SpaceShipDelegation(“NSEA”);<br>          delegation.down(1);<br>     }</p>
<p>}</p>
<p>7.4  结合使用组合和继承<br>      同时使用组合和继承是很常见的事，例如：<br>       class Plate{<br>     Plate(int i){<br>          System.out.println(“Plate constructor”);<br>     }<br>}<br>class DinnerPlate extends Plate{<br>     DinnerPlate(int i) {<br>          super(i);<br>          System.out.println(“DinnerPlate constructor”);<br>     }<br>}<br>class Utensil{<br>     Utensil(int i){<br>          System.out.println(“Utensil constructor”);<br>     }<br>}<br>class Spoon extends Utensil{<br>     Spoon(int i) {<br>          super(i);<br>          System.out.println(“Spoon constructor”);<br>     }<br>}<br>class Fork extends Utensil{<br>     Fork(int i) {<br>          super(i);<br>          System.out.println(“Fork constructor”);<br>     }<br>}<br>class Custom{<br>     Custom(int i){<br>          System.out.println(“Custom constructor”);<br>     }<br>}<br>public class PlaceSetting extends Custom{<br>     private Spoon sp;<br>     private Fork frk;<br>     private DinnerPlate pl;<br>     PlaceSetting(int i) {<br>          super(i+1);<br>          sp&#x3D;new Spoon(i+2);<br>          frk&#x3D;new Fork(i+3);<br>          pl&#x3D;new DinnerPlate(i+4);<br>          System.out.println(“PlaceSetting constructor”);<br>     }<br>     public static void main(String[] args) {<br>          new PlaceSetting(9);<br>     }</p>
<p>}<br>运行结果：<br>Custom constructor<br>Utensil constructor<br>Spoon constructor<br>Utensil constructor<br>Fork constructor<br>Plate constructor<br>DinnerPlate constructor<br>PlaceSetting constructor</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.08/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%202022%E5%B9%B48%E6%9C%8825%E6%97%A5%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><div class="content"><h2 id="5-4-this关键字"><a href="#5-4-this关键字" class="headerlink" title="5.4 this关键字"></a>5.4 this关键字</h2><p>如果有同意类型的两个对象a和b，怎么才能让这两个对象都能调用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">peel</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;BananaPeel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BananaPeel</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Banana</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Banana</span>();</span><br><span class="line">        <span class="type">Banana</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Banana</span>();</span><br><span class="line">		a.peel(<span class="number">1</span>);</span><br><span class="line">        b.peel(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译器内部，他们可能是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Banana.peel(a, <span class="number">1</span>);</span><br><span class="line">Banana.peel(b, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>但是我们的代码不能这么写。</p>
<p>如果希望在方法的内部获得对当前对象的引用怎么做？因为这个引用是编译器的引用，没有标识符可用。</p>
<p>但是，有个关键字<code>this</code>。this只能在方法内部使用，表示对“调用方法的那个对象”的引用。</p>
<p>如果在同一个类中调用另一个方法，就不必使用this。</p>
<p>只有当需要明确指出对当前对象的引用时，才需要使用this关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Leaf <span class="title function_">increment</span><span class="params">()</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i= &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Leaf</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line">        x.increment().increment().increment().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.08/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%202022%E5%B9%B48%E6%9C%8825%E6%97%A5%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5_4_1输出结果.png" alt="5_4_1输出结果">

<p>由于increment()通过this关键字返回了对当前对象的引用，所以很容易在一条语句里对同一个对象执行多次操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Apple apple)</span>&#123;</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">peeled</span> <span class="operator">=</span> apple.getPeeled();</span><br><span class="line">        System.out.println(<span class="string">&quot;好吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Peeler</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Apple <span class="title function_">peel</span><span class="params">(Apple apple)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;剥皮&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>&#123;</span><br><span class="line">    Apple <span class="title function_">getPeeled</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Peeler.peel(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassingThis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>().eat(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.08/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%202022%E5%B9%B48%E6%9C%8825%E6%97%A5%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5_4_2输出结果.png" alt="5_4_2输出结果">

<p>Apple需要调用Peeler.peel()方法，它是一个外部的工具方法，将执行由于某种原因而必须放在Apple外部的操作(也许是因为该外部方法要应用于许多不同的类,而你却不想重复这些代码)。为了将其自身传递给外部方法，Apple必须使用this关键字。</p>
<h3 id="5-4-1-在构造器中调用构造器"><a href="#5-4-1-在构造器中调用构造器" class="headerlink" title="5.4.1 在构造器中调用构造器"></a>5.4.1 在构造器中调用构造器</h3><p>可能为一一个类写了多个构造器，有时可能想在-一个构造器中调用另一个构造器，以避免重复代码。可用this关键字做到这一点。</p>
<p>通常写this的时候，都是指‘“这个对象” 或者“ 当前对象”，而且它本身表示对当前对象的引用。在构造器中，如果为this添加了参数列表，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确调用：这样，调用其他构造器就有了直接的途径:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Flower</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">petalCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line">    Flower(<span class="type">int</span> petals) &#123;</span><br><span class="line">        petalCount = petals;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor w/ int arg only, petalCount= &quot;</span> + petalCount);</span><br><span class="line">    &#125;</span><br><span class="line">    Flower(String ss) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor w/ String arg only, s=&quot;</span> + ss);</span><br><span class="line">        s = ss;</span><br><span class="line">    &#125;</span><br><span class="line">    Flower(String s, <span class="type">int</span> petals) &#123;</span><br><span class="line">        <span class="built_in">this</span>(petals);</span><br><span class="line">        <span class="built_in">this</span>.s = s; <span class="comment">// Another use of &quot;this&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;String &amp; int args&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Flower() &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;default constructor (no args)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printPetalCount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;petalCount = &quot;</span> + petalCount + <span class="string">&quot; s = &quot;</span>+ s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Flower</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">        x.printPetalCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main里new了无参的flower，无参的flower用this调用了同一个类里的另一个有两个参数的flower，两参flower故技重施this调用另一个数字参数flower，并且用this做区分，把自己的形参s赋值给了flower.s，数字参数的flower因为形参名称和flower的名称不一样，就没有再用this做区分。</p>
<p>尽管可以使用this调用另一个构造器，但是不能同时调用两个，而且构造器必须在起始处。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    Flower(String s, <span class="type">int</span> petals) &#123;</span><br><span class="line">        <span class="built_in">this</span>(petals);</span><br><span class="line"><span class="comment">//        this(s);</span></span><br><span class="line">        <span class="built_in">this</span>.s = s; <span class="comment">// Another use of &quot;this&quot;</span></span><br><span class="line"><span class="comment">//        this(s);</span></span><br><span class="line"><span class="comment">//        this(petals);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;String &amp; int args&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-2-static的含义"><a href="#5-4-2-static的含义" class="headerlink" title="5.4.2 static的含义"></a>5.4.2 static的含义</h3><p>static方法就是没有this方法。在static方法的内部不能调用非静态方法。反过来倒是可以。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。</p>
<p>Java禁用全局方法，但是在类里置入static方法就可以访问其他的static方法和static域。</p>
<p>有些人认为static方法不是“ 面向对象”的，因为它们的确具有全局函数的语义；使用static 方法时，由于不存在this，所以不是通过“向对象发送消息”的方式来完成的。</p>
<p>要是在代码中出现了大量的static方法，就该重新考虑自己的设计了。</p>
<p>然而，static的概念有其实用之处，许多时候都要用到它。</p>
<h2 id="5-5-清理：终结处理和垃圾回收"><a href="#5-5-清理：终结处理和垃圾回收" class="headerlink" title="5.5 清理：终结处理和垃圾回收"></a>5.5 清理：终结处理和垃圾回收</h2><p>我们了解初始化的重要性，不会忘记初始化，但是常常会忘记同样重要的清理工作，</p>
<p>虽然Java有内存回收机制，但是把一个对象用完之后就弃之不顾的做法不总是安全的，总是有一些特殊情况。</p>
<p>如果你不是使用new创建的对象，获取了一块“特殊的”内存区域，垃圾回收器只知道释放经过new分配的内存，不知道怎么处理这块特殊的内存。</p>
<p>为了应对这种情况，Java允许在类中定义一个finalize()方法，工作原理“假定”是这样的：一旦垃圾回收器准备好了释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生的时候，才会真正回收对象占用的内存。要是打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。</p>
<p>有个陷阱，finalize和C++的析构函数不一样</p>
<ul>
<li>在C++中，对象一定会被销毁（如果程序没有缺陷），而Java对象并非总是被销毁</li>
<li>对象可能不被垃圾回收机制回收</li>
<li>垃圾回收并不等于“析构”</li>
</ul>
<p>Java并未提供“析构函数或者相似的概念，如果需要，得自己手动创建一个普通方法。</p>
<h3 id="5-5-1-fianlize-的用途何在"><a href="#5-5-1-fianlize-的用途何在" class="headerlink" title="5.5.1 fianlize()的用途何在"></a>5.5.1 fianlize()的用途何在</h3><p>要记住垃圾回收只与内存有关。</p>
<p>无论对象是如何创建的，垃圾回收机制都会负责释放对象占据的所有内存。这就对fianlize进行限制，通过某种创建对象的方式以外的方式为对象分配了空间。</p>
<p>在Java中，一切皆为对象，这种特殊情况不太正常。</p>
<p>之所以有finalize，是在分配内存时可能采用了类似C的做法，而不是Java的通常做法。</p>
<p>Java可以调用其他语言的代码，也会会调用C的malloc来分配存储空间，而且除非调用了free函数，否则本地空间不会被释放，从而造成内存泄露。</p>
<p>尽然finalize不能过多的使用，他不是普通的清理工作的合适场所，那么普通的清理工作应该在哪里？</p>
<h3 id="5-5-2-你必须实施清理"><a href="#5-5-2-你必须实施清理" class="headerlink" title="5.5.2 你必须实施清理"></a>5.5.2 你必须实施清理</h3><p>要清理一个对象，必须在需要清理的时刻调用执行清理动作的方法。</p>
<p>在Java中，不允许创建局部对象，必须使用new创建对象，在花括号的右边界对象会被自动清理。</p>
<p>但是无论是<code>垃圾回收</code>还是<code>终结</code>，都不保证一定会终结。在jvm内存没有即将耗尽之前，是不会浪费时间去执行垃圾回收来恢复内存的。</p>
<h3 id="5-5-3-终结条件"><a href="#5-5-3-终结条件" class="headerlink" title="5.5.3 终结条件"></a>5.5.3 终结条件</h3><p>很多时候不能使用finalize，必须用其他的清理方法，并且明确的进行调用。</p>
<p>finalize有一个有趣的用法，并不依赖于每次都要对finalize进行调用，这就是对象<code>终结条件</code>的验证。</p>
<p>当某个对象不再被感兴趣了，他就可以被清理了，这个对象应该处于一种内存可以被安全释放的状态，</p>
<p>如果对象代表了一个打开的文件，在对象被回收之前应该关闭这个文件，如果没有，程序就会存在缺陷，finalize可以用来发现这种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">checkedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Book (<span class="type">boolean</span> checkOut)&#123;</span><br><span class="line">        checkedOut = checkOut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkIn</span><span class="params">()</span>&#123;</span><br><span class="line">        checkedOut = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkedOut)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error : checked Out&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminationCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">novel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">        novel.checkIn();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的Book对象在被回收之前都应该被checkin，但是在main方法里，有点疏漏，一本新的书没有被签入，如果没有finalize验证，将很难发现这种缺陷。</p>
<p><code>System.gc()</code>用来强制进项终结动作。</p>
<h3 id="5-5-4-垃圾回收器如何工作"><a href="#5-5-4-垃圾回收器如何工作" class="headerlink" title="5.5.4 垃圾回收器如何工作"></a>5.5.4 垃圾回收器如何工作</h3><p>垃圾回收器能显著提高对象的创建速度。</p>
<p>C++里，堆是一个院子，在Java中，堆更像一个传送带，每分配一个，就往前移动一格。</p>
<p>Java中，堆也不完全像传送带那样工作（那样会导致频繁的页面调度）。</p>
<p>垃圾回收器工作的时候，一遍回收空间，一遍使堆中的对象紧凑排列，这样“堆指针”就可以很容易的移动到更靠近传送带的开始处。通过垃圾回收器对对象的重新排列，实现了高速、有无限空间可分配的堆模型。</p>
<p>先了解其他系统的垃圾回收机制</p>
<p><code>引用记数</code> 是一种简单但速度很慢的回收技术。</p>
<p>每个对象都含有一个引用记数器，当有引用连接至对象的时候，引用记数+1，当引用离开作用域或者被置于null时，记数器-1。虽然引用记数开销不大，但是这开销会在整个声明周期中将持续发生。</p>
<p>垃圾回收器会在全部对象的列表上遍历，当发现某个对象的引用计数器为0的时候，就释放占用的空间（引用记数模式会在记数值变成0时立即释放）。</p>
<p>但是这样有一个问题，如果对象之间循环引用，就可能会出现“虽然计数器不为0，但是对象应该被回收”的情况。所以引用计数器只是用来说明垃圾收集的工作方式，但是似乎从未被应用于任何一种Java虚拟机中实现。</p>
<p>还有一种更快的方法，并非基于引用记数，他的思想是，对于任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。这个引用链条可能会穿过数个对象层次，由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是这个对象所包含的所有引用，如此反复，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。</p>
<p>这里所访问过的对象必须是“活”的，这就解决了对象之间循环引用的问题，这种现象根本不会被发现，因此也就被自动回收了。</p>
<p>Java虚拟机将采用一种“自适应”的垃圾回收技术，至于如何找到存活的对象取决于不同的jvm。</p>
<p>有一种<code>停止-复制</code>（stop-and-copy）的做法，这意味着，先暂停程序的运行（所以不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，如果没有被复制的就是垃圾。当对象被复制到新堆时，他们是一个挨着一个的，所以新堆的排列紧凑，就可以简单直接的分配空间了。</p>
<p>当把对象从一处搬到另一处时，所有指向他的引用都需要修正，在堆和静态存储区的引用可以直接被修正，但是可能还有其他指向这些对象的引用，只有在遍历过程中才能被找到。</p>
<p>这种所谓的“复制式回收器”，效率会降低，这有两个原因</p>
<ol>
<li>空间。需要两个堆，在两个分离的堆里来回复制，需要比实际多一倍的空间。某些Java虚拟机对这种问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。</li>
<li>复制。程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有的内存都复制，这很浪费。为了避免浪费，一些Java虚拟机会进行检查，要是没有新垃圾，就会转换到另一种“自适应”模式——“标记-清扫”。</li>
</ol>
<p>一般情况下“标记-清扫”可能会比较慢，但是当你知道只会产生少量垃圾甚至不会产生垃圾的时候，他的速度就会很快了。</p>
<p>“标记-清扫”所依据的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当找到一个存活的对象，就会给对象一个标记，过程中不会回收任何对象，只有全部标记完成后，才会开始清理。清理过程中，没有被标记的对象将会被释放，不会复制。所以剩下的堆空间是不连续的，如果想获得连续空间，就得重新整理剩下的对象。</p>
<p>“停止-复制”的意思是这种垃圾回收动作不是在后台运行的。垃圾回收的同时，程序将会被暂停。当可用内存较低的时候，垃圾回收机制会暂停运行程序。</p>
<p>jvm中，内存分配以较大的“块”为单位。如果对象较大会占用单独的块。</p>
<p>“停止-复制”要求在释放旧有对象之前，必须先把所有存活对象从旧堆复制到新堆，会有大量内存复制行为。</p>
<p>有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝。</p>
<p>每个块都用相应的代数（generation count）来记录是否存活。如果块在某处被引用，代数会增加。垃圾回收器会对上次回收动作之后新分配的块进行整理，对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作，大型对象仍然不会被复制，只是代数会增加，小型对象的那些块会被复制并整理。</p>
<p>虚拟机会进行监视，如果对象稳定，垃圾回收器效率低，就会切换到“标记-清扫”模式，如果碎片多，就会切换到“停止-复制”模式。</p>
<p>Java虚拟机有许多附加技术用以提升速度。</p>
<p>加载器操作有关的Just-InTime JIT（即时）技术。可以把程序全部或者部分翻译成本地机器码（jvm的操作），程序运行速度会得到提升。当需要装载某个类时（通常是为该类创建第一个对象的时候），编译器会先找到class文件，把字节码装入内存。</p>
<p>此时，有两种方案可供选择。</p>
<ul>
<li>一种是就让即时编译器编译所有代码。但这种做法有两个缺陷:<ul>
<li>这种加载动作散落在整个程序生命周期内，累加起来要花更多时间</li>
<li>并且会增加可执行代码的长度(字节码要比即时编译器展开后的本地机器码小很多)，这将导致页面调度，从而降低程序速度。</li>
</ul>
</li>
<li>另一种做法称为惰性评估(lazy evaluation),意思是即时编译器只在必要的时候才编译<br>代码。这样，从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的Java HotSpot技术就采用了类似方法，代码每次被执行的时候都会做一些优化，所以执行的次数越多，它的速度就越快。</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/19/hwcd/%E6%97%A5%E5%BF%97/2022.08/2022%E5%B9%B48%E6%9C%8831%E6%97%A5/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-19</time><div class="content"><h3 id="启动小程序"><a href="#启动小程序" class="headerlink" title="启动小程序"></a>启动小程序</h3><p>问题：网页端一直在登录后转圈</p>
<p>解决过程：询问祝君祝哥 了解到app端只能真机运行或者 模拟器运行</p>
<p>结果：能够正常运行</p>
<h3 id="启动网页端"><a href="#启动网页端" class="headerlink" title="启动网页端"></a>启动网页端</h3><p>问题：app端找不到需要修改的页面</p>
<p>解决过程：询问祝君祝哥 证实后台界面有一个单独的前端 询问李泰来李哥后在云效上加入公司团队，获取到代码</p>
<p>结果：能够正常运行</p>
<h3 id="注掉审核接口"><a href="#注掉审核接口" class="headerlink" title="注掉审核接口"></a>注掉审核接口</h3><p>问题： 是要把后台审核的接口注释掉就行是吗 前端界面需要也注掉吗</p>
<p>解决过程： 询问宋志文经理，得到答复。下午又确认app端的接口也需要隐藏</p>
<p>结果：已经隐藏了前端界面的目录入口和后端的接口，app端正在尝试</p>
<h3 id="git提交"><a href="#git提交" class="headerlink" title="git提交"></a>git提交</h3><p>问题：查看git记录发现似乎是每个人一个分支，不清楚公司代码提交相关内容</p>
<p>解决过程：询问李哥，了解相关内容</p>
<p>结果：学习git相关命令</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/09/01/Git/4_%E6%97%B6%E5%85%89%E7%A9%BF%E6%A2%AD%E6%9C%BA/">时光穿梭机</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-09-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6/">自学</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6/Git/">Git</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%BB%96%E9%9B%AA%E5%B3%B0/">廖雪峰</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%BB%96%E9%9B%AA%E5%B3%B0/Git%E6%95%99%E7%A8%8B/">Git教程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Git/">Git</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%BB%96%E9%9B%AA%E5%B3%B0/">廖雪峰</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E8%87%AA%E5%AD%A6/">自学</a></span><div class="content"><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><p>版本管理 可以任意选择各个时间创建的版本 就像时光机一样</p></div><a class="more" href="/2022/09/01/Git/4_%E6%97%B6%E5%85%89%E7%A9%BF%E6%A2%AD%E6%9C%BA/#more">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By 十早九木</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>