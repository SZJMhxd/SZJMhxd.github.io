<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>十早九木のBlog</title>
  
  
  <link href="https://www.szjm.online/atom.xml" rel="self"/>
  
  <link href="https://www.szjm.online/"/>
  <updated>2022-08-23T08:10:43.811Z</updated>
  <id>https://www.szjm.online/</id>
  
  <author>
    <name>十早九木</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一切都是对象</title>
    <link href="https://www.szjm.online/2022/08/23/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.szjm.online/2022/08/23/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-08-23T02:41:35.000Z</published>
    <updated>2022-08-23T08:10:43.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-一切都是对象"><a href="#2-一切都是对象" class="headerlink" title="2. 一切都是对象"></a>2. 一切都是对象</h1><blockquote><p>“如果我们说另一种不同的语言,那么我们就会发觉一个有些不同的世界。”<br>——Luduing Wittgerstein (1889-1951)</p></blockquote><p>尽管Java是基于C++的，但是相比之下，Java是一种更“ 纯粹”的面向对象程序设计语言。 <span id="more"></span>     </p><p><strong>学习Java需要有面向对象编程的思想</strong></p><h2 id="2-1-用引用操纵对象"><a href="#2-1-用引用操纵对象" class="headerlink" title="2.1 用引用操纵对象"></a>2.1 用引用操纵对象</h2><p>Java中一切都被视为对象，但是操作标识符是引用（reference）。</p><p>用遥控器(引用)来操纵电视机(对象)。只要握住这个遥控器，就能保持与电视机的连接。当有人想改变频道或者减小音量时，实际操控的是遥控器(引用), 再由遥控器来调控电视机(对象)。如果想在房间里四处走走，同时仍能调控电视机,那么只需携带遥控器(引用)而不是电视机(对象)。</p><p>此外，即使没有电视机，遥控器亦可独立存在。也就是说，你拥有一个引用，并不一定需要有一个对象与它关联。</p><p>操作一个词或者句子，创建一个String类型引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure><p>这里只是创建引用，字符串s没有内容，并不是对象。此时s没有与任何事物相关联。安全的做法是给他赋值，初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;asdf&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="2-2-必须由你创建所有的对象"><a href="#2-2-必须由你创建所有的对象" class="headerlink" title="2.2 必须由你创建所有的对象"></a>2.2 必须由你创建所有的对象</h2><p>引用需要与对象关联，通常使用new操作符实现。new关键字的意思”给我一个新对象”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;asdf&quot;</span>);</span><br></pre></td></tr></table></figure><p>不仅有new表示“给我一个新的字符串”，而且提供了一个初始字符串，给出了怎样产生这个String的信息。</p><p>Java提供了很多现成的类型，而且可以自行创建类型。</p><h3 id="2-2-1-存储到什么地方"><a href="#2-2-1-存储到什么地方" class="headerlink" title="2.2.1 存储到什么地方"></a>2.2.1 存储到什么地方</h3><p>一共5个地方可以存储</p><ol><li><strong>寄存器</strong>  最快，在处理器里，但地方小，你不能控制。</li><li><strong>堆栈</strong>  位于通用RAM(随机访问存储器) 。快速有效，但是需要知道所有项确切的生命周期，约束了灵活性。有些数据存储于堆栈中（对象引用），但是java不存储在堆栈中。</li><li><strong>堆</strong>  位于通用内存池（也位于RAM区），用于存放Java对象。<ul><li>好处  不需要知道存储的数据的生命周期 有很大的灵活性。运行new的代码时候，会自动在堆中进行内存分配</li><li>坏处  用堆进行分配和清理可能比用堆栈需要更多的时间</li></ul></li><li><strong>常量存储</strong>  常量通常直接在代码内部。安全，不会被改变。在嵌入式中，可以选择存放在ROM中。</li><li><strong>非RAM存储</strong>  存活于程序之外，可以不受程序的控制，程序没有运行时也可以存在。<ul><li>流对象  转化成字节流，通常被发送给另一台机器</li><li>持久化对象  被存放在磁盘上，程序终止时，可以保持自己的状态。把对象转化成存放在其他媒介的事物上，需要时再恢复成常规的基于RAM的对象</li></ul></li></ol><h3 id="2-2-2-特例：基本类型"><a href="#2-2-2-特例：基本类型" class="headerlink" title="2.2.2 特例：基本类型"></a>2.2.2 特例：基本类型</h3><p>用new创建小而简单的变量效率不高，这些变量不会用new创建，而是创建一个并非是引用的“自动”变量，直接存储值并且至于堆栈中，更加高效。</p><p>Java需要确定每种基本类型所占存储空间的大小，而且不会随着机器硬件变化，这是Java高可移植性的原因之一。</p><img src="/2022/08/23/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_2_2_1Java基本类型.png" alt="2_2_2_1Java基本类型"><p>所有数值类型都有正负号，不需要寻找无符号的数值类型。</p><h4 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h4><p>boolean类型没有明确大小，只有true和false</p><p>基本类型具有的包装器类，可以在堆中创建一个非基本对象，用来表示对应的基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br></pre></td></tr></table></figure><p>也可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在可以直接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br></pre></td></tr></table></figure><p>还能反过来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ch;</span><br></pre></td></tr></table></figure><h4 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h4><ul><li>BigInteger支持任意精度的整数。也就是说，在运算中，可以准确地表示任何大小的整数值，而不会丢失任何信息。</li><li>BigDecimal支持任何精度的定点数，例如，可以用它进行精确的货币计算。</li></ul><h3 id="2-2-3-Java中的数组"><a href="#2-2-3-Java中的数组" class="headerlink" title="2.2.3 Java中的数组"></a>2.2.3 Java中的数组</h3><p>几乎所有的程序设计语言都支持数组。在C和C++中数组是内存块，不安全。</p><p>Java中注重安全，会确保数组被初始化，也不能在范围之外被访问。范围检查用内存开销和下标检查为代价换取安全性和高效率。</p><p>数组其实是创建了一个引用，每个引用都会被初始化为特定值，拥有特定关键字null。</p><p>试图使用还是null的引用会报错，必须为他指定一个对象。</p><h2 id="2-3-永远不需要销毁对象"><a href="#2-3-永远不需要销毁对象" class="headerlink" title="2.3 永远不需要销毁对象"></a>2.3 永远不需要销毁对象</h2><p>变量需要存活多长时间？什么时候应该销毁对象？</p><h3 id="2-3-1-作用域"><a href="#2-3-1-作用域" class="headerlink" title="2.3.1 作用域"></a>2.3.1 作用域</h3><p>过程型语言都有作用域概念，决定了定义的变量名的可见性和生命周期。</p><p>在C C++ JAVA中，作用域由花括号<code>&#123;&#125;</code>决定 作用域里定义的变量只可用于作用域结束之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//只有x</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">96</span></span><br><span class="line">        <span class="comment">//x和q    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有x</span></span><br><span class="line">    <span class="comment">//q不在作用域的范围里了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然说java是一种自由格式的语言，多余的空格、制表符、换行都不会影响程序执行的结果，但是较为严格的缩进会更易于代码的阅读。</p><h3 id="2-3-2-对象的作用域"><a href="#2-3-2-对象的作用域" class="headerlink" title="2.3.2 对象的作用域"></a>2.3.2 对象的作用域</h3><p>对象和基本类型的生命周期不一样。new的对象可以存活于作用域之外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a String&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//作用域结束</span></span><br></pre></td></tr></table></figure><p>引用在作用域结束时就消失了，但是s指向的对象仍然占据着内存空间。无法在作用域之后访问这个对象，唯一对它的引用已经超出了作用域范围。</p><p>用new创建的对象，只要需要，就会一直保留下去。这些一直存在的对象会不会塞满内存空间？在C++可能会遇到的问题，在Java中不会存在，因为Java有内存回收机制，你只管创建，不用了Java自己会回收。</p><h2 id="2-4-创建新的数据类型：类"><a href="#2-4-创建新的数据类型：类" class="headerlink" title="2.4 创建新的数据类型：类"></a>2.4 创建新的数据类型：类</h2><p>一切都是对象，怎么区分对象的类型？</p><h3 id="2-4-1-字段和方法"><a href="#2-4-1-字段和方法" class="headerlink" title="2.4.1 字段和方法"></a>2.4.1 字段和方法</h3><p>类有两种元素：字段（属性、数据成员）和方法（成员函数）。</p><p>字段可以是任何类型的对象，也可以是基本类型的一种，如果字段是对某个对象的引用，那么必须初始化改引用。</p><p>每个对象都有存储字段的空间，普通字段不能在对象间共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataOnly</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">boolean</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管这个类只有字段没有方法，只能存储数据，但是仍然可以new</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataOnly</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOnly</span>();</span><br></pre></td></tr></table></figure><p>还可以给类里的字段赋值，句式是objectReference.member</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.i = <span class="number">47</span>;</span><br><span class="line">data.d = <span class="number">1.1</span>;</span><br><span class="line">data.b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果字段不是基本类型而是一个对象，你需要修改再下的字段，只需要<code>.</code>下去就行了</p><p>如果需要了解成员方法的运行机制，就需要了解<code>参数</code>和<code>返回值</code></p><h4 id="基本成员默认值"><a href="#基本成员默认值" class="headerlink" title="基本成员默认值"></a>基本成员默认值</h4><p>类里的基本数据类型即使没有初始化，Java也会给一个默认值。</p><p><strong>当变量作为累的成员使用时，Java才确保给默认值</strong></p><p>如果是“局部”变量，而不是某个类的字段，可能会得到任意值，而不是被初始化为0。如果没有初始化Java会在编译时直接报错。</p><img src="/2022/08/23/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_4_1_1基本类型默认值对照表.png" alt="2_4_1_1基本类型默认值对照表"><h2 id="2-5-方法、参数和返回值"><a href="#2-5-方法、参数和返回值" class="headerlink" title="2.5 方法、参数和返回值"></a>2.5 方法、参数和返回值</h2><p>与其他编程语言用函数来描述子程序不同，Java使用<strong>方法</strong>来描述“做某些事的方式”（就是属于不一样了而已）。</p><p>方法决定了一个对象能接收什么样的消息。方法的基本组成包括名称、参数、返回值和方法体。</p><p>返回类型是调用方法后从方法返回的值。</p><p>Java的方法只能作为类的一部分来创建，只有通过对象才能被调用。句式是<code>对象名.方法名(参数)</code></p><p>如果对象a下有一个f()方法返回值是int 就可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.f();</span><br></pre></td></tr></table></figure><h3 id="2-5-1-参数列表"><a href="#2-5-1-参数列表" class="headerlink" title="2.5.1 参数列表"></a>2.5.1 参数列表</h3><p>参数列表指定给方法传递的信息。</p><p>方法结束用<code>return</code>表示已经完成 离开此方法，并且可以把方法产生的值放在return后面返回</p><p>如果没有想返回的值，可以修改方法的返回类型为<code>void</code>就不会有返回值，也不用写return</p><h2 id="2-6-构建一个Java程序"><a href="#2-6-构建一个Java程序" class="headerlink" title="2.6 构建一个Java程序"></a>2.6 构建一个Java程序</h2><h3 id="2-6-1-名字可见性"><a href="#2-6-1-名字可见性" class="headerlink" title="2.6.1 名字可见性"></a>2.6.1 名字可见性</h3><p>翻转域名来确保唯一性，其他的包用<code>.</code>划分目录</p><h3 id="2-6-2-运用其他构建"><a href="#2-6-2-运用其他构建" class="headerlink" title="2.6.2 运用其他构建"></a>2.6.2 运用其他构建</h3><p>想导入包，需要先知道包在哪</p><p>比如你想使用ArrayList类 就这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure><p>还想使用<code>java.util</code>下的其他包，又不想一个一个写出来，可以用通配符<code>*</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><h3 id="2-6-3-static-关键字"><a href="#2-6-3-static-关键字" class="headerlink" title="2.6.3 static 关键字"></a>2.6.3 static 关键字</h3><p>创建类时只是在描述这个类有什么字段和方法，只有这个类被new出来的时候才被分配数据存储空间。</p><p>如果只想为某特定区域分配单一存储空间，根本不想创建对象，或者不希望方法与包含的类关联在一起。就是不创建对象也想调用方法的时候，可以使用<code>static</code>关键字。</p><p>当声明一个事物是static时，意味着这个域或者这个方法不会与包含着那个类的任何对象有实际联系。即使从未创建某个类的任何对象，也可以调用他的static方法或者访问他的static域。</p><p>只需要将static关键字放在定义之前，字或者方法就会被设定为static。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTest</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使你创建了两个StaticTest对象，StaticTest.i也是公用一个存储空间，共享一个i</p><p>如果你修改其中一个i的值，另一个i的值也会一起改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StaticTest</span> <span class="variable">st1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTest</span>();</span><br><span class="line"><span class="type">StaticTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTest</span>();</span><br><span class="line">System.out.println(st1.i);<span class="comment">//47</span></span><br><span class="line">System.out.println(st2.i);<span class="comment">//47</span></span><br><span class="line">st1.i += <span class="number">1</span>;</span><br><span class="line">System.out.println(st1.i);<span class="comment">//48</span></span><br><span class="line">System.out.println(st2.i);<span class="comment">//48</span></span><br><span class="line">st2.i += <span class="number">2</span>;</span><br><span class="line">System.out.println(st1.i);<span class="comment">//50</span></span><br><span class="line">System.out.println(st2.i);<span class="comment">//50</span></span><br></pre></td></tr></table></figure><p>对于static变量，可以直接用类名引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(StaticTest.i);<span class="comment">//50</span></span><br></pre></td></tr></table></figure><p>这种方式也可以定义静态方法，只要在方法前面加上static关键字</p><p>对于static字段来说他的用处可能是共用一个地址一个字段保持数据一致，但是对于static方法来说他的重要用途就是可以直接用类名引用方法，省去一个new。对于main()方法很重要。</p><h2 id="2-7-你的第一个Java程序"><a href="#2-7-你的第一个Java程序" class="headerlink" title="2.7 你的第一个Java程序"></a>2.7 你的第一个Java程序</h2><p>编写一个完整的程序，打印一个字符串，然后打印一个日期（用标准库中的date类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HelloDate.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello,it&#x27;s: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序文件开头要声明import引入额外类（特定类在java.lang下，这些是不用导入的）</p><img src="/2022/08/23/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_7_1java文档.png" alt="2_7_1java文档"><p>而我们所需要打印的日期类（Date）不在java.long下，就需要手动import</p><p>在java.long下 我们还能看见System 这里有有关输出的语法解释</p><img src="/2022/08/23/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_7_2system.png" alt="2_7_2system"><p>类的名字必须和文件名相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDate</span>&#123;</span><br></pre></td></tr></table></figure><p>类中必须包含一个main()方法，程序会从这里开始运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br></pre></td></tr></table></figure><p>其中public表示这是一个公有的方法，可以由外部调用</p><p>参数是一个String对象的数组</p><p>这个程序没有用到args，但是Java编译器要求要用args来存储命令行参数</p><p>打印日期代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure><p>这里传出来的是一个Date对象，创建完成后他的值就会被自动转换为String类型然后发送给println()。</p><p>这个语句执行完毕后Date对象将不再被使用，Java的垃圾回收器会发现并回收这个对象释放内存。</p><p><strong>system的其他用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ShowProperties.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShowProperties</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.getProperties().list(System.out);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;user.name&quot;</span>));</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.library.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-1-编译和运行"><a href="#2-7-1-编译和运行" class="headerlink" title="2.7.1 编译和运行"></a>2.7.1 编译和运行</h3><p>安装好java环境后 编译代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloDate.java</span><br></pre></td></tr></table></figure><p>然后运行编译后的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloDate</span><br></pre></td></tr></table></figure><h2 id="2-8-注释和嵌入式文档"><a href="#2-8-注释和嵌入式文档" class="headerlink" title="2.8 注释和嵌入式文档"></a>2.8 注释和嵌入式文档</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">阿巴巴巴</span></span><br><span class="line"><span class="comment">阿巴阿巴阿巴</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行阿巴阿巴阿巴</span></span><br></pre></td></tr></table></figure><h3 id="2-8-1-注释文档"><a href="#2-8-1-注释文档" class="headerlink" title="2.8.1 注释文档"></a>2.8.1 注释文档</h3><p>写程序得有文档，如果代码和文档是分离的，那么每次修改代码都得修改相应的文档</p><p>javadoc解决这一问题，可以自动把注释和毗邻的类名和方法名抽取出来输出一个HTML文件</p><h3 id="2-8-2-语法"><a href="#2-8-2-语法" class="headerlink" title="2.8.2 语法"></a>2.8.2 语法</h3><p>所有javadoc的命令都只能在<code>/**</code>中体现（在IDEA中，在接口代码前输入<code>/**</code>回车会自动生成相关格式）</p><img src="/2022/08/23/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_8_2_1自动生成javadoc相关格式.png" alt="2_8_2_1自动生成javadoc相关格式"><p>注意javadoc只能为public（公共）和protected（受保护）两种类型的成员生成文档注释，另外两种类型的注释会被忽略掉。（也只有public和protected的成员能在文件外被使用，这两种类型的文档才有意义）</p><h3 id="2-8-3-嵌入式HTML"><a href="#2-8-3-嵌入式HTML" class="headerlink" title="2.8.3 嵌入式HTML"></a>2.8.3 嵌入式HTML</h3><p>能生成就行了</p><h4 id="2-8-4-一些标签示例"><a href="#2-8-4-一些标签示例" class="headerlink" title="2.8.4 一些标签示例"></a>2.8.4 一些标签示例</h4><p>用的时候再看 在书的85页 PDF的67页</p><p>有作者有时间有版本有输入输出有异常抛出就行</p><h3 id="2-8-5-文档示例"><a href="#2-8-5-文档示例" class="headerlink" title="2.8.5 文档示例"></a>2.8.5 文档示例</h3><p>按照自己喜好来就行啦</p><h2 id="2-9-编码风格"><a href="#2-9-编码风格" class="headerlink" title="2.9 编码风格"></a>2.9 编码风格</h2><p>为了大家看着都舒服而建立的一套规则，一般记得遵守<strong>驼峰命名法</strong>即可，其他的东西可以看《阿里巴巴Java开发手册》</p><h2 id="2-10-总结"><a href="#2-10-总结" class="headerlink" title="2.10 总结"></a>2.10 总结</h2><p>对简单编写的HelloDate有较为深入的了解，知道是怎么回事了。</p><h2 id="2-11-练习"><a href="#2-11-练习" class="headerlink" title="2.11 练习"></a>2.11 练习</h2><img src="/2022/08/23/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_11_1练习题目.png" alt="2_11_1练习题目">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2-一切都是对象&quot;&gt;&lt;a href=&quot;#2-一切都是对象&quot; class=&quot;headerlink&quot; title=&quot;2. 一切都是对象&quot;&gt;&lt;/a&gt;2. 一切都是对象&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;“如果我们说另一种不同的语言,那么我们就会发觉一个有些不同的世界。”&lt;br&gt;——Luduing Wittgerstein (1889-1951)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管Java是基于C++的，但是相比之下，Java是一种更“ 纯粹”的面向对象程序设计语言。&lt;/p&gt;</summary>
    
    
    
    <category term="hwca" scheme="https://www.szjm.online/categories/hwca/"/>
    
    <category term="java" scheme="https://www.szjm.online/categories/hwca/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/categories/hwca/java/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/categories/hwca/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="hwca" scheme="https://www.szjm.online/tags/hwca/"/>
    
    <category term="java" scheme="https://www.szjm.online/tags/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>对象导论</title>
    <link href="https://www.szjm.online/2022/08/22/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/"/>
    <id>https://www.szjm.online/2022/08/22/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</id>
    <published>2022-08-22T10:01:27.000Z</published>
    <updated>2022-08-23T00:58:48.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-对象导论"><a href="#1-对象导论" class="headerlink" title="1. 对象导论"></a>1. 对象导论</h1><blockquote><p>我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来…除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。</p><p>——Benjamin Lee Whorf (1897 ~ 1941)</p></blockquote><p>​        计算机有更多的用途，越来越不像机器，有多种表达方式。<strong>面向对象程序设计(Object-oriented Programming, OOP)便是这种以计算机作为表<br>达媒体的大趋势中的组成部分。</strong><span id="more"></span></p><h2 id="1-1-抽象过程"><a href="#1-1-抽象过程" class="headerlink" title="1.1 抽象过程"></a>1.1 抽象过程</h2><p><strong>所有的编程语言都提供抽象机制。</strong>汇编语言是对底层机器语言的轻微抽象。（把一堆0011编程<code>jump $</code> ?）</p><p>命令语言在汇编的基础上有改进，但是模型需要自己建立，费力，维护代价高，产生了“编程方法”行业。</p><p>另一种对机器建模的方式，只对待解决的问题建模，只针对特定领域。</p><p>面向对象方式通过向程序员提供表示问题空间中的元素的工具而更进一步。这种表示方式非常通用，使得程序员不会受限于任何特定类型的问题。<strong>我们将问题空间中的元素及其在解空间中的表示称为“对象”。</strong>这种思想的实质是：程序可以通过添加新类型的对象使自身适用于某个特定问题。相比以前我们所使用的语言，这是一种更灵活和更强有力的语言抽象。所以，OOP允许<strong>根据问题来描述问题</strong>，而不是根据运行解决方案的计算机来描述问题。</p><p>Alan Kay曾经总结了第一个成功的面向对象语言、同时也是Java所基于的语言之一的Smalltak的五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式：</p><ol><li>万物皆为对象。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件(狗、建筑物、服务等)，将其表示为程序中的对象。</li><li>程序是对象的集合，它们通过发送消息来告知彼此所要做的。要想请求一个对象，就必须对该对象发送一条消息。 更具体地说，可以把消息想像为对某个特定对象的方法的调用请求。</li><li>每个对象都有自己的由其他对象所构成的存储。换句话说，可以通过创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。</li><li>每个对象都拥有其类型。按照通用的说法，“每个对象都是某个类(class) 的一个实例(instance)”，这里“类”就是“类型”的同义词。每个类最重要的区别于其他类的特性就是“可以发送什么样的消息给它”。</li><li>某一特定类型的所有对象都可以接收同样的消息。这是一句意味深长的表述，你在稍后便会看到。因为“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这意味着可以编写与“几何形”交互并自动处理所有与几何形性质相关的事物的代码。这种可替代性(substitutability) 是OOP中最强有力的概念之一。</li></ol><p>Booch对对象提出了一个更加简洁的描述：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据(它们给出了该对象的状态)和方法(它们产生行为),并且每一个对象都可以唯一地与其他对象区分开来，具体说来，就是每一个对象在内存中都有一个唯一的地址。</p><h2 id="1-2-每个对象都有一个接口"><a href="#1-2-每个对象都有一个接口" class="headerlink" title="1.2 每个对象都有一个接口"></a>1.2 每个对象都有一个接口</h2><p>所有的对象都是唯一的， 但同时也是具有相同的特性和行为的对象所归属的类的一部分。</p><p>这种思想被直接应用于第一个面向对象语言Simula-67,它在程序中使用基本关键字class来引入新的类型。<br>Simula是为了开发诸如经典的“ 银行出纳员问题”(bank teller problem)这样的仿真程序而创建的。</p><p>在银行出纳员问题中，有出纳、客户、账户、交易和货币单位等许多“对象”。在程序执行期间具有不同的状态而其他方面都相似的对象会被分组到对象的类中，这就是关键字class的由来。</p><p>创建抽象数据类型(类)是面向对象程序设计的基本概念之一。抽象数据类型的运行方式与内置(built-in) 类型几乎完全一致:你可以创建某一类型的变量(按照面向对象的说法，称其为对象或实例)，然后操作这些变量(称其为发送消息或请求；发送消息，对象就知道要做什么)。每个类的成员或元素都具有某种共性:每个账户都有结余金额，每个出纳都可以处理存款请求等。同时，每个成员都有其自身的状态:每个账户都有不同的结余金额，每个出纳都有自己的姓名。因此，出纳、客户、账户、交易等都可以在计算机程序中被表示成唯一的实体。这些实体就是对象，每一个对象都属于定义了特性和行为的某个特定的类。</p><p>程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。</p><p><strong>可以根据需求，通过添加新的数据类型来扩展编程语言。</strong>编程系统欣然接受新的类，并且像对待内置类型一样地照管它们和进行类型检查。</p><p>一旦类被建立，就可以随心所欲的创建类的任意个对象，然后去操作。</p><p>有用的对象，必须有某种方式产生对对象的请求，使对象完成各种任务。</p><img src="/2022/08/22/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_2_1用灯泡来举例.png" alt="1_2_1用灯泡来举例"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Light</span> <span class="variable">lt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">lt.on();</span><br></pre></td></tr></table></figure><p>接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码。这些代码与隐藏的数据一起构成了实现。</p><p>在类型中，每一个可能的请求都有一个方法与之相关联，当向对象发送请求时，与之相关联的方法就会被调用。此过程通常被概括为: <strong>向某个对象“ 发送消息”(产生请求)</strong>,这个对象便知道此消息的目的，然后执行对应的程序代码。</p><h2 id="1-3-每个对象都提供服务"><a href="#1-3-每个对象都提供服务" class="headerlink" title="1.3 每个对象都提供服务"></a>1.3 每个对象都提供服务</h2><p>当正在试图开发或理解-一个程序设计时,最好的方法之一就是将对象想像为“服务提供者”。</p><p>程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这-一目的。你的目标就是去创建(或者最好是在现有代码库中寻找)能够提供理想的服务来解决问题的一系列对象。</p><p>将对象看作是服务提供者还有一个附带的好处:它有助于提高对象的内聚性。</p><p><strong>高内聚</strong>是软件设计的基本质量要求之一：这意味着一个软件构件(例如一个对象，当然它也有可能是指一个方法或一个对象库)的各个方面“组合”得很好。人们在设计对象时所面临的一个问题是，将过多的功能都塞在一个对象中。</p><p>例如，在检查打印模式的模块中，你可以这样设计一个对象，让它了解所有的格式和打印技术。</p><p>你可能会发现，这些功能对于一个对象来说太多了，你需要的是三个甚至更多个对象，其中，一个对象可以是所有可能的支票排版的目录，它可以被用来查询有关如何打印一张支票的信息；另一个对象(或对象集合)可以是一个通用的打印接口，它知道有关所有不同类型的打印机的信息(但是不包含任何有关簿记的内容，它更应该是一个需要购买而不是自己编写的对象) ；第三个对象通过调用另外两个对象的服务来完成打印任务。这样，每个对象都有一个它所能提供服务的内聚的集合。 </p><p>在良好的面向对象设计中，<strong>每个对象都可以很好地完成一项任务，但是它并不试图做更多的事。</strong>就像在这里看到的，不仅允许通过购买获得某些对象(打印机接口对象)，而且还可以创建能够在别处复用的新对象(支票排版目录对象)。</p><h2 id="1-4-被隐藏的具体实现"><a href="#1-4-被隐藏的具体实现" class="headerlink" title="1.4 被隐藏的具体实现"></a>1.4 被隐藏的具体实现</h2><p>将程序开发人员按照角色分为<code>类创建者</code>(那些创建新数据类型的程序员)和<code>客户端程序员</code>(那些在其应用中使用数据类型的类消费者)是大有裨益的。</p><p>客户端程序员的目标是收集各种用来实现快速应用开发的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，而隐藏其他部分。为什么要这样呢？因为如果加以隐藏，那么客户端程序员将不能够访问它，这意味着类创建者可以任意修改被隐藏的部分，而不用担心对其他任何人造成影响。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或不知内情的客户端程序员所毁坏，因此将实现隐藏起来可以减少程序bug。</p><p><strong>访问控制</strong>存在的原因：</p><ol><li>让客户端程序员无法触及他们不应该触及到的部分（客户端程序员能调用就行）</li><li>允许库的设计者可以改变类内部的工作方式而不用担心影响到客户端程序员（将3*3&#x3D;9的计算方式由3+3+3改变成3<code>*</code>3，但是对于客户端程序员来说，他们调用的乘法接口方式没变，结果没变）</li></ol><p>Java用三个关键字在类的内部设定边界:**<code> public</code>**、 **<code>private</code>**、 <strong><code>protected</code><strong>。 这些访问指定词(access specifier) 决定了紧跟其后被定义的东西可以被谁使用。<code>public</code>表示紧随其后的元素对任何人都是可用的，而<code>private</code>这个关键字表示除类型创建者和类型的内部方法之外的任何人都不能访问的元素。<code>private</code>就像你 与客户端程序员之间的一堵砖墙,如果有人试图访问<code>private</code>成员，就会在编译时得到错误信息。<code>protected</code>关键字与<code>private</code>作用相当，差别仅在于继承的类可以访问<code>protected</code>成员，但是不能访问<code>private</code>成员。稍后将会对继承进行介绍。<br>Java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。这种权限通常被称为</strong>包访问权限</strong>，因为在这种权限下，类可以访问在同一个包(库构件)中的其他类的成员，但是在包之外，这些成员如同指定了<code>private</code>一样。</p><h2 id="1-5-复用具体体现"><a href="#1-5-复用具体体现" class="headerlink" title="1.5 复用具体体现"></a>1.5 复用具体体现</h2><p>一旦类被创建并被测试完，那么它就应该(在理想情况下)代表一个有用的代码单元。</p><p>代码复用是面向对象程序设计语言所提供的最了不起的优点之一。</p><p>最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为<strong>创建一个成员对象</strong>。</p><p>新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。因为是在使用现有的类合成新的类，所以这种概念被称为组合composition), 如果组合是动态发生的，那么它通常被称为聚合(aggregation)。 组合经常被视为“has-a” (拥有)关系，就像我们常说的“汽车拥有引擎”一样。</p><p>组合带来了极大的灵活性。新类的成员对象通常都被声明为private,使得使用新类的客户端程序员不能访问它们。这也使得你可以在不干扰现有客户端代码的情况下，修改这些成员。也可以在运行时修改这些成员对象，以实现动态修改程序的行为。</p><h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6 继承"></a>1.6 继承</h2><p>对象这种观念，本身就是十分方便的工具，使得你可以通过概念将数据和功能封装到一起，因此可以对问题空间的观念给出恰当的表示，而不用受制于必须使用底层机器语言。这些概念用关键字class来表示，它们形成了编程语言中的基本单位。</p><p>有其他麻烦：在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。如果我们能够以现有的类为基础，复制它，然后通过添加和修改这个副本来创建新类那就要好多了。通过继承便可以达到这样的效果，不过也有例外，当源类(被称为基类、超类<code>super</code>或父类)发生变动时，被修改的“ 副本”(被称为导出类、继承类或子类)也会反映出这些变动。</p><p>类型不仅仅值是描述了作用于一个对象上的约束条件，同时还有与其他类型之间的关系。</p><p>两个类型可以有相同的特性和行为（属性和方法），但是一个比另一个含有更多的特性，可以处理更多的消息。</p><p>举例： </p><ol><li>垃圾回收机，它用来归类散落的垃圾。“垃圾”是基类型,每一件垃圾都有重量、价值等特性，可以被切碎、熔化或分解。在此基础上，可以通过添加额外的特性(例如瓶子有颜色)或行为(例如铝罐可以被压碎，铁罐可以被磁化)导出更具体的垃圾类型。此外，某些行为可能不同(例如纸的价值取决于其类型和状态)。可以通过使用继承来构建-一个类型层次结构，以此来表示待求解的某种类型的问题。</li><li>几何形。基类是几何形，每一个几何形都具有尺寸、颜色、位置等，同时每一个几何形都可以被绘制、擦除、移动和着色等。在此基础上，可以导出(继承出)具体的几何形状一圆形、 正方形、三角形等每一种都具有额外的特性和行为，例如某些形状可以被翻转。某些行为可能并不相同，例如计算几何形状的面积。类型层次结构同时体现了几何形状之间的相似性和差异性。</li></ol><img src="/2022/08/22/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_6_1几何形.png" alt="1_6_1几何形"><p>当继承现有类型时，也就创造了新的类型。这个新的类型不仅包括现有类型的所有成员(尽管private成员被隐藏了起来，并且不可访问)，而且更重要的是它复制了基类的接口。也就是说，<strong>所有可以发送给基类对象的消息同时也可以发送给导出类对象</strong>。由于通过发送给类的消息的类型可知类的类型，所以这也就意味着导出类与基类具有相同的类型。在前面的例子中，“一个圆形也就是一个几何形”。通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛。</p><p>子类和父类有相同的基础接口，伴随接口就会有具体实现的方法。当被调用时，必须有代码去执行。</p><p>如果只是继承了一个类而没有其他操作，那么子类会直接继承父类的方法。这样子类不仅与父类拥有相同的类型，还拥有相同的行为，这样没有特别的意义。</p><p>有两种方法可以使父类和子类产生差异：</p><ol><li><p>直接在子类中写新的方法，这些方法不是父类的。在使用这种方法时，应该考虑父类是否也需要这种方法。</p><img src="/2022/08/22/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_6_2新增.png" alt="1_6_2新增"></li><li><p>改变现有父类的方法（覆盖）。此时，虽然使用着相同的方法，但是做的事情不一样。</p><img src="/2022/08/22/hwca/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_6_3重写.png" alt="1_6_3重写"></li></ol><h3 id="1-6-1-“是一个”与“像是一个”关系"><a href="#1-6-1-“是一个”与“像是一个”关系" class="headerlink" title="1.6.1 “是一个”与“像是一个”关系"></a>1.6.1 “是一个”与“像是一个”关系</h3><ul><li><p><strong>是一个:</strong> 不新增方法 只在原有的方法上进行修改。父类和子类是相同的类型，具有相同的接口，可以用子类对象完全替代父类对象。这被视为<code>纯粹替代</code>，通常称之为<code>替代原则</code>，这是一种理想的继承方式，<code>is-a</code>（是一个）关系。例如“一个<code>圆形</code>是一个<code>几何形状</code>”。<strong>判断是否继承，就是确定是否可以用is-a来描述两个类之间的关系</strong></p></li><li><p><strong>像是一个：</strong>新增方法。有时必须在子类中新增方法扩展接口。这个新的子类仍然可以替代父类，但是这种替代并不完美，因为他有父类没有的新方法。父类也无法访问新添加的方法。这种情况可以描述成<code>is-like-a</code>（像是一个）关系。例如，家里的旧空调（父类）只有调节温度的功能，最近新买的物联网空调（子类）不仅有作为空调的基本的调节温度功能（继承父类的方法），还能接入物联网（新增的方法）。</p></li></ul><h2 id="1-7-伴随多态的可互换对象"><a href="#1-7-伴随多态的可互换对象" class="headerlink" title="1.7 伴随多态的可互换对象"></a>1.7 伴随多态的可互换对象</h2><p>在处理类型的层次结构是，经常把一个对象不当做他所属的特定类型来对待，而是将其作为父类的对象来对待。这样可以编写不依赖特定对象的代码。</p><p>在“几何图形”的例子里，方法操作都是泛化（generic）的形状，不用在意他是方形圆形还是三角形。所有的几何形状都可以执行父类（几何形）的方法，被绘制、擦除、移动。这些方法都是直接对几何形这个父类的，不用担心子类如何处理。</p><p>这样的代码不会受到新增的类型（子类）的影响。例如，新增几何形的子类星型，星型可以完全继承几何形的泛化方法，不用自己重写绘制、擦除、移动这些方法。这能极大地改善我们的设计，同时也能降低软件维护的代价。</p><p>试图将子类的对象当做父类的对象来看待时（把圆看成几何形），仍存在问题。让一个泛化的类执行方法时，比如让一个几何形绘制自己，编译器是不知道应该执行哪一段代码的。调用这种方法时，程序员并不想知道哪一段代码将被执行，他的子类，圆形、正方形、三角形，会根据自己的具体类型来执行恰当的代码。</p><p>编译器无法精确地了解哪一段代码将会被执行，那么改怎么办呢？这是面向程序设计的最重要的东西。</p><p>编译器不能在编译时产生传统意义上的函数调用，一个非面向对象的编译器产生的函数调用会引起所谓的<code>前期绑定</code>，这样编译器将产生对一个具体函数的调用，运行时这个调用会被解析到执行代码的绝对地址。</p><p>然而在OOP中，程序直到运行时才能够确定代码的地址，所以在调用泛化对象的方法时，必须使用其他的机制。</p><p>面向对象设计语言使用了<code>后期绑定</code>的概念。当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查(无法提供此类保证的语言被称为是弱类型的)，但是并不知道将被执行的确切代码。</p><p>为了执行后期绑定，Java使用了一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道对这条消息应该做些什么。</p><p>在某些语言中，必须明确地声明希望某个方法具备后期绑定属性所带来的灵活性。在这些语言中，方法在默认情况下不是动态绑定的。而在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。</p><p>还是用几何形举例。</p><p>父类几何形新增有参函数<code>doSomething</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几何形的子类使用这些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line"><span class="type">Triangle</span> <span class="variable">triangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>();</span><br><span class="line"><span class="type">Line</span> <span class="variable">line</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Line</span>();</span><br><span class="line">doSomething(circle);</span><br><span class="line">doSomething(triangle);</span><br><span class="line">doSomething(line);</span><br></pre></td></tr></table></figure><p>不管是Circle、Triangle还是Line，他们类型的参数都可以使用doSomething方法</p><p>Circle可以被doSomething()看做是Shape，也就是说，doSomething()可以发送给Shape的任何消息，Circle都可以接收。</p><p>把子类看成父类的过程成为<code>向上转型</code>（upcasting）。</p><p>一个面向对象程序肯定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放出来的关键。让我们再看看doSomething()中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shape.erase();</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure><p>注意这些代码并不是说“ 如果是Circle,请这样做;如果是Square,请那样做…“如果编写了那种检查Shape所有实际可能类型的代码，那么这段代码肯定是杂乱不堪的，而且在每次添加了Shape的新类型之后都要去修改这段代码。这里所要表达的意思仅仅是“你是一个Shape,我知道你可以erase()和draw()你自己，那么去做吧，但是要注意细节的正确性。”<br>doSomething()的代码给人印象深刻之处在于，不知何故，它总是做了该做的。调用Circle的draw()方法所执行的代码与调用Square或Line的draw()方法所执行的代码是不同的，而且当draw(消息被发送给-一个 匿名的Shape时，也会基于该Shape的实际类型产生正确的行为。这相当神奇，因为就像在前面提到的，当Java编译 器在编译doSomething()的代码时，并不能确切知道doSomething()要处理的确切类型。所以通常会期望它的编译结果是调用基类Shape的erase()和draw()版本，而不是具体的Circle、Square或Line的相应版本。正是因为多态才使得事情总是能够被正确处理。编译器和运行系统会处理相关的细节，你需要马上知道的只是事情会发生，更重要的是怎样通过它来设计。当向一个对象发送消息时，即使涉及向上转型，该对象也知道要执行什么样的正确行为。</p><h2 id="1-8-单根继承结构"><a href="#1-8-单根继承结构" class="headerlink" title="1.8 单根继承结构"></a>1.8 单根继承结构</h2><p>在面向对象编程中，自C++面世以来就有一个瞩目的问题，是否所有的类最终都继承自单一的父类。</p><p>在Java中(事实上还包括除C++以外的所有OOP语言)是的，这个终极父类的名字就是<code>Object</code>。事实证明，单根继承结构带来了很多好处。</p><p>在单根继承结构中的所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。另一种(C++所提供的)结构是无法确保所有对象都属于同一个基本类型。从向后兼容的角度看，这么做能够更好地适应C模型，而且受限较少，但是当要进行完全的面向对象程序设计时，则必须构建自己的继承体系，使得它可以提供其他OOP语言内置的便利。并且在所获得的任何新类库中，总会用到一些不兼容的接口，需要花力气(有可能要通过多重继承)来使新接口融入你的设计之中。这么做来换取C++额外的灵活性是否值得呢?如果需要的话一-如果在C上面投资巨大，这么做就很有价值。如果是刚刚从头开始，那么像Java这样的选择通常会有更高的生产率。</p><p>单根继承结构保证所有对象都具备某些功能。因此你知道，在你的系统中你<strong>可以在每个对象上执行某些基本操作</strong>。所有对象都可以很容易地在堆上创建，而参数传递也得到了极大的简化。</p><p>单根继承结构使垃圾回收器的实现变得容易得多，而垃圾回收器正是Java相对C++的重要改进之一。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。</p><p>这对于系统级操作(如异常处理)显得尤其重要，并且给编程带来了更大的灵活性。</p><h2 id="1-9-容器"><a href="#1-9-容器" class="headerlink" title="1.9 容器"></a>1.9 容器</h2><p>如果不知道在解决某个特定问题时需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。如何才能知道需要多少空间来创建这些对象呢?</p><p>答案是不可能知道，因为这类信息只有在运行时才能获得。</p><p>解决方法是：<strong>创建另一种对象类型。</strong></p><p>这种新的对象类型持有对其他对象的引用。当然，你可以用在大多数语言中都有的数组类型来实现相同的功能。但是这个通常被称为容器(也称为集合)的新对象，在任何需要时都可扩充自己以容纳你置于其中的所有东西。因此不需要知道将来会把多少个对象置于容器中，只需要创建一个容器对象，然后让它处理所有细节。</p><h3 id="1-9-1-参数化类型"><a href="#1-9-1-参数化类型" class="headerlink" title="1.9.1 参数化类型"></a>1.9.1 参数化类型</h3><p>在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型: Object。 单根继承结构意味着所有东西都是Object类型，所以可以存储Object的容器可以存储任何东西。这使得容器很容易被复用。</p><p>要使用这样的容器，只需在其中置入对象引用，稍后还可以将它们取回。但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，因此它会丢失其身份。当把它取回时，就获取了一个对Object对象的引用，而不是对置入时的那个类型的对象的引用。</p><p>所以，怎样才能将它变回先前置人容器中时的具有实用接口的对象呢?</p><p>这里再度用到了转型，但这一次不是向继承结构的上层转型为一个更泛化的类型，而是向下转型为更具体的类型。这种转型的方式称为<code>向下转型</code>。我们知道，向上转型是安全的，例如Circle是一种Shape类型；但是不知道某个Object是Circle还是Shape,所以<strong>除非确切知道所要处理的对象的类型，否则向下转型几乎是不安全的。</strong></p><p>向下转型和运行时的检查需要额外的程序运行时间，也需要程序员付出更多的心血。如果有这样一种容器，它<strong>知道自己所保存的对象的类型，从而不需要向下转型</strong>以及消除犯错误的可能，这样不是更有意义吗？</p><p>这种解决方案被称为参数化类型机制。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。例如，通过使用参数化类型，编译器可以定制一个只接纳和取出Shape对象的容器。</p><p>Java SE5的重大变化之一就是增加了<code>参数化类型</code>，在Java中它称为范型。一对尖括号,中间包含类型信息，通过这些特征就可以识别对范型的使用。例如，可以用下面这样的语句来创建一个存储Shape的ArrayList:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Shape&gt;();</span><br></pre></td></tr></table></figure><h2 id="1-10-对象的创建和生命期"><a href="#1-10-对象的创建和生命期" class="headerlink" title="1.10 对象的创建和生命期"></a>1.10 对象的创建和生命期</h2><p>在使用对象时，最关键的问题之一便是它们的生成和销毁方式。</p><p>每个对象为了生存都需要资源，尤其是内存。当我们不再需要一个对象时，它必须被清理掉，使其占有的资源可以被释放和重用。简单的程序中这不是问题，但是不是所有的程序都那么简单。</p><p>例如，一个机场空中交通管理系统。</p><ul><li><strong>简单版：</strong>创建一个容器，保存所有飞机。<ul><li>新增：为每一架进入空中控制区域的飞机新建一个飞机对象，将其至于容器内</li><li>清理： 在飞机离开控制区域时删除相关的飞机对象。</li></ul></li><li><strong>困难版：</strong>小型飞机的飞行计划<ul><li>新增：无论何时，只要有小型飞机对象创建，就要有第二个容器来存放对应的飞行计划</li><li>销毁：何时销毁？？？</li></ul></li></ul><ol><li>C++认为效率控制是最重要的议题，所以给程序员提供了选择的权力。为了追求最大的执行速度，对象的存储空间和生命周期可以在编写程序时确定。这种方式将存储空间分配和释放置于优先考虑的位置，某些情况下这样控制非常有价值。但是，也牺牲了灵活性，因为必须在编写程序时知道对象确切的数量、生命周期和类型。如果试图解决更一般化的问题，例如计算机辅助设计、仓库管理或者空中交通控制，这种方式就显得过于受限了。</li><li>第二种方式是在被称为堆(heap) 的内存池中动态地创建对象。在这种方式中，直到运行时才知道需要多少对象，它们的生命周期如何，以及它们的具体类型是什么。这些问题的答案只能在程序运行时相关代码被执行到的那一刻才能确定。如果需要一个新对象，可以在需要的时刻直接在堆中创建。因为存储空间是在运行时被动态管理的，所以需要大量的时间在堆中分配存储空间，这可能要远远大于在堆栈中创建存储空间的时间。在堆栈中创建存储空间和释放存储空间通常各需要一条汇编指令即可，分别对应将栈顶指针向下移动和将栈顶指针向上移动。创建堆存储空间的时间依赖于存储机制的设计。</li></ol><p>动态方式有这样一个一般性的逻辑假设:对象趋向于变得复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大冲击。</p><p>动态方式所带来的更大的灵活性正是解决一般化编程问题的要点所在。</p><p><strong>Java完全采用了动态内存分配方式。</strong>每当想要创建新对象是，就要使用new关键字来构建此对象的动态实例。</p><p>还有一个问题，就是生命周期。</p><p>对于允许在堆栈上创建对象的语言，编译器可以确定对象存活的时间，并可以自动销毁。</p><p>可是，在堆上创建对象，编译器就会对它的生命周期一无所知。在C++上，必须通过编程方式类确定何时销毁对象，这可能会因为处理不正确导致内存泄露。</p><p>Java中提供了内存回收机制，能自动发现对象何时不再被使用，并继而销毁它。回收机制被设计用来处理内存释放问题，它”知道“对象何时不再被使用，并且自动释放对象占用的内存。</p><p>这是因为所有的对象都继承自单根基类Object以及只能用一种方式创建对象（在堆上创建）这两个特性。</p><h2 id="1-11-异常处理：处理错误"><a href="#1-11-异常处理：处理错误" class="headerlink" title="1.11 异常处理：处理错误"></a>1.11 异常处理：处理错误</h2><p>错误处理始终是最困难的问题之一。</p><p>异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。</p><p>异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。 因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。因为不需要被迫定期检查错误，这往往使得代码编写变得简单。</p><p>此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。</p><p><strong>异常不能被忽略</strong>，所以它保证一定会在某处得到处理。</p><p>Java的异常处理在众多的编程语言中格外引人注目，因为Java一开始就内置了异常处理，而且强制你必须使用它。它是唯一可接受的错误报告方式。如果没有编写正确的处理异常的代码，那么就会得到一条编译时的出错消息。这种有保障的一致性有时会使得错误处理非常容易。</p><h2 id="1-12-并发编程"><a href="#1-12-并发编程" class="headerlink" title="1.12 并发编程"></a>1.12 并发编程</h2><p>在计算机编程中有一个基本概念，就是在同一时刻处理多个任务的思想。</p><p>许多程序设计问题都要求，程序能够停下正在做的工作，转而处理某个其他问题，然后再返回主进程。有许多<br>方法可以实现这个目的。最初，程序员们用所掌握的有关机器底层的知识来编写中断服务程序，主进程的挂起是通过硬件中断来触发的。尽管这么做可以解决问题，但是其难度太大，而且不能移植，所以使得将程序移植到新型号的机器上时，既费时又费力。</p><p>有时中断对于处理时间性强的任务是必需的，但是对于大量的其他问题，我们只是想把问题切分成多个可独立运行的部分(任务)，从而提高程序的响应能力。</p><p>在程序中，这些彼此独立运行的部分称之为线程，上述概念被称为 “并发”。并发最常见的例子就是用户界面。通过使用任务，<strong>用户可以在揿下按钮后快速得到一个响应，而不用被迫等待到程序完成当前任务为止。</strong></p><p>通常，线程只是一种为单一处理器分配执行时间的手段。但是如果操作系统支持多处理器，那么每个任务都可以被指派给不同的处理器，并且它们是在真正地并行执行。在语言级别上，多线程所带来的便利之一便是程序员不用再操心机器上是有多个处理器还是只有一个处理器。</p><p>由于程序在逻辑上被分为线程，所以如果机器拥有多个处理器，那么程序不需要特殊调整也能执行得更快。</p><p>所有这些都使得并发看起来相当简单，但是<strong>有一个隐患：共享资源</strong>。如果有多个并行任务都要访问同一项资源，那么就会出问题。</p><p>例如，两个进程不能同时向一台打印机发送信息。为了解决这个问题，可以共享的资源，例如打印机，必须在使用期间被锁定。因此，整个过程是：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。<br><strong>Java的并发是内置于语言中的</strong>，JavaSE5已经增添了大量额外的库支持。</p><h2 id="1-13-Java与Internet"><a href="#1-13-Java与Internet" class="headerlink" title="1.13 Java与Internet"></a>1.13 Java与Internet</h2><p>为什么Java如此重要？</p><h3 id="1-13-1-Web是什么"><a href="#1-13-1-Web是什么" class="headerlink" title="1.13.1 Web是什么"></a>1.13.1 Web是什么</h3><h4 id="1-客户-x2F-服务器计算技术"><a href="#1-客户-x2F-服务器计算技术" class="headerlink" title="1. 客户&#x2F;服务器计算技术"></a>1. 客户&#x2F;服务器计算技术</h4><p>系统具有一个中央信息存储池(central repository of information)，用来存储某种数据，它通常存在于数据库中，你可以根据需要将它分发给某些人员或机器集群。</p><p>客户&#x2F;服务器概念的关键在于信息存储池的位置集中于中央，这使得它可以被修改，并且这些修改将被传播给信息消费者。总之，信息存储池、用于分发信息的软件以及信息与软件所驻留的机器或机群被总称为服务器。驻留在用户机器上的软件与服务器进行通信，以获取信息、处理信息，然后将它们显示在被称为客户机的用户机器上。</p><p>客户&#x2F;服务器计算技术的基本概念并不复杂。问题在于<strong>你只有单一的服务器，却要同时为多个客户服务。</strong>通常，这会涉及数据库管理系统，因此设计者把数据“均衡”分布于数据表中,以取得最优的使用效果。此外，系统通常允许客户在服务器中插入新的信息。这意味着必须<strong>保证一个客户插入的新数据不会覆盖另一个客户插入的新数据，也不会在将其添加到数据库的过程中丢失(这被称为事务处理)。</strong>如果客户端软件发生变化，那么它必须被重新编译、调试并安装到客户端机器上，事实证明这比想像的要更加复杂与费力。如果想支持多种不同类型的计算机和操作系统，问题将更麻烦。最后还有一个最重要的性能问题:可能在任意时刻都有成百上千的客户向服务器发出请求，所以任何小的延迟都会产生重大影响。为了将延迟最小化，程序员努力减轻处理任务的负载，通常是分散给客户端机器处理，但有时也会使用所谓的中间件将负载分散给在服务器端的其他机器。(中间件也被用来提高可维护性。)</p><h4 id="2-Web就是一台巨型服务器"><a href="#2-Web就是一台巨型服务器" class="headerlink" title="2. Web就是一台巨型服务器"></a>2. Web就是一台巨型服务器</h4><p>在某一时刻怎么连接到一个服务器上与之交互。</p><p>对服务器产生请求，服务器返回文件，本地解读。</p><p>人们希望能直接操作服务器的数据库。</p><p>Web浏览器出现了，一些信息不需要任何修改就可以在任意型号的计算机上显示。但是当时的浏览器不具备显著的交互性，需要编程来实现的任务还需要把信息发到服务器去处理，这样对于程序的排错比较困难。但是因为他只能观察，不能执行任何程序，所以有很高的安全性。</p><p>为了解决这个问题，人们采用了不同的方法。为了解决这个问题，人们采用了各种不同的方法。首先，图形标准得到了增强，使得在浏览器中可以播放质量更好的动画和视频。剩下的问题通过引人在客户端浏览器中运行程序的能<br>力就可以解决。这被称为“客户端编程”。</p><h3 id="1-13-2-客户端编程"><a href="#1-13-2-客户端编程" class="headerlink" title="1.13.2 客户端编程"></a>1.13.2 客户端编程</h3><p>Web最初的“服务器-浏览器”设计是为了提供交互性的内容，但是交互性由服务器提供。</p><p>服务器产生静态界面(HyperText Markup Language，超文本标记语言)，提供给只能解释并显示的客户端浏览器。</p><p>提交动作通过所有的Web服务器都提供的通用网关接口(common gateway interface, CGI) 传递。</p><p>提交内容会告诉CGI应该如何处理它。最常见的动作就是运行一个在服务器中常被命名为“cgi-bin”的目录下的一个程序。(如果网页地址有<code>cgi-bin</code>)几乎所有的语言都可以用来编写这些程序，PerI已经成为最常见的选择，因为它被设计用来处理文本，并且是解释型语言，因此无论服务器的处理器和操作系统如何，它都适于安装。<br>当今许多有影响力的网站完全构建于CGI之上的，实际上你几乎可以通过CGI做任何事。然而，构建于CGI程序之上的网站可能会迅速变得过于复杂而难以维护，并同时产生响应时间过长的问题。CGI程序的响应时间依赖于所必须发送的数据量的大小，以及服务器和Internet的负载。(此外，启动CGI程序也相当慢。) </p><p>你肯定经历过对Web输入表单进行数据验证的过程:你按下网页上的提交按钮，数据被发送回服务器;服务器启动一个CGI程序来检查、发现错误，并将错误组装为一个HTML页面，然后将这个页面发回给你；之后你必须回退一个页面，然后重新再试。这个过程不仅很慢，而且不太优雅。（注册界面有很多项目需要填写，你好不容易全填写晚了，但是最后的验证码过期了导致你注册失败，上面的这些东西你又要全部重新填写）</p><p>解决方法是客户端编程。大多数运行Web浏览器的机器都是能够执行大型任务的强有力的引擎。在使用原始的静态HTML方式的情况下，它们只是闲在那里，等着服务器送来下一个页面。客户端编程意味着Web浏览器能用来执行任何它可以完成的工作，使得返回给用户的结果更加迅捷，而且使得你的网站更加具有交互性。</p><p>客户端编程的问题是：它与通常意义上的编程十分不同，参数几乎相同，而平台却不同。Web浏览器就像一个功能受限的操作系统。 </p><p>最终，你仍然必须编写程序，而且还得处理那些令人头晕眼花的成堆的问题，并以客户端编程的方式来产生解决方案。</p><h4 id="1-插件"><a href="#1-插件" class="headerlink" title="1. 插件"></a>1. 插件</h4><p>客户端编程所迈出的最重要的一步就是插件(plug-in) 的开发。通过这种方式，程序员可以下载一段代码，并将其插入到浏览器中适当的位置，以此来为浏览器舔加新功能。它告诉浏览器：从现在开始，你可以采取这个新行动了**(只需要下载一次插件即可)**。</p><p>某些更快更强大的行为都是通过插件添加到服务器中的。但是编写插件并不是件轻松的事，也不是构建某特定网<br>站的过程中所要做的事情。插件对于客户端编程的价值在于：它允许专家级的程序员不需经过浏览器生产厂商的许可，就可以开发某种语言扩展，并将它们添加到服务器中。因此，插件提供了一个“后门”，使得可以创建新的客户端编程语言(但是并不是所有的客户端编程语言都是以插件的形式实现的)。</p><h4 id="2-脚本语言"><a href="#2-脚本语言" class="headerlink" title="2.脚本语言"></a>2.脚本语言</h4><p>插件引发了浏览器脚本语言(scripting language) 的开发。通过使用某种脚本语言，你可以将客户端程序的源代码直接嵌人到HTML页面中，解释这种语言的插件在HTML页面被显示时自动激活。脚本语言先天就相当易于理解，<strong>因为它们只是作为HTML页面一部分的简单文本，当服务器收到要获取该页面的请求时，它们可以被快速加载。</strong>此方法的缺点是代码会暴露给任何人去浏览(或窃取)。但是，通常不会使用脚本语言去做相当复杂的事情，所以这个缺点并不太严重。</p><p>如果你期望有一种脚本语言在Web浏览器不需要任何插件的情况下就可以得到支持，那它非JavaScript莫属。</p><p>在Web浏览器内部使用的脚本语言实际上总是被用来解决特定类型的问题，主要是用来创建更丰富、更具有交互性的图形化用户界面(graphic user interface, GUI)。但是，脚本语言可以解决客户端编程中所遇到的百分之八十的问题。</p><p>你的问题可能正好落在这百分之八十的范围之内，由于脚本语言提供了更容易、更快捷的开发方式，因此你应该在考虑诸如Java这样的更复杂的解决方案之前，先考虑脚本语言。</p><h4 id="3-Java"><a href="#3-Java" class="headerlink" title="3. Java"></a>3. Java</h4><p>如果脚本语言可以解决客户端编程百分之八十的问题，剩下那百分之二十Java是处理它们最流行的解决方案。</p><p>Java不仅是一种功能强大的、安全的、跨平台的、国际化的编程语言，而且它还在不断地被扩展，以提供更多的语言功能和类库，能够优雅地处理在传统编程语言中很难解决的问题，例如并发、数据库访问、网络编程和分布式计算。Java是通过applet以及使用Java Web Start来进行客户端编程的。</p><p>applet是只在Web浏览器中运行的小程序，它是作为网页的一部分而自动下载的(就像网页中的图片被自动下载一样)。 当applet被激活时，它便开始执行一个程序。</p><p>它提供一种分发软件的方法，一旦用户需要客户端软件时，就自动从服务器把客户端软件分发给用户。用户获取最新版本的客户端软件时不会产生错误，而且也不需要很麻烦的重新安装过程。Java的这种设计方式，使得程序员只需创建单一的程序，而只要一台计算机有浏览器，且浏览器具有内置的Java解释器(大多数的机器都如此),那么这个程序就可以自动在这台计算机上运行。由于Java是一种成熟的编程语言，所以在提出对服务器的请求之前和之后，可以在客户端尽可能多地做些事情。例如，不必跨网络地发送一张请求表单来检查自己是否填写了错误的日期或其他参数，客户端计算机就可以快速地标出错误数据，而不用等待服务器作出标记并给你传回图片。这不仅立即就获得了高速度和快速的响应能力，而且也降低了网络流量和服务器负载，从而不会使整个Internet的速度都慢了下来。</p><h4 id="4-备选方案"><a href="#4-备选方案" class="headerlink" title="4. 备选方案"></a>4. 备选方案</h4><p>好久远的例子</p><h4 id="5-NET和C"><a href="#5-NET和C" class="headerlink" title="5. .NET和C#"></a>5. .NET和C#</h4><p>.net平台大致相当于java虚拟机（JVM）和java类库</p><h4 id="6-Internet与Intranet（企业内部网）"><a href="#6-Internet与Intranet（企业内部网）" class="headerlink" title="6. Internet与Intranet（企业内部网）"></a>6. Internet与Intranet（企业内部网）</h4><p>在公网上需要注意平台兼容性与安全性 在Intranet需要注意代码质量，并且在发现bug后进行修复（？？？）</p><h3 id="1-13-3-服务器端编程"><a href="#1-13-3-服务器端编程" class="headerlink" title="1.13.3 服务器端编程"></a>1.13.3 服务器端编程</h3><p>Java成功的因素之一。</p><p>对服务器提出请求后，一般发送文件之类的浏览器会进行解释。但是更复杂的对于数据库操作的请求会执行一些程序之后返回一个HTML界面给客户端。</p><h2 id="1-14-总结"><a href="#1-14-总结" class="headerlink" title="1.14 总结"></a>1.14 总结</h2><ul><li>要知道过程型语言看起来像什么样子：数据定义和函数调用。</li><li>要通读函数调用和低层概念，以在脑海里建立一个模型。</li></ul><p>这正是我们过程式程序，需要中间表示形式的原因。<br>因为OOP在你能够在过程型语言中找到的概念的基础上，又添加了许多新概念<br>编写良好的Java程序通常比过程型程序要简单得多，而且也易于理解得多。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-对象导论&quot;&gt;&lt;a href=&quot;#1-对象导论&quot; class=&quot;headerlink&quot; title=&quot;1. 对象导论&quot;&gt;&lt;/a&gt;1. 对象导论&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来…除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。&lt;/p&gt;
&lt;p&gt;——Benjamin Lee Whorf (1897 ~ 1941)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​        计算机有更多的用途，越来越不像机器，有多种表达方式。&lt;strong&gt;面向对象程序设计(Object-oriented Programming, OOP)便是这种以计算机作为表&lt;br&gt;达媒体的大趋势中的组成部分。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="hwca" scheme="https://www.szjm.online/categories/hwca/"/>
    
    <category term="java" scheme="https://www.szjm.online/categories/hwca/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/categories/hwca/java/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/categories/hwca/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="hwca" scheme="https://www.szjm.online/tags/hwca/"/>
    
    <category term="java" scheme="https://www.szjm.online/tags/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>instanceof和类型转换</title>
    <link href="https://www.szjm.online/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.szjm.online/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-08-20T15:08:47.000Z</published>
    <updated>2022-08-21T10:39:30.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="instanceof和类型转换"><a href="#instanceof和类型转换" class="headerlink" title="instanceof和类型转换"></a>instanceof和类型转换</h3><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p><code>instanceof</code> 可以判断两个类之间是否存在父子关系<span id="more"></span></p><p>新增Teacher类继承与Person</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类新增指向Student的Object 测试继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Person;</span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Student;</span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/指向Student的Object继承关系.png" alt="指向Student的Object继承关系"><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/此时的继承树.png" alt="此时的继承树"><p>测试指向student的Person和Student</p><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/编译不通过直接爆红.png" alt="编译不通过直接爆红"><p>将这几行注释掉继续运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Person;</span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Student;</span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Student);</span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Person);</span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Teacher);</span><br><span class="line"><span class="comment">//        System.out.println(person instanceof String);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(student <span class="keyword">instanceof</span> Student);</span><br><span class="line">        System.out.println(student <span class="keyword">instanceof</span> Person);</span><br><span class="line">        System.out.println(student <span class="keyword">instanceof</span> Object);</span><br><span class="line"><span class="comment">//        System.out.println(student instanceof Teacher);</span></span><br><span class="line"><span class="comment">//        System.out.println(student instanceof String);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/teacher和student的运行结果.png" alt="teacher和student的运行结果"><ol><li>比如Person X &#x3D; new Student()，我们知道左边Person是引用类型，右边Student是实际类型</li><li>X instanceof Y，然后看X的类型（就是引用类型Person）和Y有没有继承关系，没有就直接报错，有就下一步</li><li>然后判断X的实际类型（就是右边的Student），是不是Y本身或者他的子类，是就true，不是就false</li><li>注意的是实际类型不能是Y的父类，不然就会false</li></ol><p><strong>编译看左边 运行看右边</strong></p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;instanceof和类型转换&quot;&gt;&lt;a href=&quot;#instanceof和类型转换&quot; class=&quot;headerlink&quot; title=&quot;instanceof和类型转换&quot;&gt;&lt;/a&gt;instanceof和类型转换&lt;/h3&gt;&lt;h4 id=&quot;instanceof&quot;&gt;&lt;a href=&quot;#instanceof&quot; class=&quot;headerlink&quot; title=&quot;instanceof&quot;&gt;&lt;/a&gt;instanceof&lt;/h4&gt;&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 可以判断两个类之间是否存在父子关系&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>什么是多态</title>
    <link href="https://www.szjm.online/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112_%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81/"/>
    <id>https://www.szjm.online/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112_%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81/</id>
    <published>2022-08-20T15:01:59.000Z</published>
    <updated>2022-08-20T15:07:39.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><ul><li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li><li>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多<span id="more"></span></li><li>多态存在的条件<ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象</li></ul></li><li>注意:多态是方法的多态，属性没有多态性</li><li>instanceof 类型转换（引用类型的转换）</li></ul><h4 id="一个对象的实际类型是确定的"><a href="#一个对象的实际类型是确定的" class="headerlink" title="一个对象的实际类型是确定的"></a>一个对象的实际类型是确定的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><h4 id="可以指向的引用类型就不确定了-父类的引用指向子类"><a href="#可以指向的引用类型就不确定了-父类的引用指向子类" class="headerlink" title="可以指向的引用类型就不确定了 父类的引用指向子类"></a>可以指向的引用类型就不确定了 父类的引用指向子类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><h4 id="当父类有方法时，子类s1和父类s2都可以调用方法"><a href="#当父类有方法时，子类s1和父类s2都可以调用方法" class="headerlink" title="当父类有方法时，子类s1和父类s2都可以调用方法"></a>当父类有方法时，子类s1和父类s2都可以调用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">s2.run();</span><br><span class="line">s1.run();</span><br></pre></td></tr></table></figure><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112_%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81/子类父类调用父类方法.png" alt="子类父类调用父类方法"><h4 id="当子类重写了方法时，子类父类都可以调用这个都有的方法，但是显示的是子类的结果"><a href="#当子类重写了方法时，子类父类都可以调用这个都有的方法，但是显示的是子类的结果" class="headerlink" title="当子类重写了方法时，子类父类都可以调用这个都有的方法，但是显示的是子类的结果"></a>当子类重写了方法时，子类父类都可以调用这个都有的方法，但是显示的是子类的结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112_%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81/子类父类调用子类重写方法.png" alt="子类父类调用子类重写方法"><h4 id="如果这个方法只有子类有-父类无法常规调用"><a href="#如果这个方法只有子类有-父类无法常规调用" class="headerlink" title="如果这个方法只有子类有 父类无法常规调用"></a>如果这个方法只有子类有 父类无法常规调用</h4><ul><li>对象能执行哪些方法，主要看&#x3D;左边是什么类型，和右边关系不大</li><li>子类能调用自己的或者继承父类的方法</li><li>父类可以指向子类，但是不能调用子类独有的方法</li></ul><h4 id="多态注意事项："><a href="#多态注意事项：" class="headerlink" title="多态注意事项："></a>多态注意事项：</h4><ol><li><p>多态是方法的多态，属性没有多态</p></li><li><p>父类和子类需要有联系 不能强转 （类型转换异常 <code>ClassCastException</code>!）</p></li><li><p>多态存在条件：①要有继承关系 ②方法要重写 ③父类引用指向子类对象 <code>Father f1 = new Son();</code></p></li></ol><h4 id="哪些方法不能被重写"><a href="#哪些方法不能被重写" class="headerlink" title="哪些方法不能被重写"></a>哪些方法不能被重写</h4><ol><li><code>static</code> 静态方法 属于类，不属于实例</li><li><code>final</code> 常量</li><li><code>private</code> 私有的 不能重写</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是多态&quot;&gt;&lt;a href=&quot;#什么是多态&quot; class=&quot;headerlink&quot; title=&quot;什么是多态&quot;&gt;&lt;/a&gt;什么是多态&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;即同一方法可以根据发送对象的不同而采用多种不同的行为方式。&lt;/li&gt;
&lt;li&gt;一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>方法重写</title>
    <link href="https://www.szjm.online/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/"/>
    <id>https://www.szjm.online/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/</id>
    <published>2022-08-17T13:52:45.000Z</published>
    <updated>2022-08-17T13:52:47.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>新增A、B两个类，A类继承B类，两类各新增输出不同的test方法<span id="more"></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写都是方法的重写 与属性无关</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.A;</span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.B;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.test();</span><br><span class="line"></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        b.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然都是new的A类 但是两次输出结果不同</p><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/两次输出结果不同.png" alt="两次输出结果不同"><p>父类的引用指向了子类</p><p>用B类新建了A类的对象，把A赋值给了B，这时候B是A，A又继承了B类，向上转型。所以调用B类方法的时候，也就是B&#x3D;&gt;test</p><p>解释一下什么是多态？答：父类的引用可以指向子类的实现</p><p>方法的调用只和左边，定义的数据类型有关</p><h4 id="无static"><a href="#无static" class="headerlink" title="无static"></a>无static</h4><p>A、B两类不使用static</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写都是方法的重写 与属性无关</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="comment">//    public static void test()&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="comment">//    public static void test()&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时两次的输出结果都是a的</p><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/此时两次的输出结果都是a的.png" alt="此时两次的输出结果都是a的"><p>行数栏上有o标识 表示重写</p><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/重写标识.png" alt="重写标识"><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/快捷重写.png" alt="快捷重写"><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/快捷重写2.png" alt="快捷重写2"><p>即b是A new出来的对象，因此调用了A的方法</p><p>因为静态方法是类的方法，而非静态是对象的方法</p><p>有static时，b调用了B类的方法，因为b是用b类定义的</p><p>没有static时，b调用的是对象的方法，而b是用A类new的</p><p>子类重写了父类的方法</p><p><strong>静态方法只能被继承，不能被重写</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>重写：需要有继承关系 子类重写父类的方法</p><p>​           子类和父类的方法必须一致 方法体不同 </p><ol><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符：范围可以扩大不能缩小  public&gt;protected&gt;default&gt;private</li><li>抛出异常： 范围可以被缩小不能扩大</li></ol><p>为什么需要重写？？？</p><ol><li>父类的功能子类不一定需要或者不一定满足</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;方法重写&quot;&gt;&lt;a href=&quot;#方法重写&quot; class=&quot;headerlink&quot; title=&quot;方法重写&quot;&gt;&lt;/a&gt;方法重写&lt;/h3&gt;&lt;h4 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h4&gt;&lt;p&gt;新增A、B两个类，A类继承B类，两类各新增输出不同的test方法&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Super详解</title>
    <link href="https://www.szjm.online/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.szjm.online/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-08-16T14:29:12.000Z</published>
    <updated>2022-08-16T14:30:04.184Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Super详解"><a href="#Super详解" class="headerlink" title="Super详解"></a>Super详解</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>在父类person中新建一个受保护的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;szjm&quot;</span>;</span><br></pre></td></tr></table></figure><p>在子类Student中新建一个私有类和一个公有方法 输出<code>name</code>、<code>this.name</code>和<code>super.name</code> <span id="more"></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hxd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">    System.out.println(<span class="built_in">super</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类调用<code>student.test</code>查看输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.test(<span class="string">&quot;szjm&quot;</span>);</span><br></pre></td></tr></table></figure><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/三种name输出.png" alt="三种name输出"><ul><li>第一个name是<code>传递的值</code></li><li>第二个name是<code>当前类的值</code></li><li>第三个name是<code>父类的值</code></li></ul><h4 id="公有方法"><a href="#公有方法" class="headerlink" title="公有方法"></a>公有方法</h4><p>在父类person中新建一个公有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类student中新建公有方法和公有test2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    print();</span><br><span class="line">    <span class="built_in">this</span>.print();</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类查看输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.test2();</span><br></pre></td></tr></table></figure><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/三种公有方法输出.png" alt="三种公有方法输出"><ul><li><p>print方法中定义了输出的值 所以不需要传递的值</p></li><li><p>第一个方法是<code>当前类</code></p></li><li><p>第二个方法是<code>当前类</code></p></li><li><p>第三个方法是<code>父类</code></p></li></ul><h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>私有方法无法被继承（其实可以继承 只是无法访问）</p><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><p>在父类新增无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person无参执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类新增无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Student无参执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类构造student</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p>执行发现父类的无参构造被执行了</p><p>也就是说在调用子类的时候会执行父类的无参构造</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/调用子类时执行了父类的无参构造.png" alt="调用子类时执行了父类的无参构造"><p>如果子类没有无参构造 也会执行父类的无参构造</p><h4 id="隐藏代码"><a href="#隐藏代码" class="headerlink" title="隐藏代码"></a>隐藏代码</h4><p>其实是在无参构造的时候执行了一句隐藏代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>();</span><br></pre></td></tr></table></figure><p>而且这行代码必须在子类无参构造的第一句</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/必须是构造函数主体的第一条语句.png" alt="必须是构造函数主体的第一条语句"><p>this();也必须是在子类无参构造的第一句，所以父类和子类只能选一个</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/this也必须是在子类无参构造的第一句.png" alt="this也必须是在子类无参构造的第一句"><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><p>如果父类使用有参构造，就不能使用无参构造，子类也不能使用无参构造</p><p>父类使用有参构造 子类也能使用有参构造 同时可以调用父类的有参构造</p><p>如果父类使用了有参构造 子类必须有对应的可用的构造函数</p><h4 id="Super注意点："><a href="#Super注意点：" class="headerlink" title="Super注意点："></a>Super注意点：</h4><ol><li>super调用父类的构造方法，必须在构造方法的第一个</li><li>super必须只能出现在子类的方法或者构造方法中！</li><li>super和this 不能同时调用构造方法!</li></ol><h4 id="Super与this对比："><a href="#Super与this对比：" class="headerlink" title="Super与this对比："></a>Super与this对比：</h4><ul><li>代表的对象不同：<ul><li>this：本身调用者这个对象</li><li>super：代表父类对象的应用</li></ul></li><li>前提<ul><li>this：没哟继承也可以使用</li><li>super：只能在继承条件才可以使用</li></ul></li><li>构造方法<ul><li>this()：本类的构造</li><li>super()：父类的构造</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Super详解&quot;&gt;&lt;a href=&quot;#Super详解&quot; class=&quot;headerlink&quot; title=&quot;Super详解&quot;&gt;&lt;/a&gt;Super详解&lt;/h3&gt;&lt;h4 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h4&gt;&lt;p&gt;在父类person中新建一个受保护的类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;szjm&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在子类Student中新建一个私有类和一个公有方法 输出&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;this.name&lt;/code&gt;和&lt;code&gt;super.name&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>什么是继承</title>
    <link href="https://www.szjm.online/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.szjm.online/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/</id>
    <published>2022-08-16T08:14:16.000Z</published>
    <updated>2022-08-16T08:14:27.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><ul><li>继承的本质是对某-批类的抽象，从而实现对现实世界更好的建模。</li><li><strong>extends</strong>的意思是“扩展”。子类是父类的扩展。</li><li><strong>JAVA中类只有单继承，没有多继承！</strong></li><li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li><li>继承关系的俩个类，一个为子类(派生类),一个为父类(基类)。 子类继承父类，,使用关键字<strong>extends</strong>来表示。</li><li>子类和父类之间，从意义上讲应该具有**”is a”**的关系.</li></ul><span id="more"></span><ul><li>object类</li><li>super</li><li>方法重写</li></ul><h4 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student is Person 从person继承，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    Person person;<span class="comment">//组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父类Person中新建say方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 人 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中调用student类 student类可以直接使用say方法</p><h4 id="子类继承了父类-就会拥有父类的全部方法"><a href="#子类继承了父类-就会拥有父类的全部方法" class="headerlink" title="子类继承了父类 就会拥有父类的全部方法"></a><strong>子类继承了父类 就会拥有父类的全部方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();使用父类的方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不仅是方法-属性也能继承"><a href="#不仅是方法-属性也能继承" class="headerlink" title="不仅是方法 属性也能继承"></a><strong>不仅是方法 属性也能继承</strong></h4><p>父类新增属性money</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 人 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类继承了父类的money属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();</span><br><span class="line"></span><br><span class="line">        System.out.print(student.money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/子类继承了父类的money属性.png" alt="子类继承了父类的money属性"><h4 id="私有类不能被继承"><a href="#私有类不能被继承" class="headerlink" title="私有类不能被继承"></a>私有类不能被继承</h4><p>朕给你的 才是你的</p><p>父类新增属性Emperor 新增方法kill</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 人 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> <span class="string">&quot;Emperor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拖下去斩了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类没有Emperor属性</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/子类没有Emperor属性.png" alt="子类没有Emperor属性"><p>子类不能使用kill方法</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/子类不能使用kill方法.png" alt="子类不能使用kill方法"><h4 id="不建议直接继承属性-可以使用get-set方法（封装）"><a href="#不建议直接继承属性-可以使用get-set方法（封装）" class="headerlink" title="不建议直接继承属性 可以使用get set方法（封装）"></a>不建议直接继承属性 可以使用get set方法（封装）</h4><p>设置money为私有 设置get set两个公有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 人 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> <span class="string">&quot;Emperor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拖下去斩了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以通过set方法更改money 通过get方法查看money</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();</span><br><span class="line"></span><br><span class="line">        System.out.println(student.getMoney());</span><br><span class="line">        student.setMoney(student.getMoney()-<span class="number">500</span>);</span><br><span class="line">        System.out.println(student.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/子类使用getset方法.png" alt="子类使用getset方法"><h4 id="快捷键-Ctrl-H"><a href="#快捷键-Ctrl-H" class="headerlink" title="快捷键 Ctrl+H"></a>快捷键 Ctrl+H</h4><p>在子类的大括号内使用可以查看<strong>继承树</strong></p><ul><li>student继承树</li></ul><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/student继承树.png" alt="student继承树"><ul><li><p>person继承树</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/person继承树.png" alt="person继承树"></li></ul><h3 id="了解Object类"><a href="#了解Object类" class="headerlink" title="了解Object类"></a>了解Object类</h3><p>我们可以看到在person类上面还有一个Object类</p><p>在删除掉person类里的所有方法之后 person仍然可以使用很多方法 这些都是object类的方法</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/person仍然可以使用一些方法.png" alt="person仍然可以使用一些方法"><p><strong>在Java中，所有的类都默认直接或者间接继承Object类</strong></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是继承&quot;&gt;&lt;a href=&quot;#什么是继承&quot; class=&quot;headerlink&quot; title=&quot;什么是继承&quot;&gt;&lt;/a&gt;什么是继承&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;继承的本质是对某-批类的抽象，从而实现对现实世界更好的建模。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extends&lt;/strong&gt;的意思是“扩展”。子类是父类的扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JAVA中类只有单继承，没有多继承！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。&lt;/li&gt;
&lt;li&gt;继承关系的俩个类，一个为子类(派生类),一个为父类(基类)。 子类继承父类，,使用关键字&lt;strong&gt;extends&lt;/strong&gt;来表示。&lt;/li&gt;
&lt;li&gt;子类和父类之间，从意义上讲应该具有**”is a”**的关系.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>登录的实现</title>
    <link href="https://www.szjm.online/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.szjm.online/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-06-05T02:33:23.000Z</published>
    <updated>2022-08-15T12:39:47.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-4-登录"><a href="#1-4-登录" class="headerlink" title="1.4 登录"></a>1.4 登录</h2><h3 id="1-4-1-寻找对应后端"><a href="#1-4-1-寻找对应后端" class="headerlink" title="1.4.1 寻找对应后端"></a>1.4.1 寻找对应后端</h3><h4 id="1-4-1-1-通过开发者工具"><a href="#1-4-1-1-通过开发者工具" class="headerlink" title="1.4.1.1 通过开发者工具"></a>1.4.1.1 通过开发者工具</h4><span id="more"></span><img src="/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/1.4.1.1_1通过开发者工具负载.png"><img src="/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/1.4.1.1_2通过开发者工具标头.png"><img src="/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/1.4.1.1_3通过开发者工具预览.png"><img src="/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/1.4.1.1_4通过开发者工具cookie.png"><p>分别可以看到</p><ul><li><p>请求地址是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dev-api/login</span><br></pre></td></tr></table></figure></li><li><p>传递的json是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uuid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ac4ccbd519eb4007b603e4c2f22427c5&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>返回的响应是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;操作成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzUxMiJ9.eyJsb2dpbl91c2VyX2tleSI6IjBkYzA5MjAwLTM3YjAtNDQ0My04N2Y1LTU1NDEwMjMzYjY1ZiJ9.F7h_9cWQyFejRpAh4trc8nOQ17jeSStG0g3vNm-SPUY0oQOKuM1fpLnLipKUO58bxUsOy-V7QSJ8ivfp4jIVBg&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>修改了username、rememberMe、password三项cookie</p></li></ul><h4 id="1-4-1-2-查看前端代码"><a href="#1-4-1-2-查看前端代码" class="headerlink" title="1.4.1.2 查看前端代码"></a>1.4.1.2 查看前端代码</h4><p>一共4个表单 分别保存了用户名、密码、验证码答案、记住用户4项，登录按钮是<code>handleLogin</code>方法</p><p>查看<code>handleLogin</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleLogin</span>(<span class="string">&quot;&gt; &#123;</span></span><br><span class="line"><span class="string">  this.$refs.loginForm.validate(valid =&gt; &#123;</span></span><br><span class="line"><span class="string">    if (valid&quot;</span>&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">rememberMe</span><span class="string">&quot;&gt; &#123;</span></span><br><span class="line"><span class="string">        Cookies.set(&quot;</span>username<span class="string">&quot;, this.loginForm.username, &#123; expires: 30 &#125;&quot;</span>&gt;;</span><br><span class="line">        <span class="title class_">Cookies</span>.<span class="title function_">set</span>(<span class="string">&quot;password&quot;</span>, <span class="title function_">encrypt</span>(<span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">password</span><span class="string">&quot;&gt;, &#123; expires: 30 &#125;&quot;</span>&gt;;</span><br><span class="line">        <span class="title class_">Cookies</span>.<span class="title function_">set</span>(<span class="string">&#x27;rememberMe&#x27;</span>, <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">rememberMe</span>, &#123; <span class="attr">expires</span>: <span class="number">30</span> &#125;<span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">      &#125; else &#123;</span></span><br><span class="line"><span class="string">        Cookies.remove(&quot;</span>username<span class="string">&quot;&quot;</span>&gt;;</span><br><span class="line">        <span class="title class_">Cookies</span>.<span class="title function_">remove</span>(<span class="string">&quot;password&quot;</span><span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">        Cookies.remove(&#x27;rememberMe&#x27;&quot;</span>&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;Login&quot;</span>, <span class="variable language_">this</span>.<span class="property">loginForm</span><span class="string">&quot;&gt;.then((&quot;</span>&gt; =&gt; &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="variable language_">this</span>.<span class="property">redirect</span> || <span class="string">&quot;/&quot;</span> &#125;<span class="string">&quot;&gt;.catch((&quot;</span>&gt;=&gt;&#123;&#125;<span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">      &#125;&quot;</span>&gt;.<span class="title function_">catch</span>((<span class="string">&quot;&gt; =&gt; &#123;</span></span><br><span class="line"><span class="string">        this.loading = false;</span></span><br><span class="line"><span class="string">        if (this.captchaOnOff&quot;</span>&gt; &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">getCode</span>(<span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;&quot;</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>记住用户</p><p>  判断是否勾选了记住用户</p><p>  如果是 保存用户名、密码、记住用户到cookie30天</p><p>  如果没有 从cookie清除这三项</p></li><li><p>登录方法</p><p>  ![1.4.1.2_1查看login方法1](4.登录的实现&#x2F;1.4.1.2_1查看login方法1.png”&gt;</p><p>  ![1.4.1.2_2查看login方法2](4.登录的实现&#x2F;1.4.1.2_2查看login方法2.png”&gt;</p><p>  ![1.4.1.2_3查看login方法3](4.登录的实现&#x2F;1.4.1.2_3查看login方法3.png”&gt;</p><p>  就是把这四项打包成json传到<code>/login</code>方法</p></li></ul><h4 id="1-4-1-3-查看后端代码"><a href="#1-4-1-3-查看后端代码" class="headerlink" title="1.4.1.3 查看后端代码"></a>1.4.1.3 查看后端代码</h4><ul><li><p>找到后端代码</p><p>还是使用在文件中查找的方式搜索<code>/login</code> (Ctrl+Shift+F”&gt;</p><p>![1.4.1.3_1在文件中查找login](4.登录的实现&#x2F;1.4.1.3_1在文件中查找login.png”&gt;</p></li><li><p>打断点确认</p><p>![1.4.1.3_2打断点确认](4.登录的实现&#x2F;1.4.1.3_2打断点确认.png”&gt;</p><p>可以看到<code>loginBody</code>的值</p></li><li><p>判断是否登录成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> loginService.login(loginBody.getUsername(<span class="string">&quot;&gt;, loginBody.getPassword(&quot;</span>&gt;, loginBody.getCode(<span class="string">&quot;&gt;,loginBody.getUuid(&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span><br></pre></td></tr></table></figure><p>通过一个<code>loginService.login</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, String code, String uuid<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">&#123;</span></span></span><br><span class="line"><span class="string"><span class="params">    boolean captchaOnOff = configService.selectCaptchaOnOff(&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    // 验证码开关</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (captchaOnOff<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="params">        validateCaptcha(username, code, uuid&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    // 用户验证</span></span><br><span class="line"><span class="params">    Authentication authentication = <span class="literal">null</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">try</span></span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">        // 该方法会去调用UserDetailsServiceImpl.loadUserByUsername</span></span><br><span class="line"><span class="params">        authentication = authenticationManager</span></span><br><span class="line"><span class="params">            .authenticate(new UsernamePasswordAuthenticationToken(username, password<span class="string">&quot;&gt;&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">catch</span> (Exception e<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="params">        if (e instanceof BadCredentialsException&quot;</span>&gt;</span></span><br><span class="line"><span class="params">        &#123;</span></span><br><span class="line"><span class="params">            AsyncManager.me(<span class="string">&quot;&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, MessageUtils.message(&quot;</span>user.password.not.match<span class="string">&quot;&quot;</span>&gt;<span class="string">&quot;&gt;&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">            throw new UserPasswordNotMatchException(<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="params">        else</span></span></span><br><span class="line"><span class="string"><span class="params">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="params">            AsyncManager.me(&quot;</span>&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, e.getMessage(<span class="string">&quot;&gt;&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">            throw new ServiceException(e.getMessage(&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="params">    AsyncManager.me(&quot;</span>&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_SUCCESS, MessageUtils.message(<span class="string">&quot;user.login.success&quot;</span><span class="string">&quot;&gt;&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    LoginUser loginUser = (LoginUser&quot;</span>&gt; authentication.getPrincipal(<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    recordLoginInfo(loginUser.getUserId(&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    // 生成token</span></span></span><br><span class="line"><span class="string"><span class="params">    return tokenService.createToken(loginUser&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>首先判断验证码验证是否开启，如果开启去验证验证码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateCaptcha</span><span class="params">(String username, String code, String uuid<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">&#123;</span></span></span><br><span class="line"><span class="string"><span class="params">    String verifyKey = Constants.CAPTCHA_CODE_KEY + StringUtils.nvl(uuid, &quot;</span><span class="string">&quot;&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    String captcha = redisCache.getCacheObject(verifyKey<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    redisCache.deleteObject(verifyKey&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (captcha == <span class="literal">null</span><span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="params">        AsyncManager.me(&quot;</span>&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, MessageUtils.message(<span class="string">&quot;user.jcaptcha.expire&quot;</span><span class="string">&quot;&gt;&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">        throw new CaptchaExpireException(&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (!code.equalsIgnoreCase(captcha<span class="string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">        AsyncManager.me(<span class="string">&quot;&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, MessageUtils.message(&quot;</span>user.jcaptcha.error<span class="string">&quot;&quot;</span>&gt;<span class="string">&quot;&gt;&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">        throw new CaptchaException(<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>  用固定字段<code>captcha_codes:</code>和<code>uuid</code>生成key</p><p>  从redis获取验证码答案</p><p>  删除答案</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-4-登录&quot;&gt;&lt;a href=&quot;#1-4-登录&quot; class=&quot;headerlink&quot; title=&quot;1.4 登录&quot;&gt;&lt;/a&gt;1.4 登录&lt;/h2&gt;&lt;h3 id=&quot;1-4-1-寻找对应后端&quot;&gt;&lt;a href=&quot;#1-4-1-寻找对应后端&quot; class=&quot;headerlink&quot; title=&quot;1.4.1 寻找对应后端&quot;&gt;&lt;/a&gt;1.4.1 寻找对应后端&lt;/h3&gt;&lt;h4 id=&quot;1-4-1-1-通过开发者工具&quot;&gt;&lt;a href=&quot;#1-4-1-1-通过开发者工具&quot; class=&quot;headerlink&quot; title=&quot;1.4.1.1 通过开发者工具&quot;&gt;&lt;/a&gt;1.4.1.1 通过开发者工具&lt;/h4&gt;</summary>
    
    
    
    <category term="楠哥" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="开源项目学习" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="若依前后端分离版" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/%E8%8B%A5%E4%BE%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="若依" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="楠哥" scheme="https://www.szjm.online/tags/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="若依" scheme="https://www.szjm.online/tags/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>验证码的后端实现</title>
    <link href="https://www.szjm.online/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.szjm.online/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-06-04T13:34:57.000Z</published>
    <updated>2022-08-15T12:40:51.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-3-1-2-查看Java代码"><a href="#1-3-1-2-查看Java代码" class="headerlink" title="1.3.1.2 查看Java代码"></a>1.3.1.2 查看Java代码</h4><ul><li><p>找到后端代码<span id="more"></span></p><ol><li>后端一共6个模块 其中<code>ruoyi-admin</code>是主要模块 也就是我们启动的模块<img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_1一共6个模块.png"></li><li>现在对于后端的代码还是不了解的，我们使用IDEA的工具搜索</li><li>搜索接口名称<code>captchaImage</code><ol><li>在包名<code>ruoyi-admin</code>上右击 选择<code>在文件中查找</code><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_2选择在文件中查找.png"></li><li>输入接口名<code>captchaImage</code></li><li>发现在<code>CaptchaController</code>的44行</li><li>双击定位到代码位置<img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_3查询功能的使用.png"></li></ol></li></ol></li><li><p>打断点验证</p><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_4打上断点.png"><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_5验证码加载失败.png"><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_6后端检测到断点响应.png"><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_7取消断点后响应成功.png"></li><li><p>分析后端代码</p><ol><li><p>大类前面没有接口注解 保证访问的是我们需要的接口<img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_8没有接口注解.png"></p></li><li><p>创建<code>AjaxResult</code>类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AjaxResult</span> <span class="variable">ajax</span> <span class="operator">=</span> AjaxResult.success();</span><br></pre></td></tr></table></figure><p>  一层一层点下去</p>  <img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_9Ajax_1.png">  <img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_10Ajax_2.png">  <img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_11Ajax_3.png">  <img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_12Ajax_4.png"></li><li><p>判断验证是否开启</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">captchaOnOff</span> <span class="operator">=</span> configService.selectCaptchaOnOff();</span><br><span class="line">ajax.put(<span class="string">&quot;captchaOnOff&quot;</span>, captchaOnOff);</span><br><span class="line"><span class="keyword">if</span> (!captchaOnOff)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ajax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果没有开启 直接return结束</p></li><li><p>保存验证码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存验证码信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> IdUtils.simpleUUID();</span><br><span class="line"><span class="type">String</span> <span class="variable">verifyKey</span> <span class="operator">=</span> Constants.CAPTCHA_CODE_KEY + uuid;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">capStr</span> <span class="operator">=</span> <span class="literal">null</span>, code = <span class="literal">null</span>;</span><br><span class="line"><span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_13CAPTCHA_CODE_KEY.png"><p>生成UUID，将CAPTCHA_CODE_KEY与UUID拼成新字符串作为Redis的key</p><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_14生成的key.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisCache.setCacheObject(verifyKey, code, Constants.CAPTCHA_EXPIRATION, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><p><code>verifyKey</code> captcha_codes： + 生成的UUID</p><p><code>code</code> 刚才那道算术题的答案</p><p><code>Constants.CAPTCHA_EXPIRATION</code> 值为2 就是有效期2分钟</p><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_15存储到redis.png"></li><li><p>将验证码保存为图片</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换流信息写出</span></span><br><span class="line"><span class="type">FastByteArrayOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ImageIO.write(image, <span class="string">&quot;jpg&quot;</span>, os);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AjaxResult.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  转换成jpg格式的图片</p></li><li><p>传给前端</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax.put(<span class="string">&quot;uuid&quot;</span>, uuid);</span><br><span class="line">ajax.put(<span class="string">&quot;img&quot;</span>, Base64.encode(os.toByteArray()));</span><br><span class="line"><span class="keyword">return</span> ajax;</span><br></pre></td></tr></table></figure><p>  将<em>UUID</em>也就是key值和生成的<em>图片</em>传给前端</p></li></ol></li></ul><h4 id="1-3-1-3-综合"><a href="#1-3-1-3-综合" class="headerlink" title="1.3.1.3 综合"></a>1.3.1.3 综合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getCode</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">getCodeImg</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">captchaOnOff</span> = res.<span class="property">captchaOnOff</span> === <span class="literal">undefined</span> ? <span class="literal">true</span> : res.<span class="property">captchaOnOff</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">captchaOnOff</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">codeUrl</span> = <span class="string">&quot;data:image/gif;base64,&quot;</span> + res.<span class="property">img</span>;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">uuid</span> = res.<span class="property">uuid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><ul><li>访问<code>captchaImage</code>接口 判</li><li>断返回的<code>captchaOnOff</code>是否为空 如果为空赋值为true，如果不为空赋值后端返回的值</li><li>如果<code>this.captchaOnOff</code>为真执行后续操作</li><li>后端返回的图片赋值给<code>this.codeUrl</code></li><li>后端返回的UUID赋值给<code> this.loginForm.uuid</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-3-1-2-查看Java代码&quot;&gt;&lt;a href=&quot;#1-3-1-2-查看Java代码&quot; class=&quot;headerlink&quot; title=&quot;1.3.1.2 查看Java代码&quot;&gt;&lt;/a&gt;1.3.1.2 查看Java代码&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;找到后端代码&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="楠哥" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="开源项目学习" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="若依前后端分离版" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/%E8%8B%A5%E4%BE%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="若依" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="楠哥" scheme="https://www.szjm.online/tags/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="若依" scheme="https://www.szjm.online/tags/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>验证码的前端实现</title>
    <link href="https://www.szjm.online/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.szjm.online/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-06-03T03:32:42.000Z</published>
    <updated>2022-08-15T02:46:10.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-3-验证"><a href="#1-3-验证" class="headerlink" title="1.3 验证"></a>1.3 验证</h2><h3 id="1-3-1-生成验证码"><a href="#1-3-1-生成验证码" class="headerlink" title="1.3.1 生成验证码"></a>1.3.1 生成验证码</h3><blockquote><p>基本思路</p></blockquote><ol><li>后端生成一个表达式，1+1&#x3D;2 写成1+1&#x3D;?@2</li><li>其中1+1&#x3D;?转换成图片验证码传到前端</li><li>答案2存入Redis</li><li>前端登录时 将输入框里的内容与Redis进行比对<span id="more"></span><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1_1Redis存储验证码答案.png"></li><li>如果修改Redis里的答案 即使验证码的答案与题目不一致 但是与Redis一致 也能成功登录</li></ol><h4 id="1-3-1-1-查看vue代码-ruoyi-ui-src-views-login-vue"><a href="#1-3-1-1-查看vue代码-ruoyi-ui-src-views-login-vue" class="headerlink" title="1.3.1.1 查看vue代码 ruoyi-ui/src/views/login.vue"></a>1.3.1.1 查看vue代码 <code>ruoyi-ui/src/views/login.vue</code></h4><ul><li><p>验证码是怎么展示的</p><ol><li>验证码应该是在初始化的时候加载的<img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_1初始化的方法.png"></li><li>看名字猜测是getCode<img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_2验证码的展示.png"></li><li>如果访问接口成功 获取图片的地址到<code>this.codeUrl</code>用来展示验证码图片 获取Redis的key值到<code>this.loginForm.uuid</code>用于验证码答案比对</li></ol></li><li><p>前端是怎么调用接口的</p><ol><li>追踪<code>getCodeImg()</code>，显示是从<code>@/api/login</code>引入的<img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_3追踪getCodeImg()1.png"> <img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_4追踪getCodeImg()2.png"></li><li>追踪<code>@/api/login</code>的<code>getCodeImg()</code>，注释表明是这个方法获取的验证码<img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_5注释写明是这个方法.png"><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_6与控制台的请求名称相同.png"></li><li>深入了解发现<code>request()</code>指向<code>@/utils/request</code><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_7追踪request()1.png"><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_8追踪request()2.png"></li><li>查看<code>@/utils/request</code>的<code>request()</code>，看到了<code>axios</code><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_9发现axios.png"><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_10接口注释对应1.png"><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_11接口注释对应2.png"></li></ol></li><li><p><code>Vue</code>的获取图片的请求到底是前端还是后端</p><p>我们看到vue获取验证码图片的地址是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dev-api/captchaImage</span><br></pre></td></tr></table></figure><p><strong>localhost后面没有跟端口号，也就是默认的80端口。而80是前端的端口号，后端的端口号是8080。</strong></p><p>反向代理 URL请求前端，进行代理，把前端映射到后端，解决跨域问题<br>前端还是在请求前端，所以没有跨越问题，代理将对于前端的请求转发到后端，完成请求</p></li><li><p>代理是在哪里做的</p><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_12前端反向代理代码.png"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxy</span>: &#123;</span><br><span class="line">  <span class="comment">// detail: https://cli.vuejs.org/config/#devserver-proxy</span></span><br><span class="line">  [process.<span class="property">env</span>.<span class="property">VUE_APP_BASE_API</span>]: &#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="string">`http://localhost:8080`</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">      [<span class="string">&#x27;^&#x27;</span> + process.<span class="property">env</span>.<span class="property">VUE_APP_BASE_API</span>]: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong><code>pathRewrite</code> 路径重写</strong></p><p>将VUE_APP_BASE_API的<code>/dev-api</code> 替换成<code>&#39;&#39;</code> 再映射到 <code>http://localhost:8080</code></p><p><a href="http://localhost/dev-api/captchaImage">http://localhost/dev-api/captchaImage</a> 变成 <a href="http://localhost:8080/captchaImage">http://localhost:8080/captchaImage</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-3-验证&quot;&gt;&lt;a href=&quot;#1-3-验证&quot; class=&quot;headerlink&quot; title=&quot;1.3 验证&quot;&gt;&lt;/a&gt;1.3 验证&lt;/h2&gt;&lt;h3 id=&quot;1-3-1-生成验证码&quot;&gt;&lt;a href=&quot;#1-3-1-生成验证码&quot; class=&quot;headerlink&quot; title=&quot;1.3.1 生成验证码&quot;&gt;&lt;/a&gt;1.3.1 生成验证码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;基本思路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;后端生成一个表达式，1+1&amp;#x3D;2 写成1+1&amp;#x3D;?@2&lt;/li&gt;
&lt;li&gt;其中1+1&amp;#x3D;?转换成图片验证码传到前端&lt;/li&gt;
&lt;li&gt;答案2存入Redis&lt;/li&gt;
&lt;li&gt;前端登录时 将输入框里的内容与Redis进行比对&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="楠哥" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="开源项目学习" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="若依前后端分离版" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/%E8%8B%A5%E4%BE%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="若依" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="楠哥" scheme="https://www.szjm.online/tags/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="若依" scheme="https://www.szjm.online/tags/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>运行若依项目</title>
    <link href="https://www.szjm.online/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.szjm.online/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-05-21T10:18:48.000Z</published>
    <updated>2022-08-15T11:23:08.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-若依（前后端分离版）"><a href="#1-若依（前后端分离版）" class="headerlink" title="1. 若依（前后端分离版）"></a>1. 若依（前后端分离版）</h1><h2 id="1-1-什么是若依？"><a href="#1-1-什么是若依？" class="headerlink" title="1.1 什么是若依？"></a>1.1 什么是若依？</h2><p>开源项目 在此基础上二次开发</p><ul><li>学习开源项目的目标：</li></ul><ol><li>直接用，减少自己的工作量</li><li>学习优秀开源项目底层的编程思想，设计思路，提高自己的编程能力</li></ol><ul><li>官网： <a href="http://www.ruoyi.vip/">RuoYi 若依官方网站</a><span id="more"></span></li><li>基础：SpringBoot + Vue</li><li>环境要求：<ol><li>JDK1.8+</li><li>MySQL</li><li>Redis</li><li>Maven</li><li>Vue</li></ol></li></ul><h2 id="1-2-使用若依"><a href="#1-2-使用若依" class="headerlink" title="1.2 使用若依"></a>1.2 使用若依</h2><p>使用开源项目的步骤：</p><ol><li><p>下载并运行</p></li><li><p>看懂业务流程</p></li><li><p>进行二次开发</p></li></ol><h3 id="1-2-1-下载"><a href="#1-2-1-下载" class="headerlink" title="1.2.1 下载"></a>1.2.1 下载</h3><p>若依的项目托管与Gitee，直接从gitee上<code>git clone</code>即可</p><h3 id="1-2-2-配置数据库MySQL、Redis"><a href="#1-2-2-配置数据库MySQL、Redis" class="headerlink" title="1.2.2 配置数据库MySQL、Redis"></a>1.2.2 配置数据库MySQL、Redis</h3><ul><li><p>MySQL</p><ol><li>创建数据库<code>ry-vue</code>并导入数据脚本<code>ry_2021xxxx.sql</code>，<code>quartz.sql</code></li><li>在<code>ruoyi-admin/src/main/resources/application-druid.yml</code>中配置数据库连接</li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.2_1配置数据库连接.png"></li></ol></li><li><p>Redis</p><ol><li>在<code>ruoyi-admin/src/main/resources/application.yml</code>中配置Redis连接</li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.2_2配置Redis连接.png"></li></ol></li></ul><h2 id="1-2-3-运行后端"><a href="#1-2-3-运行后端" class="headerlink" title="1.2.3 运行后端"></a>1.2.3 运行后端</h2><ol><li>运行<code>ruoyi-admin/src/main/java/com/ruoyi/RuoYiApplication.java</code></li><li>启动成功</li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.3_1启动成功.png"></li><li>浏览器访问成功</li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.3_2浏览器访问成功.png"></li></ol><h3 id="1-2-4-运行前端"><a href="#1-2-4-运行前端" class="headerlink" title="1.2.4 运行前端"></a>1.2.4 运行前端</h3><ol><li><p>安装依赖环境 </p></li><li><pre><code class="powershell">npm install --registry=https://registry.npmmirror.com<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">3. 启动服务</span><br><span class="line"></span><br><span class="line">4. ```powershell</span><br><span class="line">   npm run dev</span><br></pre></td></tr></table></figure></code></pre></li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.4_1前端启动成功.png"></li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.4_2浏览器访问成功.png"></li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.4_3成功进入系统.png"></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-若依（前后端分离版）&quot;&gt;&lt;a href=&quot;#1-若依（前后端分离版）&quot; class=&quot;headerlink&quot; title=&quot;1. 若依（前后端分离版）&quot;&gt;&lt;/a&gt;1. 若依（前后端分离版）&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是若依？&quot;&gt;&lt;a href=&quot;#1-1-什么是若依？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是若依？&quot;&gt;&lt;/a&gt;1.1 什么是若依？&lt;/h2&gt;&lt;p&gt;开源项目 在此基础上二次开发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习开源项目的目标：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;直接用，减少自己的工作量&lt;/li&gt;
&lt;li&gt;学习优秀开源项目底层的编程思想，设计思路，提高自己的编程能力&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;官网： &lt;a href=&quot;http://www.ruoyi.vip/&quot;&gt;RuoYi 若依官方网站&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="楠哥" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="开源项目学习" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="若依前后端分离版" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/%E8%8B%A5%E4%BE%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="若依" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="楠哥" scheme="https://www.szjm.online/tags/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="若依" scheme="https://www.szjm.online/tags/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>语音播报</title>
    <link href="https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5/"/>
    <id>https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5/</id>
    <published>2022-05-09T03:33:22.000Z</published>
    <updated>2022-08-15T12:46:31.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语音播报"><a href="#语音播报" class="headerlink" title="语音播报"></a>语音播报</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><p>Python  3.10.4<span id="more"></span></p><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5/Python版本.png"></li><li><p>库</p><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5/pip库.png"></li></ul><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p><a href="https://blog.csdn.net/qq_41185868/article/details/84946859">Py之pyttsx：pyttsx&#x2F;pyttsx3的简介、安装、使用方法之详细攻略</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工具模块</span></span><br><span class="line"><span class="keyword">import</span> pyttsx3 <span class="comment">#导入</span></span><br><span class="line"><span class="comment">#创建  初始化</span></span><br><span class="line">engine = pyttsx3.init()</span><br><span class="line"><span class="comment">#说话</span></span><br><span class="line">engine.say(<span class="string">&#x27;经过广州&#x27;</span>)</span><br><span class="line"><span class="comment">#运行</span></span><br><span class="line">engine.runAndWait()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;语音播报&quot;&gt;&lt;a href=&quot;#语音播报&quot; class=&quot;headerlink&quot; title=&quot;语音播报&quot;&gt;&lt;/a&gt;语音播报&lt;/h2&gt;&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python  3.10.4&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.szjm.online/categories/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/categories/Python/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Python" scheme="https://www.szjm.online/tags/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>运动抓拍</title>
    <link href="https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/"/>
    <id>https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/</id>
    <published>2022-05-09T03:31:47.000Z</published>
    <updated>2022-08-15T14:45:34.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运动抓拍"><a href="#运动抓拍" class="headerlink" title="运动抓拍"></a>运动抓拍</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Python  3.10.4<span id="more"></span><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/Python版本.png"></li><li>库<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/pip库.png"></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 保存截图地址</span></span><br><span class="line">save_path = <span class="string">&#x27;E:\\0\\autoimg\\&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义摄像头对象，其参数0表示第一个摄像头</span></span><br><span class="line">camera = cv2.VideoCapture(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># camera = cv2.VideoCapture(0)</span></span><br><span class="line"><span class="comment"># camera = cv2.VideoCapture(0, cv2.CAP_DSHOW)</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 判断视频是否打开</span></span><br><span class="line"><span class="keyword">if</span> (camera.isOpened()):</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;Open&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;摄像头未打开&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 测试用,查看视频size</span></span><br><span class="line">size = (<span class="built_in">int</span>(camera.get(cv2.CAP_PROP_FRAME_WIDTH)),</span><br><span class="line">  <span class="built_in">int</span>(camera.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;size:&#x27;</span>+<span class="built_in">repr</span>(size))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 帧率</span></span><br><span class="line">fps = <span class="number">30</span></span><br><span class="line"><span class="comment"># 总是取前一帧做为背景（不用考虑环境影响）</span></span><br><span class="line">pre_frame = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line"> start = time.time()</span><br><span class="line"> <span class="comment"># 读取视频流</span></span><br><span class="line"> ret, frame = camera.read()</span><br><span class="line"> <span class="comment"># 转灰度图</span></span><br><span class="line"> gray_lwpCV = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line"> end = time.time()</span><br><span class="line"> </span><br><span class="line"> cv2.imshow(<span class="string">&quot;capture&quot;</span>, frame)</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 运动检测部分</span></span><br><span class="line"> seconds = end - start</span><br><span class="line"> <span class="keyword">if</span> seconds &lt; <span class="number">1.0</span> / fps:</span><br><span class="line">  time.sleep(<span class="number">1.0</span> / fps - seconds)</span><br><span class="line"> gray_lwpCV = cv2.resize(gray_lwpCV, (<span class="number">500</span>, <span class="number">500</span>))</span><br><span class="line"> <span class="comment"># 用高斯滤波进行模糊处理</span></span><br><span class="line"> gray_lwpCV = cv2.GaussianBlur(gray_lwpCV, (<span class="number">21</span>, <span class="number">21</span>), <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 如果没有背景图像就将当前帧当作背景图片</span></span><br><span class="line"> <span class="keyword">if</span> pre_frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">  pre_frame = gray_lwpCV</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  <span class="comment"># absdiff把两幅图的差的绝对值输出到另一幅图上面来</span></span><br><span class="line">  img_delta = cv2.absdiff(pre_frame, gray_lwpCV)</span><br><span class="line">  <span class="comment">#threshold阈值函数(原图像应该是灰度图,对像素值进行分类的阈值,当像素值高于（有时是小于）阈值时应该被赋予的新的像素值,阈值方法)</span></span><br><span class="line">  thresh = cv2.threshold(img_delta, <span class="number">25</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</span><br><span class="line">  <span class="comment"># 膨胀图像</span></span><br><span class="line">  thresh = cv2.dilate(thresh, <span class="literal">None</span>, iterations=<span class="number">2</span>)</span><br><span class="line">  <span class="comment"># findContours检测物体轮廓(寻找轮廓的图像,轮廓的检索模式,轮廓的近似办法)</span></span><br><span class="line">  contours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">  <span class="comment"># image, contours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span></span><br><span class="line">  <span class="keyword">for</span> c <span class="keyword">in</span> contours:</span><br><span class="line">   <span class="comment"># 设置敏感度</span></span><br><span class="line">   <span class="comment"># contourArea计算轮廓面积</span></span><br><span class="line">   <span class="keyword">if</span> cv2.contourArea(c) &lt; <span class="number">1000</span>:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># print(&quot;出现目标物，请求核实&quot;)</span></span><br><span class="line">    <span class="comment"># # 保存图像</span></span><br><span class="line">    <span class="comment"># cv2.imwrite(save_path + str(time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;,time.localtime(time.time()))) + &#x27;.jpg&#x27;, frame)</span></span><br><span class="line">    <span class="comment"># print(&quot;抓拍1&quot;)</span></span><br><span class="line"></span><br><span class="line">    cv2.imwrite(save_path + <span class="built_in">str</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H_%M_%S&#x27;</span>,time.localtime(time.time()))) + <span class="string">&quot;.jpg&quot;</span>, frame)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;抓拍2&quot;</span> + <span class="built_in">str</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H_%M_%S&#x27;</span>,time.localtime(time.time()))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  pre_frame = gray_lwpCV</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># release()释放摄像头</span></span><br><span class="line">camera.release()</span><br><span class="line"><span class="comment">#destroyAllWindows()关闭所有图像窗口</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><ul><li>运行窗口<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/运行窗口.png"></li><li>命令行输出<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/命令行输出.png"></li><li>抓拍截图<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/抓拍截图.png"></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;运动抓拍&quot;&gt;&lt;a href=&quot;#运动抓拍&quot; class=&quot;headerlink&quot; title=&quot;运动抓拍&quot;&gt;&lt;/a&gt;运动抓拍&lt;/h2&gt;&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Python  3.10.4&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.szjm.online/categories/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/categories/Python/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Python" scheme="https://www.szjm.online/tags/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>调用电脑摄像头</title>
    <link href="https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    <id>https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/</id>
    <published>2022-05-09T03:04:19.000Z</published>
    <updated>2022-08-15T12:44:29.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调用电脑摄像头"><a href="#调用电脑摄像头" class="headerlink" title="调用电脑摄像头"></a>调用电脑摄像头</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Python  3.10.4<span id="more"></span><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/Python版本.png"></li><li>库<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/pip库.png"></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">1</span>) <span class="comment">#设置摄像头 0是默认的摄像头 如果你有多个摄像头的话呢，可以设置1,2,3....</span></span><br><span class="line"><span class="comment"># cap = cv2.VideoCapture(0) #设置摄像头 0是默认的摄像头 如果你有多个摄像头的话呢，可以设置1,2,3....</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:   <span class="comment">#进入无限循环</span></span><br><span class="line">ret,frame = cap.read() <span class="comment">#将摄像头拍到的图像作为frame值</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;frame&#x27;</span>,frame) <span class="comment">#将frame的值显示出来 有两个参数 前一个是窗口名字，后面是值</span></span><br><span class="line">c = cv2.waitKey(<span class="number">1</span>) <span class="comment">#判断退出的条件 当按下&#x27;Q&#x27;键的时候呢，就退出</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">cap.release()  <span class="comment">#常规操作</span></span><br><span class="line">cv2.DestroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/窗口拍摄.png">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;调用电脑摄像头&quot;&gt;&lt;a href=&quot;#调用电脑摄像头&quot; class=&quot;headerlink&quot; title=&quot;调用电脑摄像头&quot;&gt;&lt;/a&gt;调用电脑摄像头&lt;/h2&gt;&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Python  3.10.4&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.szjm.online/categories/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/categories/Python/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Python" scheme="https://www.szjm.online/tags/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>封装详解</title>
    <link href="https://www.szjm.online/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.szjm.online/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-16T14:09:29.000Z</published>
    <updated>2022-08-15T11:07:58.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><p>该露的露，该藏的藏</p><ul><li>我们程序设计要追求<strong>“高内聚，低耦合”</strong>。<ul><li>高内聚：就是类的内部数据操作细节自己完成，不允许外部干涉。</li><li>低耦合：仅暴露少量的方法给外部使用。<span id="more"></span></li></ul></li></ul></li><li><p>封装(数据的隐藏)</p><ul><li>通常, 应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。</li></ul></li><li><p>记住这句话就够了：<strong>属性私有，get&#x2F;set</strong></p><p>私有属性直接调用会报错</p></li></ul> <img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/私有属性直接调用会报错.png">  <h4 id="快速生成set-x2F-get方法"><a href="#快速生成set-x2F-get方法" class="headerlink" title="快速生成set&#x2F;get方法"></a>快速生成set&#x2F;get方法</h4><img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/alt+insert.png"><img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/选择需要构造的属性.png"><img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/点击ok生成成功.png"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>提高数据安全性 保护数据</p></li><li><p>隐藏代码实现细节</p></li><li><p>统一接口</p></li><li><p>提高系统可维护性</p></li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//类 private:私有</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//    名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;         <span class="comment">//    学号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;       <span class="comment">//    性别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">//    年龄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一些可以操作这个属性的方法</span></span><br><span class="line"><span class="comment">//    public 的 get/set方法</span></span><br><span class="line"><span class="comment">//    get 获得数据/属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    set 给这个数据设置值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    alt+insert 快速生成get/set方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="comment">//        对于不合法的数据可以在这里做限制</span></span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">150</span> &amp;&amp; age &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.Demo04.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setName(<span class="string">&quot;SZJM&quot;</span>);</span><br><span class="line">        System.out.println(s1.getName());</span><br><span class="line">        s1.setAge(<span class="number">999</span>);</span><br><span class="line">        System.out.println(s1.getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/Demo04.png">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;该露的露，该藏的藏&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们程序设计要追求&lt;strong&gt;“高内聚，低耦合”&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;高内聚：就是类的内部数据操作细节自己完成，不允许外部干涉。&lt;/li&gt;
&lt;li&gt;低耦合：仅暴露少量的方法给外部使用。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>简单小结类与对象</title>
    <link href="https://www.szjm.online/2022/04/11/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A107_%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.szjm.online/2022/04/11/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A107_%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-04-11T01:14:49.000Z</published>
    <updated>2022-04-11T01:15:25.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单小结类与对象"><a href="#简单小结类与对象" class="headerlink" title="简单小结类与对象"></a>简单小结类与对象<span id="more"></span></h3><ol><li>类与对象<ul><li>类是一个模板，抽象；对象是一个具体的实例</li></ul></li><li>方法<ul><li>定义、调用</li></ul></li><li>对应的引用<ul><li>引用类型：基本类型（8个）除了基本类型都可以叫做引用类型</li><li>对象通过引用操作（地址） 栈–&gt;堆</li></ul></li><li>属性 字段field 成员变量<ul><li>默认初始化：<ul><li>数字：<code>0</code> <code>0.0</code></li><li>char：<code>u0000</code></li><li>boolean：<code>false</code></li><li>其他：<code>null</code></li></ul></li><li>修饰符：属性类型 属性名&#x3D; 属性值</li></ul></li><li>对象的创建和使用<ul><li>必须使用<code>new</code>  关键字创造对象，构造器  <code>Person SZJM = new Person();</code></li><li>对象的属性 <code>SZJM.name</code></li><li>对象的方法 <code>SZJM.touchFish()</code></li></ul></li><li>类：<ul><li>静态的属性   属性</li><li>动态的行为   方法</li></ul></li><li>三大特征<ul><li>封装</li><li>继承</li><li>多态</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;简单小结类与对象&quot;&gt;&lt;a href=&quot;#简单小结类与对象&quot; class=&quot;headerlink&quot; title=&quot;简单小结类与对象&quot;&gt;&lt;/a&gt;简单小结类与对象&lt;/h3&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>创建对象内存分析</title>
    <link href="https://www.szjm.online/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A106_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
    <id>https://www.szjm.online/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A106_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</id>
    <published>2022-04-10T14:51:07.000Z</published>
    <updated>2022-08-15T11:09:04.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h3><p><strong>栈放变量名，堆放对象</strong><span id="more"></span></p><img src="/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A106_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/创建对象内存分析.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"><span class="comment">//默认有一个无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;叫一声&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.Demo03.Pet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pet</span>();</span><br><span class="line">        dog.name = <span class="string">&quot;闹闹&quot;</span>;</span><br><span class="line">        dog.age = <span class="number">5</span>;</span><br><span class="line">        dog.shout();</span><br><span class="line"></span><br><span class="line">        System.out.println(dog.name);</span><br><span class="line">        System.out.println(dog.age);</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pet</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A106_%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/Demo03.png">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;构造器详解&quot;&gt;&lt;a href=&quot;#构造器详解&quot; class=&quot;headerlink&quot; title=&quot;构造器详解&quot;&gt;&lt;/a&gt;构造器详解&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;栈放变量名，堆放对象&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>构造器详解</title>
    <link href="https://www.szjm.online/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A105_%E6%9E%84%E9%80%A0%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.szjm.online/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A105_%E6%9E%84%E9%80%A0%E5%99%A8%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-10T14:06:22.000Z</published>
    <updated>2022-08-15T11:09:49.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h3><p><strong>构造器必须要掌握</strong><span id="more"></span></p><p><strong>一个类即使什么都不写 编译时也会存在一个方法</strong></p><ul><li>使用new关键字创建对象</li><li>使用new关键字创建的时候，除了分配内存空间之外，还会给<em>创建好的对象</em>进行默认的初始化<br>以及对类中构造器的调用。</li><li>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩<br>个特点:<ol><li>必须和类的名字相同</li><li>必须没有返回类型，也不能写void</li></ol></li><li>构造器必须要掌握</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">//    一个类即使什么都不写 编译时也会存在一个方法</span></span><br><span class="line"><span class="comment">//    显示的定义构造器</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    实例化初始值</span></span><br><span class="line"><span class="comment">//    1. 使用new关键字，必须要有构造器</span></span><br><span class="line"><span class="comment">//    2. 构造器一般用来初始化值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;SZJM&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    有参构造 一旦定义了有参构造 无参构造就必须显示定义 此时无参构造必须存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo02;</span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        new 实例化一个对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(person.name);<span class="comment">//SZJM</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;十早九木&quot;</span>);</span><br><span class="line">        System.out.println(person1.name);<span class="comment">//十早九木</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A105_%E6%9E%84%E9%80%A0%E5%99%A8%E8%AF%A6%E8%A7%A3/Demo02构造器.png"><h4 id="ALT-Enter-快速生成构造器"><a href="#ALT-Enter-快速生成构造器" class="headerlink" title="ALT + Enter 快速生成构造器"></a>ALT + Enter 快速生成构造器</h4><img src="/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A105_%E6%9E%84%E9%80%A0%E5%99%A8%E8%AF%A6%E8%A7%A3/快速生成构造器.png"><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><p>构造器：</p><ol><li>方法名必须和类名相同</li><li>没有返回值</li></ol></li><li><p>作用：</p><ol><li>new 本质在调用构造方法</li><li>初始化对象的值</li></ol></li><li><p>注意：</p><ol><li>定义有参构造之后，如果想使用无参构造 显示的定义一个无参的构造</li></ol></li><li><p>快捷键</p><ol><li>ALT + Enter 快速生成构造器</li></ol></li><li><p>新</p><ol><li><code>this.</code></li></ol></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;构造器详解&quot;&gt;&lt;a href=&quot;#构造器详解&quot; class=&quot;headerlink&quot; title=&quot;构造器详解&quot;&gt;&lt;/a&gt;构造器详解&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;构造器必须要掌握&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>类与对象的创建</title>
    <link href="https://www.szjm.online/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A104_%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>https://www.szjm.online/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A104_%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</id>
    <published>2022-04-10T13:30:51.000Z</published>
    <updated>2022-08-15T11:10:18.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><ul><li>类是一种抽象的数据类型，它是对某一类事物整体描述&#x2F;定义，但是并不能代表某一个具体的事物。<span id="more"></span></li><li>动物、植物、手机、电脑…..</li><li>Person类、Pet类、 Car类等，这些类都是用来描述&#x2F;定义某一类具体的事物应该具备的特<br>点和行为</li><li>对象是抽象概念的具体实例<ul><li>张三就是人的一个具体实例，张三家里的旺财就是狗的一个具体实例。</li><li>能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo02;</span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="comment">//    属性  （字段)</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;在学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo02;</span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        类是抽象的 需要实例化</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">//        类实例化之后会返回一个自己的对象</span></span><br><span class="line"><span class="comment">//        student 对象就是一个 Student 类的具体实例</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">Ming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">Hong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(Ming.name);</span><br><span class="line">        System.out.println(Ming.age);</span><br><span class="line"></span><br><span class="line">        Ming.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">        Ming.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(Ming.name);</span><br><span class="line">        System.out.println(Ming.age);</span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++&quot;</span>);</span><br><span class="line">        System.out.println(Hong.name);</span><br><span class="line">        System.out.println(Hong.age);</span><br><span class="line"></span><br><span class="line">        Hong.name = <span class="string">&quot;小红&quot;</span>;</span><br><span class="line">        Hong.age = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(Hong.name);</span><br><span class="line">        System.out.println(Hong.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A104_%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/创建应用对象.png">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;类与对象的关系&quot;&gt;&lt;a href=&quot;#类与对象的关系&quot; class=&quot;headerlink&quot; title=&quot;类与对象的关系&quot;&gt;&lt;/a&gt;类与对象的关系&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类是一种抽象的数据类型，它是对某一类事物整体描述&amp;#x2F;定义，但是并不能代表某一个具体的事物。&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>回顾方法的调用</title>
    <link href="https://www.szjm.online/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103_%E5%9B%9E%E9%A1%BE%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>https://www.szjm.online/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103_%E5%9B%9E%E9%A1%BE%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</id>
    <published>2022-04-10T13:10:16.000Z</published>
    <updated>2022-08-15T11:13:52.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回顾方法及加深"><a href="#回顾方法及加深" class="headerlink" title="回顾方法及加深"></a>回顾方法及加深</h3><ul><li><p>方法的调用 <span id="more"></span></p><ul><li><p>静态方法</p></li><li><p>非静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    静态方法 static 直接通过类名调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Student.say1();</span></span><br><span class="line">        Student.say2();</span><br><span class="line"><span class="comment">//        实例化这个类 new</span></span><br><span class="line"><span class="comment">//        new Student().say1(); 或者</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    static 和类一起加载 调用此时还不存在的非静态类报错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        b();</span><br><span class="line"><span class="comment">//        c();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        a();</span><br><span class="line"><span class="comment">//        c();</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    类实例化之后才存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">        a();</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"><span class="comment">//Student类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在办公室就听到你们说话了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;整个楼道就你们班有人说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在办公室就听到你们说话了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;整个楼道就你们班有人说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>  <img src="/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103_%E5%9B%9E%E9%A1%BE%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/静态类与非静态类.png">  <ul><li><p>形参和实参 (形参和实参的类型要对应)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        形参和实参的类型要对应</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Demo03</span>().add1(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(add2(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>  <img src="/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103_%E5%9B%9E%E9%A1%BE%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/Demo03.png">  <ul><li><p>值传递和引用传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        change(a);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>  <img src="/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103_%E5%9B%9E%E9%A1%BE%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/Demo04值传递.png">    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"><span class="comment">//引用传递 传递对象 本质还是值传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(person.age);<span class="comment">//0</span></span><br><span class="line">        change(person);</span><br><span class="line">        System.out.println(person.age);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">        <span class="comment">//        person这个对象 指定了这个对象 具体的值 可以改变</span></span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个Person类 有一个属性name</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;<span class="comment">//默认值null</span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//默认值0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <img src="/2022/04/10/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A103_%E5%9B%9E%E9%A1%BE%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/Demo05引用传递.png">  <ul><li>this关键字</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;回顾方法及加深&quot;&gt;&lt;a href=&quot;#回顾方法及加深&quot; class=&quot;headerlink&quot; title=&quot;回顾方法及加深&quot;&gt;&lt;/a&gt;回顾方法及加深&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法的调用&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
