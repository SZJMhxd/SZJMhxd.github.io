<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>十早九木のBlog</title>
  
  
  <link href="https://www.szjm.online/atom.xml" rel="self"/>
  
  <link href="https://www.szjm.online/"/>
  <updated>2022-08-30T07:51:01.614Z</updated>
  <id>https://www.szjm.online/</id>
  
  <author>
    <name>十早九木</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>复用类</title>
    <link href="https://www.szjm.online/2022/08/30/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/7.%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
    <id>https://www.szjm.online/2022/08/30/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/7.%E5%A4%8D%E7%94%A8%E7%B1%BB/</id>
    <published>2022-08-30T07:42:04.000Z</published>
    <updated>2022-08-30T07:51:01.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-复用类"><a href="#7-复用类" class="headerlink" title="7. 复用类"></a>7. 复用类</h1><p>复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。<span id="more"></span></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;7-复用类&quot;&gt;&lt;a href=&quot;#7-复用类&quot; class=&quot;headerlink&quot; title=&quot;7. 复用类&quot;&gt;&lt;/a&gt;7. 复用类&lt;/h1&gt;&lt;p&gt;复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它还必须能够做更多的事情。&lt;/p&gt;</summary>
    
    
    
    <category term="hwcd" scheme="https://www.szjm.online/categories/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/categories/hwcd/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="hwcd" scheme="https://www.szjm.online/tags/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/tags/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>访问控制权限</title>
    <link href="https://www.szjm.online/2022/08/30/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/6.%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/"/>
    <id>https://www.szjm.online/2022/08/30/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/6.%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</id>
    <published>2022-08-30T07:40:23.000Z</published>
    <updated>2022-08-30T07:40:25.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-访问控制权限"><a href="#6-访问控制权限" class="headerlink" title="6. 访问控制权限"></a>6. 访问控制权限</h1><p>访问控制(或隐藏具体实现)与“最初的实现并不恰当“有关。<span id="more"></span></p><p>作品的某些部分需要多次编辑才会变得完美，有时回头看自己的代码，就能发现更好的实现方式，这就是重构的原动力之一。</p><p>重构就是重写代码，使其更可读、更易理解，并因此而更具可维护性。</p><p>但是，通常有一些客户端程序员需要在代码的某些部分保持不变，这时候就需要考虑“如何把变动的事物和保持不变的事物区分开来”。</p><p>这对类库（library）而言十分重要，对于客户端程序员而言，他们知道库被更新了，但是只需要修改使用的库名字，而不需要修改自己的代码；而对于类库开发者而言，能保证自己能对类库进行修改，而客户端程序员不能。</p><p>反过来，类库开发者也不知道那些代码被客户端程序员使用了，不知道那些代码可以修改，那些代码不能。</p><p>为了解决这一问题，Java提供了可以限制访问权限的关键字，从最大权限到最小权限依次为<code>public</code>，<code>protected</code>，<code>default</code>(包访问权限 友好的),<code>private</code>。</p><p>作为类库开发者，应该尽可能的将一切方法都设置为<code>private</code>，仅仅向客户端程序员开放你愿意让他们使用的方法。</p><p>构建类库的概念以及对于谁有权用该类库构件的控制问题还是不完善的。如何将构件捆绑到一个内聚的类库单元？可以用package控制。</p><h2 id="6-1-包：库单元"><a href="#6-1-包：库单元" class="headerlink" title="6.1 包：库单元"></a>6.1 包：库单元</h2><p>包内包含有一组类，他们在单一的名字空间之下被组织在了一起。</p><p>在Java的标准发布中有一个工具库，在java.util名字空间下。其中的ArrayList类的一种使用方式就是用全名<code>java.util.ArrayList</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FullQualification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.util.<span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式会使程序语句非常冗长，可以使用另一种方式<code>import</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleImport</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        ArrayList list = new java.util.ArrayList();</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//现在可以直接这么写</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们只是导入了ArrayList，如果我们想使用java.util中其他的类，还得新写一个导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><p>可以用这种方法，使用java.util下所有的类。</p><p>之所以要导入是因为要提供一个管理名字空间的机制，所有的类成员的名称都是彼此隔离的。如果你本地有一个stack类，然而你又在网络上下载了一个同名的stack类，怎么区分呢？这时候为每个类创建唯一标识符就成了非常重要的事情。</p><p>目前为止书里的示例都在单一文件中，专为local use（本地使用）而设计，所以没有受到包名的干扰。</p><p>其实他们已经在包里了，<code>未命名包</code>，或者叫<code>默认包</code>。虽然为了简单起见，书里目前其他部分都是本地默认包，不过如果准备准备编写在其他机器上能共存的类库的话，就需要考虑防止类名称之间的冲突问题。</p><p>编写Java源代码文件时，这个文件通常被称之为编译单元（或者叫转译单元）。</p><p>每个编译单元必须有一个后缀<code>.java</code>，而编译单元内可以有一个public类，这个类的名字必须与文件名字相同（包括大小写，但是不包括后缀）。</p><p>每个编译单元只能有一个public类，如果在编译单元之中还有别的类，包外是无法看见这些类的，因为他们不是public类，主要用来为主类提供支持。</p><h3 id="6-1-1-代码组织"><a href="#6-1-1-代码组织" class="headerlink" title="6.1.1 代码组织"></a>6.1.1 代码组织</h3><p>编译.java文件时，文件里的每个类都会有一个输出文件，同名，但是后缀改成了.class。</p><p>在编译少量的.java文件会得到大量的class文件。</p><p>编译型语言是对于编译器产生一个中间件文件，再通过连接器或者类库产生器产生的其他同类文件捆绑在一起。</p><p>Java是把可运行程序打包并压缩为一个Java文档文件jar，Java解释器负责这些文件的查找、装载和解释。</p><p>类库实际上是一组类文件，每个文件都有一个public类，以及任意数量的非public类，因此每个文件都有一个构件，如果希望这些构件从属于一个群组，可以使用关键字package。</p><p>使用package语句必须在文件除注释外第一句，在文件的起始处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> access;</span><br></pre></td></tr></table></figure><p>这声明该编译单元是名为access类库的一部分，你正在声明这个编译类在该编译单元中的public类在access名称的保护伞下，任何使用该名称的人都需要在使用前给出选择，指定全名或者使用import关键字。（Java包的命名规则全部使用小写字母，包括中间的字）</p><p>假设文件的名称是MyClass.java，这就意味着该文件中有且只有一个public类，该类的名称必须是MyClass（大小写必须一致）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:access/mypackage/MyClass.java</span></span><br><span class="line"><span class="keyword">package</span> access.mypackage</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果有人想使用MyClass或者access中任何其他public类，就必须使用import关键字或者使用全名引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QyalifiedMyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        access.mypackage.<span class="type">MyClass</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">access</span>.mypackage.MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般使用简洁的import关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access.mypackage.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImportedMyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类库设计员需要牢记package和import关键字允许做的是将单一的全局名字空间分割开来，这样无论多少人使用网络和Java的开始编写类，都不会出现名称冲突的问题。</p><h3 id="6-1-2-创建独一无二的包名"><a href="#6-1-2-创建独一无二的包名" class="headerlink" title="6.1.2 创建独一无二的包名"></a>6.1.2 创建独一无二的包名</h3><p>既然一个包从未真正的被打包包装成单一的文件，并且可以由许多.class文件构成，这样情况就会变得复杂。</p><p>为了避免这种情况，一种方法是把特定包的所有.class文件都置于一个目录下，利用操作系统的层次化文件结构来解决这个问题。</p><p>所有的文件收入子目录还可以解决另外两个问题：</p><ol><li><p>怎样创建独一无二的名称</p></li><li><p>怎样查找可能隐藏域目录结构某处的类</p></li></ol><p>这些任务通过将.class文件所在的路径位置编码成package的名称来实现。</p><p>如果按照使用域名为包名的惯例，因为域名是全网惟一的，所以package的名称也将是独一无二的，就不会出现名称冲突的问题，当然你也可以用其他的命名方法，如果你想要发布你的Java程序代码，最好还是取得一个域名。</p><p>把package名称分解为机器上的目录，当Java程序运行并且需要加载class文件的时候，就可以确定.class文件在目录上所处的位置。Java运行过程如下：</p><p>首先，找出环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找.class文件的根目录，从根目录开始，解释器获取包名并且将每个<code>.</code>替换成<code>/</code>或者<code>\</code>或者取决于操作系统的其他符号，解释器会在转换后的地址中查找与你所需要创建的类名称的相关class文件。</p><p>以我的域名szjm.online为例，把他的顺序倒过来，全部转换成小写，online.szjm就成为了我创建的类的独一无二的全局名称，如果在创建一个<code>simple</code>类，那么这个包的名称就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> online.szjm.simple;</span><br></pre></td></tr></table></figure><p>实际使用中就是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> online.szjm.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;online.szjm.simple.Vector&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个包的相对路径是在<code>online\szjm\simple\Vector</code>，那么这个路径之前的部分是什么呢，是CLASSPATH设定的地址。</p><p>从Java5开始CLASSPATH默认就是当前路径，一般情况下就不需要再设定了。若使用Java5以前的版本，需要设置环境变量CLASSPATH为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">CLASSPATH</span></span><br><span class="line">.;%<span class="variable constant_">JAVA_HOME</span>%\lib\dt.<span class="property">jar</span>;%<span class="variable constant_">JAVA_HOME</span>%\lib\tools.<span class="property">jar</span></span><br></pre></td></tr></table></figure><p>其中dt.jar是关于java运行环境的类库；tools.jar是工具类库</p><p>一旦类路径得到正确确认，使用类包的文件就可以在任何位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> online.szjm.simple.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LibTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">        <span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">List</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器碰到simple的import语句时，就会在CLASSPATH所指定的目录中查找<code>online\szjm\simple</code>，然后从已编译的文件中查找名称相符的（Vector对应Vector.class  List对应List.class），这里要注意这两个方法需要是public</p><p>如果两个含有相同名称的类库都使用*的方式导入，会怎么样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> online.szjm.simple.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><p>由于java.util.*和我们定义的online.szjm.simple.*都包含Vector类，那么我们在用new创建类时，就会产生冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Vector</span> <span class="variable">V</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br></pre></td></tr></table></figure><p>这里到底用的哪个类呢？编译器是不知道的，就会报错，强制程序员明确指明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.<span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Vector();</span><br></pre></td></tr></table></figure><p>这种写法配合CLASSPATH就可以完全指明Vector的位置，然而这种情况下如果不需要使用java.util下的其他内容，就可以不用写<code>import java.util.*;</code>语句了。</p><h3 id="6-1-3-定制工具库"><a href="#6-1-3-定制工具库" class="headerlink" title="6.1.3 定制工具库"></a>6.1.3 定制工具库</h3><p>现在可以创建自己的类库来减少或消除重复的程序代码了，比如可以新写一个输出类来替代System.out</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> online.szjm.tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        System.out.print(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PrintStream <span class="title function_">printf</span><span class="params">(String format, Object... args)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.out.printf(format, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完后，就可以用import static语句在系统上使用静态的print和println方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C6.C1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> online.szjm.tools.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;自定义的换行输出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>经过我的测试在命令行javac需要手动配置CLASSPATH 还可能需要加包名，在IDEA环境需要手动导入库，如果只是这个项目使用就导入项目设置里的库，如果是以后也使用就导入全局库，记得要是class文件的，所以在IDEA一般是out输出文件夹</strong></p><img src="/2022/08/30/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/6.%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/6_1_3_1IDEA导入库.png" alt="6_1_3_1IDEA导入库"><p>从现在开始，你无论何时创建的有用的新工具都可以添加到自己的类库中。</p><h3 id="6-1-4-用import改变行为"><a href="#6-1-4-用import改变行为" class="headerlink" title="6.1.4 用import改变行为"></a>6.1.4 用import改变行为</h3><p>Java没有C的条件编译功能，该功能可以使你不必更改任何程序代码，就能够切换开关并产生不同的行为。Java去掉此功能的原因可能是因为C在绝大多数情况下是用此功能来解决跨平台问题的，即程序代码的不同部分是根据不同的平台来编译的。由于Java自身可以自动跨越不同的平台，因此这个功能对Java而言是没有必要的。</p><p>然而，条件编译还有其他一些有价值的用途。调试就是一个很常见的用途。调试功能在开发过程中是开启的，而在发布的产品中是禁用的。可以通过修改被导入的package的方法来实现这一目的，修改的方法是将你程序中用到的代码从调试版改为发布版。这一技术可以适用于任何种类的条件代码。</p><h3 id="6-1-5-对使用包的忠告"><a href="#6-1-5-对使用包的忠告" class="headerlink" title="6.1.5 对使用包的忠告"></a>6.1.5 对使用包的忠告</h3><p>无论何时创建包，都已经在给定的包的名称的时候隐含的指定了目录结构，这个包必须位于其名称所指定的目录中，而该目录必须是在以CLASSPATH开始的目录中可以查询的。</p><p>除非遵守“包的名字对应目录路径”的规则，否则就可能报错，告知无法找到特定的类，哪怕这个类在同一个目录中。</p><p>如果遇到类似报错，注释掉package语句，如果这样程序就能运行，就知道问题在哪了。</p><p>编译过的代码通常与源代码在不同的目录里，但是必须保证JVM可以使用CLASSPATH找到该路径。</p><h2 id="6-2-Java访问权限修饰词"><a href="#6-2-Java访问权限修饰词" class="headerlink" title="6.2 Java访问权限修饰词"></a>6.2 Java访问权限修饰词</h2><p><code>public</code>、<code>protected</code>和<code>private</code>这几个Java访问权限修饰词在使用时，是置于类中每个成员的定义之前的，无论它是一个域还是一个方法。每个访问权限修饰词仅控制它所修饰的特定定义的访问权。</p><p>如果不提供任何访问权限修饰词，则意味着它是“包访向权限”。因此，无论如何，所有事<br>物都具有某种形式的访问权限控制。</p><h3 id="6-2-1-包访问权限"><a href="#6-2-1-包访问权限" class="headerlink" title="6.2.1 包访问权限"></a>6.2.1 包访问权限</h3><p>之前的所有示例都没有使用任何访问权限修饰词。默认访向权限没有任何关键字，但通常是指包访问权限(有时也表示成为friendly)。这就意味着当前的包中的所有其他类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。由于一个编译单元(即一个文件)， 只能隶属于一个包，所以经由包访问权限，处于同一个编译单元中的所有类彼此之间都是自动可访问的。</p><p>包访问权限允许将包内所有相关的类组合起来，以使它们彼此之间可以轻松地相互作用。</p><p>当把类组织起来放进一个包内之时， 也就给它们的包访向权限的成员赋予了相互访向的权限，你“拥有”了该包内的程序代码。“只有你拥有的程序代码才可以访向你所拥有的其他程序代码”,这是合理的。</p><p>应该说，包访问权限为把类群聚在一个包中的做法提供了意义和理由。在许多语言中，在文件内组织定义的方式是任意的，但在Java中，则要强制你以一种合理的方式对它们加以组织。另外，你可能还想要排除这样的类，它们不应该访问在当前包中所定义的类。</p><p>类控制着哪些代码有权限访问自己的成员，取得对某成员的访问权的唯一途径是：</p><ol><li>使该成员成为public。于是，无论是谁，无论在哪里，都可以访问该成员。</li><li>不加访问权限修饰词，并将其他类放置于同一个包内，给成员赋予包访问权。于是包内的其他类也就可以访问该成员了。</li><li>在第7章将会介绍继承技术，继承而来的类既可以访间public成员也可以访向protected成员(但访问private成员却不行)。 只有在两个类都处于同一个包内时，它才可   以访问包访问权限的成员。但现在不必担心继承和protected。</li><li>提供访问器(acessor) 和变异器(mutator) 方法(也称作getset方法),以读取和改变数值。对OOP而言，这是最优雅的方式，而且这也是JavaBeans的基本原理。</li></ol><h3 id="6-2-2-public-接口访问权限"><a href="#6-2-2-public-接口访问权限" class="headerlink" title="6.2.2 public: 接口访问权限"></a>6.2.2 public: 接口访问权限</h3><p>使用关键字public,就意味着public之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。假设定义了一个包含下面编译单元的dessert包:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> access.dessert;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cookie</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cookie construcrot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bite</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bite&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Cookie.java文件必须在<code>access\dessert</code>目录下。Java不是总是将当前目录视作查找行为的起点，如果CLASSPATH之中缺少了<code>.</code>作为路径，Java就不会查找那里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access.dessert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dinner</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就创建了一个Cookie对象，他的构造器是public而且类也是public，但是bite只向在dessert包中的类提供访问权，所以bite成员在dinner之间是无法访问的。</p><p>下面这个代码虽然看起来破坏了规则，但是可以编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:access/Cake.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cake</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pie</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pie</span>();</span><br><span class="line">        x.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个处于相同目录的文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:access/Pie.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pie</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pie.f()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会有人认为这两个文件毫不相关，但是Cake却可以创建一个Pie对象并调用他的f()方法</p><p>Cake能访问Pie是因为这两个包都没有给自己设定任何包名称，Java就会将这样的文件看做隶属于该目录的默认包，该目录的所有文件都有互相访问的权限。</p><h3 id="6-2-3-private：你无法访问"><a href="#6-2-3-private：你无法访问" class="headerlink" title="6.2.3 private：你无法访问"></a>6.2.3 private：你无法访问</h3><p>关键字private的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员。由于处于同一个包内的其他类是不可以访问private成员的，因此这等于说是自己隔离了自己。</p><p>从另一方面说，让许多人共同合作来创建一个包也是不大可能的，为此private就允许你随意改变该成员，而不必考虑这样做是否会影响到包内其他的类。</p><p>默认的包访问权限通常已经提供了充足的隐藏措施。请记住，使用类的客户端程序员是无法访问包访问权限成员的。</p><p>这样做很好，因为默认访问权限是一种我们常用的权限，同时也是一种在忘记添加任何访问权限控制时能够自动得到的权限。因此，通常考虑的是，哪些成员是想要明确公开给客户端程序员使用的，从而将它们声明为public,而在最初，你可能不会认为自己经常会需要使用关键字private,因为没有它，照样可以工作。然而，事实很快就会证明，对private的使用是多么的重要，在多线程环境下更是如此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sundae</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sundae</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Sundae <span class="title function_">makeASundae</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sundae</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IceCream</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="comment">//Sundae x = new Sundae();</span></span><br><span class="line">            <span class="type">Sundae</span> <span class="variable">x</span> <span class="operator">=</span> Sundae.makeASundae();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很好的说明private的例子，这个例子中，不能够通过构造器来创建Sundae对象，必须通过makeASundae()方法来达到这个目的。</p><p>任何可以肯定只是该类的一个“ 助手”方法的方法，都可以把它指定为private,以确保不会在包内的其他地方误用到它，于是也就防止了你会去改变或删除这个方法。将方法指定为private确保了你拥有这种选择权。</p><p>这对于类中的private域同样适用。除非必须公开底层实现细目(此种境况很少见)，否则就应该将所有的域指定为private。<strong>然而，不能因为在类中某个对象的引用是private,就认为其他的对象无法拥有该对象的public引用</strong>。</p><h3 id="6-2-4-protected-继承访问权限"><a href="#6-2-4-protected-继承访问权限" class="headerlink" title="6.2.4 protected: 继承访问权限"></a>6.2.4 protected: 继承访问权限</h3><p>关键字protected处理的是继承的概念，通过继承可以利用一个现有类，我们将其称为基类（父类），然后将新成员添加到该现有类中而不必碰该现有类。还可以改变该类的现有成员的行为。</p><p>为了从现有类中继承，需要声明新类extends (扩展)了一 个现有类，就像这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">extends</span> <span class="title class_">Bar</span> &#123;</span><br></pre></td></tr></table></figure><p>类定义中的其他部分看起来都是一样的。</p><p>如果创建了一个新包，并自另一个包中继承类，那么唯一可以访问的成员就是源包的public成员。(当然，如果在同一个包内执行继承工作，就可以操纵所有的拥有包访向权限的成员。)</p><p>有时，基类的创建者会希望有某个特定成员，把对它的访问权限赋予派生类而不是所有类。这就需要protected来完成这一工作。 protected 也提供包访问权限，也就是说，相同包内的其他类可以访问protected元素。</p><p>回顾一下先前的例子Cookie.java,就可以得知下面的类是不可以调用拥有包访问权限的成员bite()的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access.dessert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChocolateChip</span> <span class="keyword">extends</span> <span class="title class_">Cookie</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ChocolateChip</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ChocolateChip constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chomp</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//! bite();</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ChocolateChip</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChocolateChip</span>();</span><br><span class="line">        x. chomp() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关继承技术的一个很有趣的事情是，如果类Cookie中存在一个方法bite()的话， 那么该方法同时也存在于任何一个从Cookie继承而来的类中。但是由于bite()有包访向权限而且它位于另一个包内，所以我们在这个包内是无法使用它的。</p><p>当然，也可以把它指定为public,但是这样做所有的人就都有了访问权限，而且很可能这并不是你所希望的。如果我们将类Cookie像这样加以更改: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> access.cookie2;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cookie</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cookie construcrot&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">bite</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bite&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在对于所有继承自Cookie的类而言，bite()都是可用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access.cookie2.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class ChocolateChip2 <span class="keyword">extends</span> <span class="title class_">Cookie</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ChocolateChip2</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ChocolateChip2 constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chomp</span><span class="params">()</span>&#123;</span><br><span class="line">        bite();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ChocolateChip2</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChocolateChip2</span>();</span><br><span class="line">        x.chomp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里尽管bite()也具有包访问权限但是他仍旧不是public的。</p><h2 id="6-3-接口和实现"><a href="#6-3-接口和实现" class="headerlink" title="6.3 接口和实现"></a>6.3 接口和实现</h2><p>访问权限的控制常被称为是具体实现的隐藏。</p><p>把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是封装。其结果是一个同时带有特征和行为的数据类型。</p><p>出于两个很重要的原因，访问权限控制将权限的边界划在了数据类型的内部。</p><ol><li>要设定客户端程序员可以使用和不可以使用的界限。可以在结构中建立自己的内部机制，而<br>不必担心客户端程序员会偶然地将内部机制当作是他们可以使用的接口的一部分。这个原因直接引出了第二个原因。</li><li>即将接口和具体实现进行分离。如果结构是用于一组程序之中，而客户端程序员除了可以向接口发送信息之外什么也不可以做的话，那么就可以随意更改所有不是public的东西( 例如有包访问权限、protected 和private的成员)，而不会破坏客户端代码。</li></ol><p>为了清楚起见，可能会采用一种将public成员置于开头，后面跟着protected.包访问权限和private成员的创建类的形式。这样做的好处是类的使用者可以从头读起，首先阅读对他们而言最为重要的部分(即public成员， 因为可以从文件外部调用它们)，等到遇见作为内部实现细节的非public成员时停止阅读:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class OrganizedByAccess &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pub1</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pub2</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pub3</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">priv1</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">priv2</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> vo1d <span class="title function_">priv3</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做仅能使程序阅读起来稍微容易一些，因为接口和具体实现仍旧混在一起。也就是说，仍能看到源代码的实现部分，因为它就在类中。另外，javadoc所提供的注释文档功能降低了程序代码的可读性对客户端程序员的重要性。将接口展现给某个类的使用者实际上是类浏览器的任务。</p><p>类浏览器是一种以非常有用的方式来查阅所有可用的类，并告诉你用它们可以做些什么(也就是显示出可用成员)的工具。在Java中，用Web浏览器浏览JDK文档可以得到使用类浏览器的相同效果。</p><h2 id="6-4-类的访问权限"><a href="#6-4-类的访问权限" class="headerlink" title="6.4 类的访问权限"></a>6.4 类的访问权限</h2><p>在Java中，访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。如果希望某个类可以为某个客户端程序员所用，就可以通过把关键字public作用于整个类的定义来达到目的。这样做甚至可以控制客户端程序员是否能创建一个该类的对象。</p><p>为了控制某个类的访问权限，修饰词必须出现于关键字class之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br></pre></td></tr></table></figure><p>现在如果库的名字是access，那么任何客户端程序员都可以通过下面的声明访问Widget</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access .Widget;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">import</span> access.*;</span><br></pre></td></tr></table></figure><p>然而，这里还有一些额外的限制:</p><ol><li>每个编译单元(文件)都只能有一个public类。这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出出错信息。</li><li>public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。所以对于Widget而言，文件的名称必须是Widget.java，而不是widget.java或WIDGET.java。如果不匹配，同样将得到编译时错误。</li><li>虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。(尽管随意命名会使得人们在阅读和维护代码时产生混淆。)</li></ol><p>如果获取了一个在access内部的类，用来完成Widget或是其他在access中的public类所要执行的任务，将会出现什么样的情况呢?你不想自找麻烦去为客户端程序员创建说明文档，而且你认为不久可能会想要完全改变原有方案并将旧版本一起删除，代之以一种不同的版本。为了保留此灵活性，需要确保客户端程序员不会依赖于隐藏在access之中的任何特定实现细节。为了达到这一点，只需将关键字public从类中拿掉，这个类就拥有了包访问权限。(该类只可以用于该包之中。)</p><p>在创建一个包访问权限的类时，仍旧是在将该类的域声明为private时才有意义，应尽可能地总是将域指定为私有的，但是通常来说，将与类(包访问权限)相同的访问权限赋予方法也是很合理的。</p><p>既然一个有包访问权限的类通常只能被用于包内，那么如果对你有强制要求，在此种情况下，编译器会告诉你，你只需要将这样的类的方法设定为public就可以了。</p><p>请注意，类既不可以是private的(这样会使得除该类之外，其他任何类都不可以访向它)，也不可以是protected的。所以对于类的访问权限，仅有两个选择:包访问权限或public。 </p><p>如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而阻止任何人<br>创建该类的对象，但是有一个例外，就是你在该类的static成员内部可以创建。</p><p>如果我们把构造器定义为private，那就谁也无法创建这个类型的对象。这种情况下还是有方法使用这两个类。</p><p>在Soup1中创建一个static方法，创建一个新的Soup1对象并返回一个对它的引用。这样如果想在返回引用之前做一些额外的工作，或者是记录创建了多少个Soup1对象都可以。</p><p>Soup2用到了所谓的设计模式，这种模式被称之为singleton（单例），这是因为你始终只能创建它的一个对象。Soup2类的对象是作为Soup2的一个static private成员而创建的，所以有且只有一个，除非是通过public方法access()，否则无法访问到。</p><p>之前提到过，如果没有为类访问权限指定一个修饰符，那么会默认得到包访问权限，意味着该类的对象可以由包内任何其他类来创建，而包外是不行的。如果某个static成员是public的话，客户端程序员仍然可以调用这个static成员，尽管他们并不能生成该类的对象。</p><h2 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h2><p>无论什么关系，为各成员创建需要遵守的界限是很重要的。当创建了类库之后，也就与该类库的用户建立了某种关系。客户端程序员会用你的类库聚合成一个应用程序或者创建更大的类库。</p><p>如果不指定规则，客户端程序员就可以对类的所有成员为所欲为。</p><p>控制对成员的访问权限有两个原因。</p><ul><li>第一是为了使用户不要碰触那些他们不该碰触的部分，这些部分对于类内部的操作是必要的，但是它并不属于客户端程序员所需接口的一部分。 因此，将方法和域指定成private，对客户端程序员而言是一种服务。 因为这样他们可以很清楚地看到什么对他们重要，什么是他们可以忽略的。这样简化了他们对类的理解。</li><li>第二个原因，也是最重要的原因，是为了让类库设计者可以更改类的内部工作方式，而不必担心这样会对客户端程序员产生重大的影响。例如，最初可能会以某种方式创建一个类，然后发现如果更改程序结构，可以大大提高运行速度。如果接口和实现可以被明确地隔离和加以保护，那么就可以实现这一目的，而不必强制客户端程序员重新编写代码。访问权限控制可以确保不会有任何客户端程序员依赖于某个类的底层实现的任何部分。</li></ul><p>类的公共接口是用户真正能够看到的，所以这一部分是在分析和设计的过程中决定该类是否正确的最重要的部分。</p><p>尽管如此，你仍然有进行改变的空间。如果在最初无法创建出正确的接口，那么只要不删除任何客户端程序员在他们的程序中已经用到的东西,就可以在以后添加更多的方法。</p><p>注意，访问权限控制专注于类库创建者和该类库的外部使用者之间的关系，这种关系也是一种通信方式。 然而，在许多情况下事情并非如此。例如，你自己编写了所有的代码，或者你在一个组员聚集在一起的项目组中工作，所有的东西都放在同一个包中。这些情况是另外一种不同的通信方式，因此严格地遵循访问权限规则并不一定是最佳选择，默认(包)访问权限也许只是可行而已。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;6-访问控制权限&quot;&gt;&lt;a href=&quot;#6-访问控制权限&quot; class=&quot;headerlink&quot; title=&quot;6. 访问控制权限&quot;&gt;&lt;/a&gt;6. 访问控制权限&lt;/h1&gt;&lt;p&gt;访问控制(或隐藏具体实现)与“最初的实现并不恰当“有关。&lt;/p&gt;</summary>
    
    
    
    <category term="hwcd" scheme="https://www.szjm.online/categories/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/categories/hwcd/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="hwcd" scheme="https://www.szjm.online/tags/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/tags/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>初始化与清理</title>
    <link href="https://www.szjm.online/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
    <id>https://www.szjm.online/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</id>
    <published>2022-08-26T10:00:02.000Z</published>
    <updated>2022-08-29T02:43:50.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-初始化与清理"><a href="#5-初始化与清理" class="headerlink" title="5. 初始化与清理"></a>5. 初始化与清理</h1><p>随着计算机革命的发展，“不安全” 的编程方式已逐渐成为编程代价高昂的主因之一。<span id="more"></span></p><p>初始化和清理是两个涉及安全的问题，不初始化会让字段的值不受控制，不清理会占用内存</p><p>C++引入了构造器，在创建对象的时候调用。</p><p>Java也采用了构造器，并且额外提供了垃圾回收器来释放内存资源</p><h2 id="5-1-用构造器确保初始化"><a href="#5-1-用构造器确保初始化" class="headerlink" title="5.1 用构造器确保初始化"></a>5.1 用构造器确保初始化</h2><p>假想每个类都有一个initialize()方法，在使用对象之前，应该先调用这个方法。</p><p>在Java中，构造器会自动调用这个方法进行初始化。</p><p>如何命名这个方法？这个方法可能会和类里成员的名称冲突，怎么让编译器知道应该调用哪个方法。</p><p>Java中构造器和类使用相同的名称，因为在初始化期间要自动调用构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleConsrructor</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Rock</span>&#123;</span><br><span class="line">        Rock()&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Rock &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Rock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_1_1输出结果.png" alt="5_1_1输出结果"><p>在new的时候，会为对象分配空间，并调用响应的构造器，确保在操作对象之前，已经被初始化了。</p><p>因为构造器的名称必须和类名完全相同，所以“每个方法首字母小写”的编码风格不适用于构造器。</p><p>不接受任何参数的构造器叫<code>默认构造器</code>，Java文档通常叫<code>无参构造器</code>，当然构造器也可以有参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Rock2</span>&#123;</span><br><span class="line">    Rock2(<span class="type">int</span> i)&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Rock &quot;</span> + i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Rock2</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_1_2输出结果.png" alt="5_1_2输出结果"><p>如果Rock2(int)是Rock2中惟一的构造器，那么Java将不会允许你使用其他任何方式创建Java对象。</p><p>概念上，初始化和构建是独立的，但是代码中，初始化和构建是一体的，因为没有对initialize方法的明确调用。</p><p>构造器是特殊类型的方法，没有返回值。不同于void的空返回值，构造器是不能返回，没有其他选择。</p><h2 id="5-2-方法重载"><a href="#5-2-方法重载" class="headerlink" title="5.2 方法重载"></a>5.2 方法重载</h2><p>重要特性，对名字的运用。创建对象的时候，会给对象分配的空间取个名字，方法时给某个动作取的名字。用名字可以引用所有的对象和方法。名字起得好，易于理解。</p><p>既然构造器的名字已经由类名所决定的，就只能有一个构造器名。那如果想用多种方式创建一个对象怎么做？</p><p>有时既想对类初始化，也想从文件里读取信息来初始化，这就需要两个构造器，一个无参构造器，一个有参构造。</p><p>由于都是构造器，他们必须都用类名做名字，为了让两个构造器同时存在，必须要用到方法重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    Tree()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;种下种子&quot;</span>);</span><br><span class="line">        height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree(<span class="type">int</span> initialHeight)&#123;</span><br><span class="line">        height = initialHeight;</span><br><span class="line">        System.out.println(<span class="string">&quot;创造一颗高度为&quot;</span> + height + <span class="string">&quot;的新树&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;树有&quot;</span> + height + <span class="string">&quot;米高&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s + <span class="string">&quot;树有&quot;</span> + height + <span class="string">&quot;米高&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overloading</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="type">Tree</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tree</span>(i);</span><br><span class="line">            t.info();</span><br><span class="line">            t.info(<span class="string">&quot;重载  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Tree</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_2_1输出结果.png" alt="5_2_1输出结果"><p>for循环里的new Tree(i)和外面的new Tree()其实不是一个东西，他们的输出都不一样</p><p>同样t.info()和t.info(“重载  “)走的也不是一个东西</p><h3 id="5-2-1-区分重载方法"><a href="#5-2-1-区分重载方法" class="headerlink" title="5.2.1 区分重载方法"></a>5.2.1 区分重载方法</h3><p>要是好几个方法都有相同的名字，Java怎么知道是哪一个呢？</p><p>每一个重载的方法都有一个独一无二的参数列表，参数顺序的不同也能区分（但是不建议这么做，会使代码难以维护）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverladongOrder</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(String s, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;String: &quot;</span> + s + <span class="string">&quot;, int: &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int: &quot;</span> + i + <span class="string">&quot;, String: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="string">&quot;String first&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        f(<span class="number">2</span>, <span class="string">&quot;Int first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_2_1_1输出结果.png" alt="5_2_1_1输出结果"><h3 id="5-2-2-涉及基本类型的重载"><a href="#5-2-2-涉及基本类型的重载" class="headerlink" title="5.2.2 涉及基本类型的重载"></a>5.2.2 涉及基本类型的重载</h3><p>基本类型能从较小的类型自动提升为较大的类型，但是如果这个过程牵涉到重载，就可能会造成一些问题。</p><ul><li>如果某个重载方法接收int型参数，就会被调用。</li><li>如果传入的参数类型小于方法中声明的参数类型，传入的类型就会被提升。</li><li>如果无法找到恰好接收char参数的方法，就会把char提升至int型。</li></ul><p>如果传入的参数大于声明的参数，就得需要自己执行窄化转换。</p><h3 id="5-2-3-以返回值区分重载方法"><a href="#5-2-3-以返回值区分重载方法" class="headerlink" title="5.2.3 以返回值区分重载方法"></a>5.2.3 以返回值区分重载方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><p>虽然说对于你来说这两个很好区分，但是当你用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br></pre></td></tr></table></figure><p>来调用的时候，你怎么知道自己调用的是哪一个，java又怎么知道你调用的是哪一个呢？</p><p>不能用返回值来区分重载方法</p><h2 id="5-3-默认构造器（无参构造器）"><a href="#5-3-默认构造器（无参构造器）" class="headerlink" title="5.3 默认构造器（无参构造器）"></a>5.3 默认构造器（无参构造器）</h2><p>默认构造器是没有形式参数的，它的作用是创建一个默认对象。</p><p>如果你写的类没有构造器，编译器就会自动帮你创建一个默认构造器。</p><p>但是如果你已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建那个无参构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird2</span>()&#123;</span><br><span class="line">    Bird2(<span class="type">int</span> i)&#123;&#125;</span><br><span class="line">    Bird2(<span class="type">double</span> d)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoSynthesis</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//Bird2 b1 = new Bird2();</span></span><br><span class="line"><span class="type">Bird2</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird2</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Bird2</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird2</span>(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了构造器，Java就不会帮忙创建Bird2()这个无参构造，你就无法使用。</p><h2 id="5-4-this关键字"><a href="#5-4-this关键字" class="headerlink" title="5.4 this关键字"></a>5.4 this关键字</h2><p>如果有同意类型的两个对象a和b，怎么才能让这两个对象都能调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">peel</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;BananaPeel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BananaPeel</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Banana</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Banana</span>();</span><br><span class="line">        <span class="type">Banana</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Banana</span>();</span><br><span class="line">a.peel(<span class="number">1</span>);</span><br><span class="line">        b.peel(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译器内部，他们可能是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Banana.peel(a, <span class="number">1</span>);</span><br><span class="line">Banana.peel(b, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>但是我们的代码不能这么写。</p><p>如果希望在方法的内部获得对当前对象的引用怎么做？因为这个引用是编译器的引用，没有标识符可用。</p><p>但是，有个关键字<code>this</code>。this只能在方法内部使用，表示对“调用方法的那个对象”的引用。</p><p>如果在同一个类中调用另一个方法，就不必使用this。</p><p>只有当需要明确指出对当前对象的引用时，才需要使用this关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Leaf <span class="title function_">increment</span><span class="params">()</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i= &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Leaf</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line">        x.increment().increment().increment().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_4_1输出结果.png" alt="5_4_1输出结果"><p>由于increment()通过this关键字返回了对当前对象的引用，所以很容易在一条语句里对同一个对象执行多次操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Apple apple)</span>&#123;</span><br><span class="line">        <span class="type">Apple</span> <span class="variable">peeled</span> <span class="operator">=</span> apple.getPeeled();</span><br><span class="line">        System.out.println(<span class="string">&quot;好吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Peeler</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Apple <span class="title function_">peel</span><span class="params">(Apple apple)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;剥皮&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>&#123;</span><br><span class="line">    Apple <span class="title function_">getPeeled</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Peeler.peel(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassingThis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>().eat(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_4_2输出结果.png" alt="5_4_2输出结果"><p>Apple需要调用Peeler.peel()方法，它是一个外部的工具方法，将执行由于某种原因而必须放在Apple外部的操作(也许是因为该外部方法要应用于许多不同的类,而你却不想重复这些代码)。为了将其自身传递给外部方法，Apple必须使用this关键字。</p><h3 id="5-4-1-在构造器中调用构造器"><a href="#5-4-1-在构造器中调用构造器" class="headerlink" title="5.4.1 在构造器中调用构造器"></a>5.4.1 在构造器中调用构造器</h3><p>可能为一一个类写了多个构造器，有时可能想在-一个构造器中调用另一个构造器，以避免重复代码。可用this关键字做到这一点。</p><p>通常写this的时候，都是指‘“这个对象” 或者“ 当前对象”，而且它本身表示对当前对象的引用。在构造器中，如果为this添加了参数列表，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确调用：这样，调用其他构造器就有了直接的途径:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Flower</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">petalCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line">    Flower(<span class="type">int</span> petals) &#123;</span><br><span class="line">        petalCount = petals;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor w/ int arg only, petalCount= &quot;</span> + petalCount);</span><br><span class="line">    &#125;</span><br><span class="line">    Flower(String ss) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor w/ String arg only, s=&quot;</span> + ss);</span><br><span class="line">        s = ss;</span><br><span class="line">    &#125;</span><br><span class="line">    Flower(String s, <span class="type">int</span> petals) &#123;</span><br><span class="line">        <span class="built_in">this</span>(petals);</span><br><span class="line">        <span class="built_in">this</span>.s = s; <span class="comment">// Another use of &quot;this&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;String &amp; int args&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Flower() &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;default constructor (no args)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printPetalCount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;petalCount = &quot;</span> + petalCount + <span class="string">&quot; s = &quot;</span>+ s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Flower</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Flower</span>();</span><br><span class="line">        x.printPetalCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main里new了无参的flower，无参的flower用this调用了同一个类里的另一个有两个参数的flower，两参flower故技重施this调用另一个数字参数flower，并且用this做区分，把自己的形参s赋值给了flower.s，数字参数的flower因为形参名称和flower的名称不一样，就没有再用this做区分。</p><p>尽管可以使用this调用另一个构造器，但是不能同时调用两个，而且构造器必须在起始处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    Flower(String s, <span class="type">int</span> petals) &#123;</span><br><span class="line">        <span class="built_in">this</span>(petals);</span><br><span class="line"><span class="comment">//        this(s);</span></span><br><span class="line">        <span class="built_in">this</span>.s = s; <span class="comment">// Another use of &quot;this&quot;</span></span><br><span class="line"><span class="comment">//        this(s);</span></span><br><span class="line"><span class="comment">//        this(petals);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;String &amp; int args&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-2-static的含义"><a href="#5-4-2-static的含义" class="headerlink" title="5.4.2 static的含义"></a>5.4.2 static的含义</h3><p>static方法就是没有this方法。在static方法的内部不能调用非静态方法。反过来倒是可以。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。</p><p>Java禁用全局方法，但是在类里置入static方法就可以访问其他的static方法和static域。</p><p>有些人认为static方法不是“ 面向对象”的，因为它们的确具有全局函数的语义；使用static 方法时，由于不存在this，所以不是通过“向对象发送消息”的方式来完成的。</p><p>要是在代码中出现了大量的static方法，就该重新考虑自己的设计了。</p><p>然而，static的概念有其实用之处，许多时候都要用到它。</p><h2 id="5-5-清理：终结处理和垃圾回收"><a href="#5-5-清理：终结处理和垃圾回收" class="headerlink" title="5.5 清理：终结处理和垃圾回收"></a>5.5 清理：终结处理和垃圾回收</h2><p>我们了解初始化的重要性，不会忘记初始化，但是常常会忘记同样重要的清理工作，</p><p>虽然Java有内存回收机制，但是把一个对象用完之后就弃之不顾的做法不总是安全的，总是有一些特殊情况。</p><p>如果你不是使用new创建的对象，获取了一块“特殊的”内存区域，垃圾回收器只知道释放经过new分配的内存，不知道怎么处理这块特殊的内存。</p><p>为了应对这种情况，Java允许在类中定义一个finalize()方法，工作原理“假定”是这样的：一旦垃圾回收器准备好了释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生的时候，才会真正回收对象占用的内存。要是打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。</p><p>有个陷阱，finalize和C++的析构函数不一样</p><ul><li>在C++中，对象一定会被销毁（如果程序没有缺陷），而Java对象并非总是被销毁</li><li>对象可能不被垃圾回收机制回收</li><li>垃圾回收并不等于“析构”</li></ul><p>Java并未提供“析构函数或者相似的概念，如果需要，得自己手动创建一个普通方法。</p><h3 id="5-5-1-fianlize-的用途何在"><a href="#5-5-1-fianlize-的用途何在" class="headerlink" title="5.5.1 fianlize()的用途何在"></a>5.5.1 fianlize()的用途何在</h3><p>要记住垃圾回收只与内存有关。</p><p>无论对象是如何创建的，垃圾回收机制都会负责释放对象占据的所有内存。这就对fianlize进行限制，通过某种创建对象的方式以外的方式为对象分配了空间。</p><p>在Java中，一切皆为对象，这种特殊情况不太正常。</p><p>之所以有finalize，是在分配内存时可能采用了类似C的做法，而不是Java的通常做法。</p><p>Java可以调用其他语言的代码，也会会调用C的malloc来分配存储空间，而且除非调用了free函数，否则本地空间不会被释放，从而造成内存泄露。</p><p>尽然finalize不能过多的使用，他不是普通的清理工作的合适场所，那么普通的清理工作应该在哪里？</p><h3 id="5-5-2-你必须实施清理"><a href="#5-5-2-你必须实施清理" class="headerlink" title="5.5.2 你必须实施清理"></a>5.5.2 你必须实施清理</h3><p>要清理一个对象，必须在需要清理的时刻调用执行清理动作的方法。</p><p>在Java中，不允许创建局部对象，必须使用new创建对象，在花括号的右边界对象会被自动清理。</p><p>但是无论是<code>垃圾回收</code>还是<code>终结</code>，都不保证一定会终结。在jvm内存没有即将耗尽之前，是不会浪费时间去执行垃圾回收来恢复内存的。</p><h3 id="5-5-3-终结条件"><a href="#5-5-3-终结条件" class="headerlink" title="5.5.3 终结条件"></a>5.5.3 终结条件</h3><p>很多时候不能使用finalize，必须用其他的清理方法，并且明确的进行调用。</p><p>finalize有一个有趣的用法，并不依赖于每次都要对finalize进行调用，这就是对象<code>终结条件</code>的验证。</p><p>当某个对象不再被感兴趣了，他就可以被清理了，这个对象应该处于一种内存可以被安全释放的状态，</p><p>如果对象代表了一个打开的文件，在对象被回收之前应该关闭这个文件，如果没有，程序就会存在缺陷，finalize可以用来发现这种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">checkedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Book (<span class="type">boolean</span> checkOut)&#123;</span><br><span class="line">        checkedOut = checkOut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkIn</span><span class="params">()</span>&#123;</span><br><span class="line">        checkedOut = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkedOut)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error : checked Out&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminationCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">novel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">        novel.checkIn();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="literal">true</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的Book对象在被回收之前都应该被checkin，但是在main方法里，有点疏漏，一本新的书没有被签入，如果没有finalize验证，将很难发现这种缺陷。</p><p><code>System.gc()</code>用来强制进项终结动作。</p><h3 id="5-5-4-垃圾回收器如何工作"><a href="#5-5-4-垃圾回收器如何工作" class="headerlink" title="5.5.4 垃圾回收器如何工作"></a>5.5.4 垃圾回收器如何工作</h3><p>垃圾回收器能显著提高对象的创建速度。</p><p>C++里，堆是一个院子，在Java中，堆更像一个传送带，每分配一个，就往前移动一格。</p><p>Java中，堆也不完全像传送带那样工作（那样会导致频繁的页面调度）。</p><p>垃圾回收器工作的时候，一遍回收空间，一遍使堆中的对象紧凑排列，这样“堆指针”就可以很容易的移动到更靠近传送带的开始处。通过垃圾回收器对对象的重新排列，实现了高速、有无限空间可分配的堆模型。</p><p>先了解其他系统的垃圾回收机制</p><p><code>引用记数</code> 是一种简单但速度很慢的回收技术。</p><p>每个对象都含有一个引用记数器，当有引用连接至对象的时候，引用记数+1，当引用离开作用域或者被置于null时，记数器-1。虽然引用记数开销不大，但是这开销会在整个声明周期中将持续发生。</p><p>垃圾回收器会在全部对象的列表上遍历，当发现某个对象的引用计数器为0的时候，就释放占用的空间（引用记数模式会在记数值变成0时立即释放）。</p><p>但是这样有一个问题，如果对象之间循环引用，就可能会出现“虽然计数器不为0，但是对象应该被回收”的情况。所以引用计数器只是用来说明垃圾收集的工作方式，但是似乎从未被应用于任何一种Java虚拟机中实现。</p><p>还有一种更快的方法，并非基于引用记数，他的思想是，对于任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。这个引用链条可能会穿过数个对象层次，由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是这个对象所包含的所有引用，如此反复，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。</p><p>这里所访问过的对象必须是“活”的，这就解决了对象之间循环引用的问题，这种现象根本不会被发现，因此也就被自动回收了。</p><p>Java虚拟机将采用一种“自适应”的垃圾回收技术，至于如何找到存活的对象取决于不同的jvm。</p><p>有一种<code>停止-复制</code>（stop-and-copy）的做法，这意味着，先暂停程序的运行（所以不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，如果没有被复制的就是垃圾。当对象被复制到新堆时，他们是一个挨着一个的，所以新堆的排列紧凑，就可以简单直接的分配空间了。</p><p>当把对象从一处搬到另一处时，所有指向他的引用都需要修正，在堆和静态存储区的引用可以直接被修正，但是可能还有其他指向这些对象的引用，只有在遍历过程中才能被找到。</p><p>这种所谓的“复制式回收器”，效率会降低，这有两个原因</p><ol><li>空间。需要两个堆，在两个分离的堆里来回复制，需要比实际多一倍的空间。某些Java虚拟机对这种问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。</li><li>复制。程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有的内存都复制，这很浪费。为了避免浪费，一些Java虚拟机会进行检查，要是没有新垃圾，就会转换到另一种“自适应”模式——“标记-清扫”。</li></ol><p>一般情况下“标记-清扫”可能会比较慢，但是当你知道只会产生少量垃圾甚至不会产生垃圾的时候，他的速度就会很快了。</p><p>“标记-清扫”所依据的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当找到一个存活的对象，就会给对象一个标记，过程中不会回收任何对象，只有全部标记完成后，才会开始清理。清理过程中，没有被标记的对象将会被释放，不会复制。所以剩下的堆空间是不连续的，如果想获得连续空间，就得重新整理剩下的对象。</p><p>“停止-复制”的意思是这种垃圾回收动作不是在后台运行的。垃圾回收的同时，程序将会被暂停。当可用内存较低的时候，垃圾回收机制会暂停运行程序。</p><p>jvm中，内存分配以较大的“块”为单位。如果对象较大会占用单独的块。</p><p>“停止-复制”要求在释放旧有对象之前，必须先把所有存活对象从旧堆复制到新堆，会有大量内存复制行为。</p><p>有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝。</p><p>每个块都用相应的代数（generation count）来记录是否存活。如果块在某处被引用，代数会增加。垃圾回收器会对上次回收动作之后新分配的块进行整理，对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作，大型对象仍然不会被复制，只是代数会增加，小型对象的那些块会被复制并整理。</p><p>虚拟机会进行监视，如果对象稳定，垃圾回收器效率低，就会切换到“标记-清扫”模式，如果碎片多，就会切换到“停止-复制”模式。</p><p>Java虚拟机有许多附加技术用以提升速度。</p><p>加载器操作有关的Just-InTime JIT（即时）技术。可以把程序全部或者部分翻译成本地机器码（jvm的操作），程序运行速度会得到提升。当需要装载某个类时（通常是为该类创建第一个对象的时候），编译器会先找到class文件，把字节码装入内存。</p><p>此时，有两种方案可供选择。</p><ul><li>一种是就让即时编译器编译所有代码。但这种做法有两个缺陷:<ul><li>这种加载动作散落在整个程序生命周期内，累加起来要花更多时间</li><li>并且会增加可执行代码的长度(字节码要比即时编译器展开后的本地机器码小很多)，这将导致页面调度，从而降低程序速度。</li></ul></li><li>另一种做法称为惰性评估(lazy evaluation),意思是即时编译器只在必要的时候才编译<br>  代码。这样，从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的Java HotSpot技术就采用了类似方法，代码每次被执行的时候都会做一些优化，所以执行的次数越多，它的速度就越快。</li></ul><h2 id="5-6-成员初始化"><a href="#5-6-成员初始化" class="headerlink" title="5.6 成员初始化"></a>5.6 成员初始化</h2><p>Java尽力保证所有的变量在使用前能得到恰当的初始化，对于方法的局部变量，Java会在编译时报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i++;<span class="comment">//Error -- i not initialized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然Java可以为i赋值一个默认值，但是这可能会让编程人员忽略这一个未初始化的变量。</p><p>如果一个类的字段是基本类型，Java会保证每个基本类型的数据成员都会有初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitialValues</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> t;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">byte</span> b;</span><br><span class="line">    <span class="type">short</span> s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">long</span> l;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    InitialValues reference;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printInitialValues</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Data type    Initial value&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;char         &quot;</span> + c);</span><br><span class="line">        System.out.println(<span class="string">&quot;byte         &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;short        &quot;</span> + s);</span><br><span class="line">        System.out.println(<span class="string">&quot;int          &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;long         &quot;</span> + l);</span><br><span class="line">        System.out.println(<span class="string">&quot;float        &quot;</span> + f);</span><br><span class="line">        System.out.println(<span class="string">&quot;double       &quot;</span> + d);</span><br><span class="line">        System.out.println(<span class="string">&quot;reference    &quot;</span> + reference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InitialValues</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialValues</span>();</span><br><span class="line">        iv.printInitialValues();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        也可以写成</span></span><br><span class="line"><span class="comment">        new InitialValues().printInitialValues();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_6_1输出结果.png" alt="5_6_1输出结果"><p>尽管没有手动初始化，但是他们确实被赋予了初值（char初始值是0，所以显示为空白）。</p><p>如果对象引用没有，就会获得一个特殊值null。</p><h3 id="5-6-1-指定初始化"><a href="#5-6-1-指定初始化" class="headerlink" title="5.6.1 指定初始化"></a>5.6.1 指定初始化</h3><p>如果想对某个变量赋予一个初值，直接在定义的时候复制就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitialValues</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">7894561230L</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.1415926d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类对象也可以这样进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depth</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Measurement</span>&#123;</span><br><span class="line"><span class="type">Depth</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Depth</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有指定初始值就尝试调用，运行中会报异常。</p><p>可以通过调用某个方法来提供初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInit1</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> f();</span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="number">11</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可以带有参数，但是参数必须是已经被初始化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInit2</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> f();</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> g(i);</span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="number">11</span>;&#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="keyword">return</span> n * <span class="number">10</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序的正确性取决于初始化的顺序，而与其编译方式无关。</p><p>所以，编译器恰当地对“向前引用”发出了警告。</p><p>这种初始化方法既简单又直观。但有个限制：类InitialValues的每 个对象都会具有相同的初值。有时，这正是所希望的，但有时却需要更大的灵活性。</p><h2 id="5-7-构造器初始化"><a href="#5-7-构造器初始化" class="headerlink" title="5.7 构造器初始化"></a>5.7 构造器初始化</h2><p>可以用构造器进行初始化，运行时可以调用方法或者执行某些动作来确定初值，能带来很高的灵活性。</p><p>但是你无法阻止自动化的进行，这一步会在构造器被调用之前发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Counter()&#123;<span class="type">int</span> = <span class="number">7</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里i会被置为0，然后编程7。对于所有基本类型和对象引用，包括在定义时已经指定初始值的变量，都是成立的。</p><p>编译器不会强制一定要在构造器的哪里在使用前对元素进行初始化，因为Java会自动初始化。</p><h3 id="5-7-1-初始化顺序"><a href="#5-7-1-初始化顺序" class="headerlink" title="5.7.1 初始化顺序"></a>5.7.1 初始化顺序</h3><p>在类的内部，变量定义的先后顺序决定了初始化的顺序。</p><p>变量定义散布于方法定义之间，但是会在任何方法（包括构造器）被调用前被初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">    Window (<span class="type">int</span> marker)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Window(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">1</span>);</span><br><span class="line">    House() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">        w3 = <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">w2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Window</span> <span class="variable">w3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderOfInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">House</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">        h.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_7_1_1输出结果.png" alt="5_7_1_1输出结果"><p>这里故意打乱了house类里window对象的定义，但是我们可以从输出中看到顺序。</p><p>首先是按先后顺序执行了window字段的初始化，然后执行了无参构造house方法的运行，在house方法里，是按照顺序进行的，先执行了输出语句，才又执行了window（33），最后，执行了main方法中要求的f()方法。</p><h3 id="5-7-2-静态数据的初始化"><a href="#5-7-2-静态数据的初始化" class="headerlink" title="5.7.2 静态数据的初始化"></a>5.7.2 静态数据的初始化</h3><p>无论创建多少个对象，静态数据都只占用了一份存储区域。</p><p>static关键字不能用于局部变量，只用作用于域。</p><p>如果域是静态基本类型域，而且没有被初始化，就会获得基本类型的默认值。</p><p>如果是一个对象引用，就会获得默认值null。</p><p>如果想在定义处进行初始化，采取的方法与非静态数据没有不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bowl</span>&#123;</span><br><span class="line">    Bowl(<span class="type">int</span> marker)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bowl(&quot;</span> + marker +<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> marker)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">1</span>);</span><br><span class="line">    Table()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">        bowl2.f1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> marker)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cupboard</span>&#123;</span><br><span class="line">    <span class="type">Bowl</span> <span class="variable">bowl3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">4</span>);</span><br><span class="line">    Cupboard()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">        bowl4.f1(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> marker)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bowl</span> <span class="variable">bowl5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bowl</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating new Cupboard() in main&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">        table.f2(<span class="number">1</span>);</span><br><span class="line">        cupboard.f3(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Table</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Cupboard</span> <span class="variable">cupboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cupboard</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_7_2_1输出结果.png" alt="5_7_2_1输出结果"><p>静态初始化只有在必要时刻才会进行。如果不创建table对象，也不引用table.b1和table.b2，那么静态的bowl b1和b2永远不会被创建。只有在第一个table对象被创建（或者第一次访问静态数据）的时候，才会被初始化。<strong>此后，静态对象不会被再次初始化。</strong></p><p>初始化顺序是先静态对象，然后是非静态对象。（还是不要忘记先字段再方法）</p><p>假设有个名为Dog的类：</p><ol><li>即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时(构造器可以看成静态方法)，或者Dog类的静态方法&#x2F;静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。</li><li>然后载入Dogclass (后面会学到，这将创建一个Class对象)，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。</li><li>当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。</li><li>这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值(对数字来说就是0,对布尔型和字符型也相同)，而引用则被设置成了null。</li><li>执行所有出现于字段定义处的初始化动作。</li><li>执行构造器。正如将在第7章所看到的，这可能会牵涉到很多动作，尤其是涉及继承的<br>时候。</li></ol><h3 id="5-7-3-显式的静态初始化"><a href="#5-7-3-显式的静态初始化" class="headerlink" title="5.7.3 显式的静态初始化"></a>5.7.3 显式的静态初始化</h3><p>Java允许将多个静态初始化动作组织成一个特殊的“静态子句”(有时也叫做“静态块”)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spoon</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管看起来像个方法，单实际上只是在static关键字后面的代码，和其他静态初始化一样只执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cup</span>&#123;</span><br><span class="line">    Cup(<span class="type">int</span> marker)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cup(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> marker)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cups</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Cup cup1;</span><br><span class="line">    <span class="keyword">static</span> Cup cup2;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cup1 = <span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">1</span>);</span><br><span class="line">        cup2 = <span class="keyword">new</span> <span class="title class_">Cup</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Cups()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cups()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExplicitStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        Cups.cup1.f(<span class="number">99</span>);<span class="comment">//(1)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    static Cups cups1 = new Cups();//(2)</span></span><br><span class="line"><span class="comment">//    static Cups cups2 = new Cups();//(2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_7_3_1输出结果.png" alt="5_7_3_1输出结果"><p>只有new这个类，他构造器才会执行，像这里只是使用了这个类里的其他方法，只会执行static的操作。</p><p>无论是通过标为(1)的那行代码访问静态的cup1对象，还是把标为(1)的行注释掉，让它去运行<br>标为(2)的那行代码(即解除标为(2)的行的注释)，Cups的静态初始化动作都会得到执行。如果把标为(1)和(2)的行同时注释掉，Cups的静态初始化动作就不会进行，就像在输出中看到的那样。此外，激活一行还是两行标为(2)的代码(即解除注释)都无关紧要,静态初始化动作只进行一次。</p><h3 id="5-7-4-非静态实例初始化"><a href="#5-7-4-非静态实例初始化" class="headerlink" title="5.7.4 非静态实例初始化"></a>5.7.4 非静态实例初始化</h3><p>Java中有实例初始化的类似语法，用来初始化每一个对象的非静态变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mug</span>&#123;</span><br><span class="line">    Mug(<span class="type">int</span> marker)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mug(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> marker)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mugs</span> &#123;</span><br><span class="line">    Mug mug1;</span><br><span class="line">    Mug mug2;</span><br><span class="line">    &#123;</span><br><span class="line">        mug1 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">1</span>);</span><br><span class="line">        mug2 = <span class="keyword">new</span> <span class="title class_">Mug</span>(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mug1 &amp; mug2 initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Mugs()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Mugs(<span class="type">int</span> i)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mugs</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs() completed&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Mugs</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs(1) completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_7_4_1输出结果.png" alt="5_7_4_1输出结果"><p>看起来与静态初始化一模一样，只不过少了static关键字。</p><h2 id="5-8-数组初始化"><a href="#5-8-数组初始化" class="headerlink" title="5.8 数组初始化"></a>5.8 数组初始化</h2><p>数组只是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。<br>数组是通过方括号下标操作符[ ]来定义和使用的。</p><p>要定义一个数组，只需在类型名后加上一对空方括号即可，方括号在前还是在后是随意的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a1;</span><br><span class="line"><span class="type">int</span> a1[];</span><br></pre></td></tr></table></figure><p>两个格式的含义是一样的，不过前一种格式更合理，它表明的类型是“一个int数组”。</p><p>编译器不允许指定数组的大小，这就把问题又带回了“引用”相关的问题。</p><p>在数组没有被定义的时候，拥有的只是对数组的一个引用，对于这个引用已经分配了足够的空间，但是对于这个数组对象本身，没有分配任何空间。</p><p>要给数组创建相应的存储空间，要写初始化表达式。数组的初始化可以在代码的任何地方。</p><p>另一种用花括号的特殊初始化方式，必须在创建数组的地方出现。在这种情况下，存储空间的分配类似于使用new，将由编译器负责。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>为什么可以在没有数组的时候定义一个数组引用？作用是可以进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a2;</span><br><span class="line">a2 = a1;</span><br></pre></td></tr></table></figure><p>这样复制了一个引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrysOfPrimitives</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] a2;</span><br><span class="line">        a2 = a1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a2.length; i++) &#123;</span><br><span class="line">            a2[i] = a2[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a1.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a1[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + a1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_8_1输出结果.png" alt="5_8_1输出结果"><p>这里只给了a1初始化，没有对a2初始化，而是在后面对a2进行了赋值。</p><p>这里a1a2其实是对于一个相同数组的引用，所以第一个循环中对于a2的修改，在第二个循环中可以在a1中体现。</p><p>所有的数组类型（无论是什么元素的数组），都有一个固有方法length，可以通过这个方法获知数组包含了多少元素。</p><p>但是Java数组记数是从第0个元素开始的，所以最大下标数是length-1，不同于C和C++允许访问所有内存会出bug，Java在下标越界的时候会抛出异常，停止程序的运行。</p><p>如果不能确定数组里需要多少元素，可以用new在数组里创建元素，尽管创建的是基本类型数组，但是new可以工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        System.out.println(<span class="string">&quot;length of a = &quot;</span> + a.length);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_8_2输出结果.png" alt="5_8_2输出结果"><p>虽然数组的大小是通过Random.nextInt()方法随机实现的，但是能运行。</p><p>定义了长度但是没有初始化赋值的数组，元素的基本数据类型的值会自动初始化或者为空。</p><p>Arrays.toString()是java.util的标准类库，能产生一维数组可打印的版本。</p><p>如果创建了一个非基本类型的数组，就创建了一个引用数组。</p><p>用Integer举例，这是一个类而不是一个基本类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayClassObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">12</span>);</span><br><span class="line">        Integer[] a = <span class="keyword">new</span> <span class="title class_">Integer</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        System.out.println(<span class="string">&quot;length of a = &quot;</span> + a.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = rand.nextInt(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_8_3输出结果.png" alt="5_8_3输出结果"><p>在使用new创建对象的时候，还只是一个引用数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> <span class="title class_">Integer</span>[rand.nextInt(<span class="number">20</span>)];</span><br></pre></td></tr></table></figure><p>直到通过创建新的Interger对象，并把对象赋值给引用的时候，初始化才算结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = rand.nextInt(<span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>也可以用花括号括起来的列表来初始化对象数组，有两种形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayInit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>),</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        Integer[] b = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>),</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));<span class="comment">//[1, 2, 3]</span></span><br><span class="line">        System.out.println(Arrays.toString(b));<span class="comment">//[1, 2, 3]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方式可以在任何地方被调用，甚至是在方法调用的内部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Other.main(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;fiddle&quot;</span>, <span class="string">&quot;de&quot;</span>, <span class="string">&quot;dum&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : args)&#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-8-1-可变参数列表"><a href="#5-8-1-可变参数列表" class="headerlink" title="5.8.1 可变参数列表"></a>5.8.1 可变参数列表</h3><p>上面提到的方法可以获得一种可变参数列表的效果，可以应用于参数个数或者类型未知的场合。</p><p>由于所有的类都直接或者间接继承与Object类，所以也可以创建以Object数组为参数的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarArgs</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Object[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : args)&#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">47</span>), <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">3.14</span>), <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">3.1415926</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_8_1_1输出结果.png" alt="5_8_1_1输出结果"><p>标准Java库中的类能输出有意义的内容，但这里建立的类的对象，打印出的内容只是类的名称以及后面紧跟着的一个@符号以及多个十六进制数字。于是，默认行为(如果没有定义toString()方法的话)就是打印类的名字和对象的地址。</p><p>在Java SE5之后，可以定义可变参数列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewVarArgs</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Object... args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : args)&#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">47</span>), <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">3.14</span>), <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">3.1415926</span>));</span><br><span class="line">        printArray(<span class="number">47</span>, <span class="number">3.14</span>, <span class="number">3.1415926</span>);</span><br><span class="line">        printArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        printArray(<span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>(), <span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">        printArray((Object[]) <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        printArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_8_1_2输出结果.png" alt="5_8_1_2输出结果"><p>有了可变参数，就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你去填充数组。你获取的仍旧是一个数组，这就是为什么print(可以使用foreach来迭代该数组的原因。</p><p>但是，这不仅仅只是从元素列表到数组的自动转换，请注意程序中倒数第二行，一个Integer数组(通过使用自动包装而创建的)被转型为一个Object数组(以便移除编译器警告信息)，并且传递给了printArray()。很明显，编译器会发现它已经是一个数组了，所以不会在其上执行任何转换。因此，如果你有一组事物，可以把它们当作列表传递，而如果你已经有了一个数组，该方法可以把它们当作可变参数列表来接受。</p><p>该程序的最后一行表明将0个参数传递给可变参数列表是可行的，当具有可选的尾随参数时，这一特性就会很有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalTrailingArguments</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> required, String... trailing)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;required: &quot;</span> + required + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : trailing) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        f(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数列表可以使用任何类型的参数，包括基本类型。参数也可以是数组，并且如果数组没有任何元素，那么转变的数据尺寸为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C5;</span><br><span class="line"><span class="comment">//5_8_1_3</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VaratgType</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Character... args)</span>&#123;</span><br><span class="line">        System.out.print(args.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot; length &quot;</span> + args.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span>... args)</span>&#123;</span><br><span class="line">        System.out.print(args.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot; length &quot;</span> + args.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f();</span><br><span class="line">        g(<span class="number">1</span>);</span><br><span class="line">        g();</span><br><span class="line">        System.out.println(<span class="string">&quot;int[]: &quot;</span> + <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>].getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_8_1_3输出结果.png" alt="5_8_1_3输出结果"><p>getClass()，方法属于Object的一部分。<code>[</code>表示这是一个后面紧随的类型的数组，紧随的<code>I</code>表示基本类型int。</p><p>最后一行的int数组类型打印，验证了使用可变参数列表不依赖自动包装机制，实际上使用的是标准类型。</p><p>可变参数列表与自动包装机制可以和谐相处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C5;</span><br><span class="line"><span class="comment">//5_8_1_4</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoboxingVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Integer... args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : args)&#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>),<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">        f(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        f(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">11</span>), <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_8_1_4输出结果.png" alt="5_8_1_4输出结果"><p>单一参数列表可以将类型混合到一起，自动包装机制将有选择的讲int参数提升为Integer</p><p>可变参数列表使得重载过程变得复杂，看起来会显得安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C5;</span><br><span class="line"><span class="comment">//5_8_1_5</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadingVarargs</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Character... args)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Character c : args)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Integer... args)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : args)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Long... args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        f(<span class="number">1</span>);</span><br><span class="line">        f(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">        f(<span class="number">0L</span>);</span><br><span class="line"><span class="comment">//        f();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种情况编译器都会使用自动包装机制来匹配重载的方法，然后调用最匹配的方法。</p><p>这里就不能传空参数过来了，因为没有参数，编译器不能区分到底改使用哪个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C5;</span><br><span class="line"><span class="comment">//5_8_1_6</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadingVarargs2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">float</span> i, Character... args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Character... args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="number">1</span> , <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span> , <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThinkingInJava\src\com\C5\OverloadingVarargs2.java:13:9</span><br><span class="line">java: 对f的引用不明确</span><br><span class="line">  com.C5.OverloadingVarargs2 中的方法 f(float,java.lang.Character...) 和 com.C5.OverloadingVarargs2 中的方法 f(java.lang.Character...) 都匹配</span><br></pre></td></tr></table></figure><p>如果对两个方法都加上一个非可变参数，就能解决问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C5;</span><br><span class="line"><span class="comment">//5_8_1_7</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadingVarargs3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">float</span> i, Character... args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span> c, Character... args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="number">1</span> , <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span> , <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议只在重载方法的一个版本上使用可变参数列表，或者根本就不使用。</p><h2 id="5-9-枚举类型"><a href="#5-9-枚举类型" class="headerlink" title="5.9 枚举类型"></a>5.9 枚举类型</h2><p>Java SE5新增小特性，<code>enum</code>关键字，可以很方便的使用群组枚举类型集。</p><p>需要先新建一个枚举类型集，由于枚举类型的实例是常量，所以按照命名管理用大写，如果名称由多个单词组成，用下划线分隔。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Spiciness</span> &#123;</span><br><span class="line">    NOT,MILD,MEDIUM,HOT,FLAMING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使用枚举，需要创建一个该类型的引用，并赋值给实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C5.C9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleEnumUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Spiciness</span> <span class="variable">howHot</span> <span class="operator">=</span> Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);<span class="comment">//MEDIUM</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建enum时，编译器会自动添加一些特性，比如会创建toString()方法方便显示某个enum实例的名字；ordinal()方法表示特定enum常量的声明顺序；static values()方法，按照enum声明顺序，产生这些常量值构成的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C5.C9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Spiciness s : Spiciness.values())&#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;, ordinal &quot;</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_9_3输出结果.png" alt="5_9_3输出结果"><p>enum看起来像是新的数据类型，但是这个关键字只是为enum生成对应的类的时候产生了某些编译器行为，因此在很大程度上，可以将enum当做任何类来处理，事实上enum确实是有自己方法的类。</p><p>enum在Switch语句中有一些特别的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C5.C9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Burrito</span> &#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Burrito</span><span class="params">(Spiciness degree)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span> (degree)&#123;</span><br><span class="line">            <span class="keyword">case</span> NOT:</span><br><span class="line">                System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MILD:</span><br><span class="line">            <span class="keyword">case</span> MEDIUM:</span><br><span class="line">                System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">            <span class="keyword">case</span> FLAMING:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;maybe too hot.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Burrito</span></span><br><span class="line">            <span class="variable">plain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.NOT),</span><br><span class="line">            greenChile = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.MILD),</span><br><span class="line">            jalapeno = <span class="keyword">new</span> <span class="title class_">Burrito</span>(Spiciness.HOT);</span><br><span class="line">        plain.describe();</span><br><span class="line">        greenChile.describe();</span><br><span class="line">        jalapeno.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/26/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/5.%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/5_9_4输出结果.png" alt="5_9_4输出结果"><p>由于switch是要在有限的可能值集合中进行选择，因此它与enum正是绝佳的组合。请注意enum的名字是如何能够倍加清楚地表明程序要干什么的。</p><p>大体上，你可以将enum用作另外一种创建数据类型的方式，然后直接将所得到的类型拿来使用。这正是关键所在，因此你不必过多地考虑它们。</p><p>在Java SE5引进enum之前，你必须花费大量的精力去保证与其等价的枚举类型是安全可用的。</p><h2 id="5-10-总结"><a href="#5-10-总结" class="headerlink" title="5.10 总结"></a>5.10 总结</h2><p>构造器真的是一个很棒的初始化机制，初始化在Java中有至关重要的地位。</p><p>C++中大量的编程错误都来自初始化不正确，因为这种问题难以被发现，并且清理不当也会出问题。</p><p>C++中析构很重要，但是在Java中有垃圾回收器，很多情况下是不需要手动清理的，虽然可能会慢一点，但是影响不大。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;5-初始化与清理&quot;&gt;&lt;a href=&quot;#5-初始化与清理&quot; class=&quot;headerlink&quot; title=&quot;5. 初始化与清理&quot;&gt;&lt;/a&gt;5. 初始化与清理&lt;/h1&gt;&lt;p&gt;随着计算机革命的发展，“不安全” 的编程方式已逐渐成为编程代价高昂的主因之一。&lt;/p&gt;</summary>
    
    
    
    <category term="hwcd" scheme="https://www.szjm.online/categories/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/categories/hwcd/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="hwcd" scheme="https://www.szjm.online/tags/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/tags/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>控制执行流程</title>
    <link href="https://www.szjm.online/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/4.%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.szjm.online/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/4.%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2022-08-24T08:41:48.000Z</published>
    <updated>2022-08-26T12:55:06.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-控制执行流程"><a href="#4-控制执行流程" class="headerlink" title="4. 控制执行流程"></a>4. 控制执行流程</h1><p>就像有知觉的生物一样， 程序必须在执行过程中控制它的世界，并做出选择。在Java中，你要使用执行控制语句来做出选择。<span id="more"></span></p><h2 id="4-1-true和false"><a href="#4-1-true和false" class="headerlink" title="4.1 true和false"></a>4.1 true和false</h2><p>所有语句都利用真假两种状态来决定执行路径。</p><p>但是不允许将数字作为布尔值使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//if (a)</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="4-2-if-else"><a href="#4-2-if-else" class="headerlink" title="4.2 if-else"></a>4.2 if-else</h2><p>控制程序流程的基本形式。else可选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Boolean-expression)</span><br><span class="line">    statement</span><br><span class="line">或</span><br><span class="line"><span class="keyword">if</span> (Boolean-expression)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p><strong>java没有elif</strong></p><p>if-else可以嵌套</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Boolean-expression)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Boolean-expression)</span><br><span class="line">statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.szjm.struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入成绩: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (score == <span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;S&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">100</span> &amp;&amp; score &gt;= <span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">90</span> &amp;&amp; score &gt;= <span class="number">80</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">80</span> &amp;&amp; score &gt;= <span class="number">70</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">70</span> &amp;&amp; score &gt;= <span class="number">60</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">60</span> &amp;&amp; score &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-迭代"><a href="#4-3-迭代" class="headerlink" title="4.3 迭代"></a>4.3 迭代</h2><p>while、do-while和for用来控制循环，有时将它们划分为迭代语句(iteration statement)。 </p><p>语句会重复执行，直到起控制作用的布尔表达式(Booleanexpression) 得到“假”的结果为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(Boolean-expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>在循环刚开始时，会计算一次布尔表达式的值；而在语句的下一次迭代开始前会再计算一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AeroplaneChessStart1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">counterNum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rollNum</span> <span class="operator">=</span> rand.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">        System.out.println(counterNum + <span class="string">&quot;: &quot;</span> + rollNum);</span><br><span class="line">        <span class="keyword">while</span> (rollNum != <span class="number">6</span>)&#123;</span><br><span class="line">            rollNum = rand.nextInt(<span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">            counterNum++;</span><br><span class="line">            System.out.println(counterNum + <span class="string">&quot;: &quot;</span> + rollNum);&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;在第&quot;</span> + counterNum + <span class="string">&quot;回合摇到了6，允许起飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个飞行棋相关的小程序，用while判断是否摇到了数字6。</p><p>这里while后面加了花括号，如果不加花括号的话只会执行while后面的第一句</p><h3 id="4-3-1-do-while"><a href="#4-3-1-do-while" class="headerlink" title="4.3.1 do-while"></a>4.3.1 do-while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">   statement</span><br><span class="line"><span class="title function_">while</span><span class="params">(Boolean-expression)</span>    </span><br></pre></td></tr></table></figure><p>while和do-while唯一的区别就是do-while中的语句至少会执行一次，即便表达式第一次就被<br>计算为false。而在while循环结构中，如果条件第一次就为false, 那么其中的语句根本不会执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class AeroplaneChessStart2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random rand = new Random();</span><br><span class="line">        int counterNum = 0;</span><br><span class="line">        int rollNum = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            counterNum++;</span><br><span class="line">            rollNum = rand.nextInt(6) + 1;</span><br><span class="line">            System.out.println(counterNum + &quot;: &quot; + rollNum);</span><br><span class="line">        &#125;while (rollNum != 6);</span><br><span class="line">        System.out.println(&quot;在第&quot; + counterNum + &quot;回合摇到了6，允许起飞&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是飞行棋起飞，改成do-while。</p><h3 id="4-3-2-for"><a href="#4-3-2-for" class="headerlink" title="4.3.2 for"></a>4.3.2 for</h3><p>for循环可能是最经常使用的迭代形式，这种在第一次迭代之前要进行初始化。随后，它会<br>进行条件测试，而且在每一次迭代结束时，进行某种形式的“步进”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialization;Boolean-expression;step)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p>初始化(initialization) 表达式、布尔表达式(Boolean-expression), 或者步进(step) 运算，都可以为空。每次迭代前会测试布尔表达式。若获得的结果是false，就会执行for语句后面的代<br>码行。</p><p>每次循环结束，会执行一次步进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化//条件判断//迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">    System.out.println(i);<span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;for循环结束&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="4-3-3-逗号操作符"><a href="#4-3-3-逗号操作符" class="headerlink" title="4.3.3 逗号操作符"></a>4.3.3 逗号操作符</h3><p>是逗号操作符，不是逗号分隔符，Java用到逗号操作符的地方只有for循环里。</p><p>在for循环的初始化和步进控制里，可以使用一系列由逗号分格的语句，而且这些语句会独立执行。</p><p><strong>初始化部分只能是同一类型的定义。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommaOperator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>,j = <span class="number">0</span>; i &lt; <span class="number">6</span> ; i++, j += <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/4.%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/4_3_3_1输出结果.png" alt="4_3_3_1输出结果"><h2 id="4-4-Foreach语法"><a href="#4-4-Foreach语法" class="headerlink" title="4.4 Foreach语法"></a>4.4 Foreach语法</h2><p>不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.szjm.struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForDemo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums =&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>&#125;;<span class="comment">//定义一个数组</span></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums)&#123;<span class="comment">//把nums每一项遍历出来赋值给x 每一次循环从nums取值</span></span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以用foreach把字符串拆分输出（str.toCharArray()  返回一个char数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : <span class="string">&quot;Talk is cheap. Show me the code.&quot;</span>.toCharArray())</span><br><span class="line">            System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/4.%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/4_4_1输出结果.png" alt="4_4_1输出结果"><p>除了遍历之外，还可以有一些基于遍历的操作,比如代替fori</p><p>可以把</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br></pre></td></tr></table></figure><p>替换成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : range(<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p><strong>但是</strong>，虽然用range()让foreach的可用性变高了，但是，代码运行效率会降低。</p><h2 id="4-5-return"><a href="#4-5-return" class="headerlink" title="4.5 return"></a>4.5 return</h2><p>returm关键词有两方面的用途：</p><ul><li>指定一个方法返回什么值(假设它没有void返回值)</li><li>会导致当前的方法退出，并返回那个值。</li></ul><h2 id="4-6-break和continue"><a href="#4-6-break和continue" class="headerlink" title="4.6 break和continue"></a>4.6 break和continue</h2><p>在任何迭代语句的主体部分，都可用break和continue控制循环的流程。</p><ul><li>break 强行退出循环，不执行循环中剩余的语句。</li><li>continue 停止执行当前的迭代，然后退回循环起始处，开始下一次迭代。</li></ul><h2 id="4-7-臭名昭著的goto"><a href="#4-7-臭名昭著的goto" class="headerlink" title="4.7 臭名昭著的goto"></a>4.7 臭名昭著的goto</h2><p>java中有goto关键字，但是没有goto，但是有相同的机制“标签”。</p><p>break和continue关键词通常只中断当前循环，但若随同标签一起使用，它们就会中断循环，直到标签所在的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">label1:</span><br><span class="line">外循环入口</span><br><span class="line">&#123;</span><br><span class="line">内循环入口</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//(1)</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">//(2)</span></span><br><span class="line">        <span class="keyword">continue</span> label; <span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">continue</span> label; <span class="comment">//(4)</span></span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>break中断内部迭代，回到外部迭代</p></li><li><p>continue使执行点移回内部迭代的起始处</p></li><li><p>continue label同时中断内部迭代及外部迭代，直接转到label处，随后，它实际上是继续迭代过程，但却从外部迭代开始。</p></li><li><p>break label也会中断所有迭代，回到label处，但并不从新进入循环，即实际上是完全中止了两个迭代。</p></li></ol><p>一般的 continue 会退回最内层循环的开头（顶部），并继续执行。<br>带标签的 continue 会到达标签的位置，并重新进入紧接在那个标签后面的循环。<br>一般的 break 会中断并跳出当前循环。<br>带标签的 break 会中断并跳出标签所指的循环。</p><h2 id="4-8-switch"><a href="#4-8-switch" class="headerlink" title="4.8 switch"></a>4.8 switch</h2><p>switch有时也被划归为一种选择语句。</p><p>根据整数表达式的值，switch语句可以从一系列代码中选出一段去执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.szjm.struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (grade)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;奖学金我来了&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;就这样吧&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;回去打游戏喽&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;感谢老师不杀之恩&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;诶嘿 开摆&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;小老弟怎么回事&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个case均以一个break结尾， 这样可使执行流程跳转至switch主体的末尾。</p><p>这是构建switch语 句的一种传统方式， 但break是可选的。若省略break,会继续执行后面的case语句，直到遇到一个break为止。尽管通常不想出现这种情况，但对有经验的程序员来说，也许能够善加利用这种情况。注意最后的default语句没有break,因为执行流程已到了break的跳转目的地。当然，如果考虑到编程风格方面的原因，完全可以在default语句的末尾放一个break,尽管它并没有任何实际的用处。</p><p>break也可以不写，这样还会对grade进行后面的判断（如果有需要的话，一般没需要，加上break不对后面的数据进行判断还能节省时间）</p><p>switch语句是实现多路选择(也就是说从一系列执行路径中挑选一个)的一种干净利落的方<br>法。但它要求使用一个选择因子，并且必须是int或char那样的整数值。例如，假若将一个字符串或者浮点数作为选择因子使用，那么它们在switch语句里是不会工作的。对于非整数类型,则必须使用一系列if语句。</p><h2 id="4-9-总结"><a href="#4-9-总结" class="headerlink" title="4.9 总结"></a>4.9 总结</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;4-控制执行流程&quot;&gt;&lt;a href=&quot;#4-控制执行流程&quot; class=&quot;headerlink&quot; title=&quot;4. 控制执行流程&quot;&gt;&lt;/a&gt;4. 控制执行流程&lt;/h1&gt;&lt;p&gt;就像有知觉的生物一样， 程序必须在执行过程中控制它的世界，并做出选择。在Java中，你要使用执行控制语句来做出选择。&lt;/p&gt;</summary>
    
    
    
    <category term="hwcd" scheme="https://www.szjm.online/categories/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/categories/hwcd/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="hwcd" scheme="https://www.szjm.online/tags/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/tags/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>操作符</title>
    <link href="https://www.szjm.online/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://www.szjm.online/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/</id>
    <published>2022-08-24T06:12:13.000Z</published>
    <updated>2022-08-26T12:55:11.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-操作符"><a href="#3-操作符" class="headerlink" title="3. 操作符"></a>3. 操作符</h1><p>在最底层，Java中的数据是通过使用操作符来操作的。</p><p>Java建立在C++的基础上，大多语法差不多。<span id="more"></span></p><h2 id="3-1-更简单的打印语句"><a href="#3-1-更简单的打印语句" class="headerlink" title="3.1 更简单的打印语句"></a>3.1 更简单的打印语句</h2><p>可以自己编写一些工具类来简化System.out.println</p><h2 id="3-2-使用Java操作符"><a href="#3-2-使用Java操作符" class="headerlink" title="3.2 使用Java操作符"></a>3.2 使用Java操作符</h2><p>了解常用的操作符，String类型支持“+”和“+&#x3D;”</p><h2 id="3-3-优先级"><a href="#3-3-优先级" class="headerlink" title="3.3 优先级"></a>3.3 优先级</h2><p>操作符的顺序，最简单的就是和数学一样先乘除后加减，先算小括号</p><h2 id="3-4-赋值"><a href="#3-4-赋值" class="headerlink" title="3.4 赋值"></a>3.4 赋值</h2><p><code>=</code> 取右值复制给左值</p><p>右值可以是任何常数、变量、表达式，只要能生成一个值。</p><p>左值必须是一个明确的、已命名的变量。</p><p>常量因为不能被改变所以不能赋值。</p><p><strong>有关对象的赋值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span>&#123;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Assignment</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Tank</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        <span class="type">Tank</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        t1.level = <span class="number">9</span>;</span><br><span class="line">        t1.name = <span class="string">&quot;t1&quot;</span>;</span><br><span class="line">        t2.level = <span class="number">47</span>;</span><br><span class="line">        t2.name = <span class="string">&quot;t2&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1: t1.level: &quot;</span> + t1.level + <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">        t1 = t2;</span><br><span class="line">        System.out.println(<span class="string">&quot;2: t1.level: &quot;</span> + t1.level + <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">        t1.level = <span class="number">27</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3: t1.level: &quot;</span> + t1.level + <span class="string">&quot;, t2.level: &quot;</span> + t2.level);</span><br><span class="line">        System.out.println(t1.name + t2.name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_4_1%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" alt="3_4_1输出结果"></p><p>赋值操作是对一个对象的引用，本来t1.level引用的是值为9的这个对象，但是在赋值的时候被t2.level的引用覆盖了，现在两个引用的都是值为47的这个对象，值为9的这个对象没有了引用会被java的垃圾回收器自动清理。</p><p>方便观察我在树上代码的基础上新增了name字段，可以明确地看出是t2覆盖了t1的值。</p><p>如果只是想对字段进行赋值要记得明确到字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.level = t2.name;</span><br></pre></td></tr></table></figure><h3 id="3-4-1-方法调用中的别名问题"><a href="#3-4-1-方法调用中的别名问题" class="headerlink" title="3.4.1 方法调用中的别名问题"></a>3.4.1 方法调用中的别名问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Letter</span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassObject</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Letter y)</span>&#123;</span><br><span class="line">        y.c = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Letter</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Letter</span>();</span><br><span class="line">        x.c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1: x.c: &quot;</span> + x.c);</span><br><span class="line">        f(x);</span><br><span class="line">        System.out.println(<span class="string">&quot;2: x.c: &quot;</span> + x.c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_4_1_1输出结果.png" alt="3_4_1_1输出结果"><p>这其中f()中y是定义的参数名，其实就是x，所以对y.c的赋值其实就是在对x.c赋值</p><h2 id="3-5-算术操作符"><a href="#3-5-算术操作符" class="headerlink" title="3.5 算术操作符"></a>3.5 算术操作符</h2><p>+-*&#x2F;% <code>/</code>整数除法会直接去掉结果的小数位，而不是四舍五入取整。</p><p><code>+=</code>简化符号 同时进行运算和赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//等同</span></span><br><span class="line">n = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>Random()可以生成伪随机数，在不指定种子的情况下会将当前时间作为随机数的种子。（如果每次用一样的种子就能生成一样的数字）</p><h3 id="3-5-1-一元加减操作符"><a href="#3-5-1-一元加减操作符" class="headerlink" title="3.5.1 一元加减操作符"></a>3.5.1 一元加减操作符</h3><p>正负号</p><p>编译器能自动判断出使用哪一种 但是为了让人能看清楚最好加上小括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = -a;</span><br><span class="line">x = a * -b;</span><br><span class="line">x = a * (-b);</span><br></pre></td></tr></table></figure><p>因为不加<code>-</code>的数字默认是正数，所以<code>+</code>惟一的作用仅仅是将较小类型的操作数提升为int</p><h2 id="3-6-自动递增和递减"><a href="#3-6-自动递增和递减" class="headerlink" title="3.6 自动递增和递减"></a>3.6 自动递增和递减</h2><p><code>++</code>  <code>--</code></p><ul><li><strong>前缀</strong>  <code>++</code> <code>--</code>操作符位于变量或表达式的前面。先执行运算，再生成值。</li><li><strong>后缀</strong>  <code>++</code> <code>--</code>操作符位于变量或表达式的后面。先生成值，再执行运算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoInc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);<span class="comment">//(1)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;++i: &quot;</span> + ++i);<span class="comment">//i+=1(2);print(2)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i++: &quot;</span> + i++);<span class="comment">//print(2);i+=1(3)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);<span class="comment">//(3)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--i: &quot;</span> + --i);<span class="comment">//i-=1(2);print(2)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i--: &quot;</span> + i--);<span class="comment">//print(2);i-=1(1)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);<span class="comment">//(1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_6_1输出结果.png" alt="3_6_1输出结果"><h2 id="3-7-关系操作符"><a href="#3-7-关系操作符" class="headerlink" title="3.7 关系操作符"></a>3.7 关系操作符</h2><p>生成一个Boolean结果，计算操作数的值之间的关系</p><p><strong>不是比大小，而是判断是不是比他大&#x2F;比他小</strong></p><h3 id="3-7-1-测试对象的等价性"><a href="#3-7-1-测试对象的等价性" class="headerlink" title="3.7.1 测试对象的等价性"></a>3.7.1 测试对象的等价性</h3><p>关系操作符<code>==</code>  <code>!=</code>适用于所有对象，但是这两个操作符每次是在比较什么，需要自行判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Equivalence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">47</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">47</span>);</span><br><span class="line">        System.out.println(n1 == n2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(n1 != n2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(n1.equals(n2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">        System.out.println(n3 == n4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(n3 != n4);<span class="comment">//false</span></span><br><span class="line">        System.out.println(Objects.equals(n3, n4));</span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Num</span> <span class="variable">n5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Num</span>();</span><br><span class="line">        <span class="type">Num</span> <span class="variable">n6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Num</span>();</span><br><span class="line">        System.out.println(n5 == n6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(n5 != n6);<span class="comment">//true</span></span><br><span class="line">        System.out.println(n5.equals(n6));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(n5.i == n6.i);<span class="comment">//true</span></span><br><span class="line">        System.out.println(n5.i != n6.i);<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(n1);<span class="comment">//47</span></span><br><span class="line">        System.out.println(n1 == <span class="number">47</span>);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-逻辑操作符"><a href="#3-8-逻辑操作符" class="headerlink" title="3.8 逻辑操作符"></a>3.8 逻辑操作符</h2><p>与<code>&amp;&amp;</code>  或<code>||</code> 非<code>！</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">T</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">F</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;T: &quot;</span> + T);</span><br><span class="line">        System.out.println(<span class="string">&quot;F: &quot;</span> + F);</span><br><span class="line">        System.out.println(<span class="string">&quot;!T: &quot;</span> + !T);</span><br><span class="line">        System.out.println(<span class="string">&quot;!F: &quot;</span> + !F);</span><br><span class="line">        System.out.println(<span class="string">&quot;T &amp;&amp; F: &quot;</span> + (T &amp;&amp; F));</span><br><span class="line">        System.out.println(<span class="string">&quot;T || F: &quot;</span> + (T || F));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_8_1输出结果.png" alt="3_8_1输出结果"><h3 id="3-8-1-短路"><a href="#3-8-1-短路" class="headerlink" title="3.8.1 短路"></a>3.8.1 短路</h3><p>与<code>&amp;&amp;</code>  一个为假全为假 两个都是真才为真</p><p>或<code>||</code> 一个为真全为真 两个都是假才为假</p><p>非<code>！</code>  取反</p><h2 id="3-9-直接常量"><a href="#3-9-直接常量" class="headerlink" title="3.9 直接常量"></a>3.9 直接常量</h2><p>toBinaryString（int i）：返回int变量的二进制表示的字符串。<br>toHexString（int i）：返回int变量的16进制字符串。<br>toOctalString（int i）：返回int变量的8进制表示字符串。</p><p>长整型long后面<code>L</code> 不用小写l与1和大写I做区分</p><p>浮点型float和双精度浮点型double后面的<code>f</code> <code>d</code>用大小写都能区分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Literals</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">122</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;HEX num1:&quot;</span> + Integer.toHexString(num1));</span><br><span class="line">        System.out.println(<span class="string">&quot;DEC num1:&quot;</span> + num1);</span><br><span class="line">        System.out.println(<span class="string">&quot;OCT num1:&quot;</span> + Integer.toOctalString(num1));</span><br><span class="line">        System.out.println(<span class="string">&quot;BIN num1:&quot;</span> + Integer.toBinaryString(num1));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0x2f</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;i1:&quot;</span>+ Integer.toBinaryString(i1));</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">0X2F</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;i2:&quot;</span>+ Integer.toBinaryString(i2));</span><br><span class="line">        <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0177</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;i3:&quot;</span>+ Integer.toBinaryString(i3));</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0xffff</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;c:&quot;</span>+ Integer.toBinaryString(c));</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0x7f</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;b:&quot;</span>+ Integer.toBinaryString(b));</span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0x7fff</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;s:&quot;</span>+ Integer.toBinaryString(s));</span><br><span class="line">        <span class="type">long</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">200L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200l</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">1F</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="number">1f</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">1d</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1D</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_9_1输出结果.png" alt="3_9_1输出结果"><p>直接常量后面的后缀字符标志了它的类型。</p><p>若为大写(或小写)的L，代表long (但是,使用小写字母容易造成混淆，因为它看起来很像数字1或者大写I)</p><p>大写(或小写)字母F,代表foat</p><p>大写(或小写)字母D,则代表double</p><p>十六进制数适用于所有整数数据类型，以前缀0x (或0X)，后面跟随0-9或小写(或大写)的a-f来表示。如果试图将一个变量初始化成超出自身表示范围的值(无论这个值的数值形式如何)，编译器都会向我们报告一条错误信息。 注意在前面的代码中，已经给出了char、bytel以及short所能表示的最大的十六进制值。如果超出范围，编译器会将值自动转换成int型，并告诉我们需要对这次赋值进行“ 窄化转型”(转型将在本章稍后部分定义)。这样我们就可清楚地知道<br>自己的操作是否越界了。</p><h3 id="3-9-1-指数计数法"><a href="#3-9-1-指数计数法" class="headerlink" title="3.9.1 指数计数法"></a>3.9.1 指数计数法</h3><p>虽然数学里<code>e</code>表示自然对数的基数约等于2.718，但是在科学计数法中<code>e</code>表示10</p><p>例如 1.39*e^-43^ 表示 1.39*10^-43^ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exponents</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">expFloat</span> <span class="operator">=</span> <span class="number">1.39e-43f</span>;</span><br><span class="line">        System.out.println(expFloat);</span><br><span class="line">        <span class="type">double</span> <span class="variable">expDouble</span> <span class="operator">=</span> <span class="number">47e6d</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">expDouble2</span> <span class="operator">=</span> <span class="number">47e5d</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">expDouble3</span> <span class="operator">=</span> <span class="number">47e47</span>;</span><br><span class="line">        System.out.println(expDouble);</span><br><span class="line">        System.out.println(expDouble2);</span><br><span class="line">        System.out.println(expDouble3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_9_1_1输出结果.png" alt="3_9_1_1输出结果"><p>这里科学计数法的整数部分只有1位，如果看到你输入的47e47变成了4.7e48不要迷茫</p><h2 id="3-10-按位操作符"><a href="#3-10-按位操作符" class="headerlink" title="3.10 按位操作符"></a>3.10 按位操作符</h2><p>操作整数基本数据的单个比特<code>bit</code>二进制位。</p><p>按位操作源于C语言面向底层的操作，直接操作底层硬件，设置硬件寄存器里的二进制位。</p><p>Java的设计初衷是嵌入电视机顶盖，所以保留了这种面向底层的操作。</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&amp; 按位与</td><td>如果相对应位都是1，则结果为1，否则为0</td></tr><tr><td>| 按位或</td><td>如果相对应位都是0，则结果为0，否则为1</td></tr><tr><td>^ 按位异或</td><td>如果相对应位值相同，则结果为0，否则为1</td></tr><tr><td>~ 按位取反</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BINoperate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;BIN n1: &quot;</span> + df.format(Integer.valueOf(Integer.toBinaryString(n1))));</span><br><span class="line">        System.out.println(<span class="string">&quot;BIN n2: &quot;</span> + df.format(Integer.valueOf(Integer.toBinaryString(n2))));</span><br><span class="line">        System.out.println(<span class="string">&quot;&amp;: &quot;</span>  + df.format(Integer.valueOf(Integer.toBinaryString(n1 &amp; n2))));</span><br><span class="line">        System.out.println(<span class="string">&quot;&amp;: &quot;</span>  + (n1 &amp; n2));</span><br><span class="line">        System.out.println(<span class="string">&quot;|: &quot;</span>  + df.format(Integer.valueOf(Integer.toBinaryString(n1 | n2))));</span><br><span class="line">        System.out.println(<span class="string">&quot;|: &quot;</span>  + (n1 | n2));</span><br><span class="line">        System.out.println(<span class="string">&quot;^: &quot;</span>  + df.format(Integer.valueOf(Integer.toBinaryString(n1 ^ n2))));</span><br><span class="line">        System.out.println(<span class="string">&quot;^: &quot;</span>  + (n1 ^ n2));</span><br><span class="line">        System.out.println(<span class="string">&quot;~n1: &quot;</span>  + Integer.toBinaryString(~n1));</span><br><span class="line">        System.out.println(<span class="string">&quot;~n1: &quot;</span>  + ~n1);</span><br><span class="line">        System.out.println(<span class="string">&quot;~n2: &quot;</span>  + Integer.toBinaryString(~n2));</span><br><span class="line">        System.out.println(<span class="string">&quot;~n2: &quot;</span>  + ~n2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_10_1%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" alt="3_10_1输出结果"></p><h2 id="3-11-移位操作符"><a href="#3-11-移位操作符" class="headerlink" title="3.11 移位操作符"></a>3.11 移位操作符</h2><p>移位操作符操作的运算对象也是二进制的“位” 。</p><p>移位操作符只可用来处理整数类型(基本类型的一种)。 </p><ul><li><p>**左移位操作符<code>&lt;&lt;</code> **  能按照操作符右侧指定的位数将操作符左边的操作数向左移动(在低位补0)。</p></li><li><p><strong>“有符号”右移位操作符<code>&gt;&gt;</code></strong>  则按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：</p><ul><li>若符号为正，则在高位插入0</li><li>若符号为负，则在高位插入1</li></ul></li><li><p><strong>“无符号”右移位操作符<code>&gt;&gt;&gt;</code></strong>  Java中新增的，它使用“零扩展”：无论正负，都在高位插入0。这一作符是C或C++中所没有的。</p></li></ul><p>如果对char、byte或者short类 型的数值进行移位处理，那么在移位进行之前，它们会<strong>被转<br>换为int类型</strong>，并且得到的<strong>结果也是一个int类型的值</strong>。只有数值右端的低5位才有用。这样可防止我们移位超过int型值所具有的位数。(译注: 因为2的5次方为32，而int型值只有32位。) 若对一个long类型的数值进行处理,最后得到的结果也是long。此时只会用到数值右端的低6位，以防止移位超过long型数值具有的位数。</p><p>“移位”可与“等号”(&lt;&lt;&#x3D;或&gt;&gt; &gt;&#x3D;或&gt;&gt;&gt;&#x3D;)组合使用。此时，操作符左边的值会移动由右边<br>的值指定的位数，再将得到的结果赋给左边的变量。但在进行“无符号”右移位结合赋值操作<br>时，可能会遇到-一个问题:如果对byte或short值 进行这样的移位运算，得到的可能不是正确的结果。它们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型,在这种情况下可能得到-1的结果。下面这个例子演示了这种情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URShift</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line">        i &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line">        l &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line">        s &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line"></span><br><span class="line">        b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">        System.out.println(Integer.toBinaryString(b&gt;&gt;&gt;<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_11_1输出结果.png" alt="3_11_1输出结果"><p>在最后一个移位运算中，结果没有赋给b,而是直接打印出来，所以其结果是正确的。</p><h2 id="3-12-三元操作符-if-else"><a href="#3-12-三元操作符-if-else" class="headerlink" title="3.12 三元操作符 if-else"></a>3.12 三元操作符 if-else</h2><p>三元操作符也称为条件操作符，它显得比较特别，因为它有三个操作数。但它确实属于操<br>作符的一种，因为<strong>它最终也会生成一个值</strong>，这与本普通if-else语句是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>-exp ? value0 : value1</span><br></pre></td></tr></table></figure><p>如果boolean-exp (布尔表达式)的结果为true,就计算value0,而且这个计算结果也就是操作符最终产生的值。</p><p>如果boolean-exp的结果为false,就计算value1,,同样,它的结果也就成为了操作符最终产生的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TernaryIfElse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ternary</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">10</span> ? i*<span class="number">100</span> : i*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">standardIfElse</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">return</span> i * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ternary(<span class="number">9</span>));</span><br><span class="line">        System.out.println(ternary(<span class="number">10</span>));</span><br><span class="line">        System.out.println(standardIfElse(<span class="number">9</span>));</span><br><span class="line">        System.out.println(standardIfElse(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ternary与standardIfElse功能一样，但是使用三元运算符的ternary更为简洁紧凑</p><h2 id="3-13-字符串操作符"><a href="#3-13-字符串操作符" class="headerlink" title="3.13 字符串操作符 + +="></a>3.13 字符串操作符 <code>+</code> <code>+=</code></h2><p>连接字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringOperators</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">1</span>, z = <span class="number">2</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;x, y, z&quot;</span>;</span><br><span class="line">        System.out.println(s + x + y + z);<span class="comment">//x, y, z012</span></span><br><span class="line">        System.out.println(x + <span class="string">&quot; &quot;</span> + s);<span class="comment">//0 x, y, z</span></span><br><span class="line">        s += <span class="string">&quot;(summed) = &quot;</span>;</span><br><span class="line">        System.out.println(s + (x + y + z));<span class="comment">//x, y, z(summed) = 3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span> + x);<span class="comment">//0</span></span><br><span class="line">        System.out.println(x + <span class="string">&quot;&quot;</span> + y);<span class="comment">//01</span></span><br><span class="line">        System.out.println(x + y + <span class="string">&quot;&quot;</span>);<span class="comment">//1</span></span><br><span class="line">        System.out.println(x + y + <span class="string">&quot;&quot;</span> + z);<span class="comment">//12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有字符串参与运算，那么整个结果就全是字符串了</p><h2 id="3-14-使用操作符时常犯的错误"><a href="#3-14-使用操作符时常犯的错误" class="headerlink" title="3.14 使用操作符时常犯的错误"></a>3.14 使用操作符时常犯的错误</h2><ol><li><p>区分<code>=</code> <code>==</code></p></li><li><p>记得用<code>()</code></p></li></ol><p>错误示范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（x = y)&#123;</span><br><span class="line">    <span class="comment">//………………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-15-类型转换操作符"><a href="#3-15-类型转换操作符" class="headerlink" title="3.15 类型转换操作符"></a>3.15 类型转换操作符</h2><p>在适当的时候，Java会将一种数据类型自动转换成另一种。</p><p>类型转换允许我们显式的进行这种类型的转换，或者在不能自动进行转换的时候强制进行类型转换。</p><p>格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(要被转换为什么类型)要被转换的变量</span><br></pre></td></tr></table></figure><p>Java允许除了布尔型的任何基本数据类型互相转换。</p><h3 id="3-15-1-截尾和舍入"><a href="#3-15-1-截尾和舍入" class="headerlink" title="3.15.1 截尾和舍入"></a>3.15.1 截尾和舍入</h3><p>如果吧一个浮点型转换成一个整数型，会不会被四舍五入？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CastingNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">fa</span> <span class="operator">=</span> <span class="number">1.7f</span>, fb = <span class="number">1.4f</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">da</span> <span class="operator">=</span> <span class="number">1.7</span>, db = <span class="number">1.4</span>;</span><br><span class="line">        System.out.println((<span class="type">int</span>)fa);<span class="comment">//1</span></span><br><span class="line">        System.out.println((<span class="type">int</span>)fb);<span class="comment">//1</span></span><br><span class="line">        System.out.println((<span class="type">int</span>)da);<span class="comment">//1</span></span><br><span class="line">        System.out.println((<span class="type">int</span>)db);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_15_1_1输出结果.png" alt="3_15_1_1输出结果"><p>结果是没有四舍五入，直接截尾（抹去了小数部分的位数）</p><p>如果想获得四舍五入的结果，可以使用java.lang.Math中的round()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundingNumbers</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">fa</span> <span class="operator">=</span> <span class="number">1.7f</span>, fb = <span class="number">1.4f</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">da</span> <span class="operator">=</span> <span class="number">1.7</span>, db = <span class="number">1.4</span>;</span><br><span class="line">        System.out.println(Math.round(fa));<span class="comment">//2</span></span><br><span class="line">        System.out.println(Math.round(fb));<span class="comment">//1</span></span><br><span class="line">        System.out.println(Math.round(da));<span class="comment">//2</span></span><br><span class="line">        System.out.println(Math.round(db));<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/24/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/3.%E6%93%8D%E4%BD%9C%E7%AC%A6/3_15_1_2输出结果.png" alt="3_15_1_2输出结果"><h3 id="3-15-2-提升"><a href="#3-15-2-提升" class="headerlink" title="3.15.2 提升"></a>3.15.2 提升</h3><p>比int小的类型，在运算之前，这些值会自动转换成int，最终生成的结果也是int，如果再想把结果赋值给较小的类型，就必须使用类型转换，可能会出现信息丢失。</p><p>通常，表达式中最大数据类型就是表达式最终结果的类型。</p><p>float+double&#x3D;double</p><p>int+long&#x3D;long</p><h2 id="3-16-Java没有sizeof"><a href="#3-16-Java没有sizeof" class="headerlink" title="3.16 Java没有sizeof"></a>3.16 Java没有sizeof</h2><p>在C和C++中, sizeof()操作符可以告诉你为数据项分配的字节数。在C和C++中，需要使用sizeof()的最大原因是为了“移植” 。不同的数据类型在不同的机器上可能有不同的大小，所以在进行一些与存储空间有关的运算时，程序员必须获悉那些类型具体有多大。例如，一台计算机可用32位来保存整数，而另一台只用16位保存。显然，在第一台机器中，程序可保存更大的值。可以想像，移植是令C和C++程序员颇为头痛的一个问题。Java不需要sizeof()操作符来满足这方面的需要，因为所有数据类型在所有机器中的大小都是相同的。我们不必考虑移植问题一它已经被设计在语言中了。</p><h2 id="3-17-操作符小结"><a href="#3-17-操作符小结" class="headerlink" title="3.17 操作符小结"></a>3.17 操作符小结</h2><p>注意，能够对布尔型值进行的运算非常有限。我们只能赋予它true和false值， 并测试它为真<br>还是为假，而不能将布尔值相加，或对布尔值进行其他任何运算。</p><p>在char、byte和short中， 使用算术操作符中数据类型提升。对这些类型的任何一个进行算术运算，都会获得一个int结果， 必须将其显式地类型转换回原来的类型(窄化转换可能会造成信息的丢失)，以将值赋给原本的类型。</p><p>但对于int值， 却不必进行类型转化，因为所有数据都已经属于int类型。</p><p>如果对两个足够大的int值执行乘法运算，结果就会溢出。</p><h2 id="3-18-总结"><a href="#3-18-总结" class="headerlink" title="3.18 总结"></a>3.18 总结</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;3-操作符&quot;&gt;&lt;a href=&quot;#3-操作符&quot; class=&quot;headerlink&quot; title=&quot;3. 操作符&quot;&gt;&lt;/a&gt;3. 操作符&lt;/h1&gt;&lt;p&gt;在最底层，Java中的数据是通过使用操作符来操作的。&lt;/p&gt;
&lt;p&gt;Java建立在C++的基础上，大多语法差不多。&lt;/p&gt;</summary>
    
    
    
    <category term="hwcd" scheme="https://www.szjm.online/categories/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/categories/hwcd/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="hwcd" scheme="https://www.szjm.online/tags/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/tags/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>一切都是对象</title>
    <link href="https://www.szjm.online/2022/08/23/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.szjm.online/2022/08/23/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-08-23T08:24:37.000Z</published>
    <updated>2022-08-26T12:55:15.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-一切都是对象"><a href="#2-一切都是对象" class="headerlink" title="2. 一切都是对象"></a>2. 一切都是对象</h1><blockquote><p>“如果我们说另一种不同的语言,那么我们就会发觉一个有些不同的世界。”<br>——Luduing Wittgerstein (1889-1951)</p></blockquote><p>尽管Java是基于C++的，但是相比之下，Java是一种更“ 纯粹”的面向对象程序设计语言。 <span id="more"></span>     </p><p><strong>学习Java需要有面向对象编程的思想</strong></p><h2 id="2-1-用引用操纵对象"><a href="#2-1-用引用操纵对象" class="headerlink" title="2.1 用引用操纵对象"></a>2.1 用引用操纵对象</h2><p>Java中一切都被视为对象，但是操作标识符是引用（reference）。</p><p>用遥控器(引用)来操纵电视机(对象)。只要握住这个遥控器，就能保持与电视机的连接。当有人想改变频道或者减小音量时，实际操控的是遥控器(引用), 再由遥控器来调控电视机(对象)。如果想在房间里四处走走，同时仍能调控电视机,那么只需携带遥控器(引用)而不是电视机(对象)。</p><p>此外，即使没有电视机，遥控器亦可独立存在。也就是说，你拥有一个引用，并不一定需要有一个对象与它关联。</p><p>操作一个词或者句子，创建一个String类型引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure><p>这里只是创建引用，字符串s没有内容，并不是对象。此时s没有与任何事物相关联。安全的做法是给他赋值，初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;asdf&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="2-2-必须由你创建所有的对象"><a href="#2-2-必须由你创建所有的对象" class="headerlink" title="2.2 必须由你创建所有的对象"></a>2.2 必须由你创建所有的对象</h2><p>引用需要与对象关联，通常使用new操作符实现。new关键字的意思”给我一个新对象”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;asdf&quot;</span>);</span><br></pre></td></tr></table></figure><p>不仅有new表示“给我一个新的字符串”，而且提供了一个初始字符串，给出了怎样产生这个String的信息。</p><p>Java提供了很多现成的类型，而且可以自行创建类型。</p><h3 id="2-2-1-存储到什么地方"><a href="#2-2-1-存储到什么地方" class="headerlink" title="2.2.1 存储到什么地方"></a>2.2.1 存储到什么地方</h3><p>一共5个地方可以存储</p><ol><li><strong>寄存器</strong>  最快，在处理器里，但地方小，你不能控制。</li><li><strong>堆栈</strong>  位于通用RAM(随机访问存储器) 。快速有效，但是需要知道所有项确切的生命周期，约束了灵活性。有些数据存储于堆栈中（对象引用），但是java不存储在堆栈中。</li><li><strong>堆</strong>  位于通用内存池（也位于RAM区），用于存放Java对象。<ul><li>好处  不需要知道存储的数据的生命周期 有很大的灵活性。运行new的代码时候，会自动在堆中进行内存分配</li><li>坏处  用堆进行分配和清理可能比用堆栈需要更多的时间</li></ul></li><li><strong>常量存储</strong>  常量通常直接在代码内部。安全，不会被改变。在嵌入式中，可以选择存放在ROM中。</li><li><strong>非RAM存储</strong>  存活于程序之外，可以不受程序的控制，程序没有运行时也可以存在。<ul><li>流对象  转化成字节流，通常被发送给另一台机器</li><li>持久化对象  被存放在磁盘上，程序终止时，可以保持自己的状态。把对象转化成存放在其他媒介的事物上，需要时再恢复成常规的基于RAM的对象</li></ul></li></ol><h3 id="2-2-2-特例：基本类型"><a href="#2-2-2-特例：基本类型" class="headerlink" title="2.2.2 特例：基本类型"></a>2.2.2 特例：基本类型</h3><p>用new创建小而简单的变量效率不高，这些变量不会用new创建，而是创建一个并非是引用的“自动”变量，直接存储值并且至于堆栈中，更加高效。</p><p>Java需要确定每种基本类型所占存储空间的大小，而且不会随着机器硬件变化，这是Java高可移植性的原因之一。</p><img src="/2022/08/23/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_2_2_1Java基本类型.png" alt="2_2_2_1Java基本类型"><p>所有数值类型都有正负号，不需要寻找无符号的数值类型。</p><h4 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h4><p>boolean类型没有明确大小，只有true和false</p><p>基本类型具有的包装器类，可以在堆中创建一个非基本对象，用来表示对应的基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br></pre></td></tr></table></figure><p>也可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在可以直接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;</span><br></pre></td></tr></table></figure><p>还能反过来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ch;</span><br></pre></td></tr></table></figure><h4 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h4><ul><li>BigInteger支持任意精度的整数。也就是说，在运算中，可以准确地表示任何大小的整数值，而不会丢失任何信息。</li><li>BigDecimal支持任何精度的定点数，例如，可以用它进行精确的货币计算。</li></ul><h3 id="2-2-3-Java中的数组"><a href="#2-2-3-Java中的数组" class="headerlink" title="2.2.3 Java中的数组"></a>2.2.3 Java中的数组</h3><p>几乎所有的程序设计语言都支持数组。在C和C++中数组是内存块，不安全。</p><p>Java中注重安全，会确保数组被初始化，也不能在范围之外被访问。范围检查用内存开销和下标检查为代价换取安全性和高效率。</p><p>数组其实是创建了一个引用，每个引用都会被初始化为特定值，拥有特定关键字null。</p><p>试图使用还是null的引用会报错，必须为他指定一个对象。</p><h2 id="2-3-永远不需要销毁对象"><a href="#2-3-永远不需要销毁对象" class="headerlink" title="2.3 永远不需要销毁对象"></a>2.3 永远不需要销毁对象</h2><p>变量需要存活多长时间？什么时候应该销毁对象？</p><h3 id="2-3-1-作用域"><a href="#2-3-1-作用域" class="headerlink" title="2.3.1 作用域"></a>2.3.1 作用域</h3><p>过程型语言都有作用域概念，决定了定义的变量名的可见性和生命周期。</p><p>在C C++ JAVA中，作用域由花括号<code>&#123;&#125;</code>决定 作用域里定义的变量只可用于作用域结束之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//只有x</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">96</span></span><br><span class="line">        <span class="comment">//x和q    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只有x</span></span><br><span class="line">    <span class="comment">//q不在作用域的范围里了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然说java是一种自由格式的语言，多余的空格、制表符、换行都不会影响程序执行的结果，但是较为严格的缩进会更易于代码的阅读。</p><h3 id="2-3-2-对象的作用域"><a href="#2-3-2-对象的作用域" class="headerlink" title="2.3.2 对象的作用域"></a>2.3.2 对象的作用域</h3><p>对象和基本类型的生命周期不一样。new的对象可以存活于作用域之外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a String&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//作用域结束</span></span><br></pre></td></tr></table></figure><p>引用在作用域结束时就消失了，但是s指向的对象仍然占据着内存空间。无法在作用域之后访问这个对象，唯一对它的引用已经超出了作用域范围。</p><p>用new创建的对象，只要需要，就会一直保留下去。这些一直存在的对象会不会塞满内存空间？在C++可能会遇到的问题，在Java中不会存在，因为Java有内存回收机制，你只管创建，不用了Java自己会回收。</p><h2 id="2-4-创建新的数据类型：类"><a href="#2-4-创建新的数据类型：类" class="headerlink" title="2.4 创建新的数据类型：类"></a>2.4 创建新的数据类型：类</h2><p>一切都是对象，怎么区分对象的类型？</p><h3 id="2-4-1-字段和方法"><a href="#2-4-1-字段和方法" class="headerlink" title="2.4.1 字段和方法"></a>2.4.1 字段和方法</h3><p>类有两种元素：字段（属性、数据成员）和方法（成员函数）。</p><p>字段可以是任何类型的对象，也可以是基本类型的一种，如果字段是对某个对象的引用，那么必须初始化改引用。</p><p>每个对象都有存储字段的空间，普通字段不能在对象间共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataOnly</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">boolean</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管这个类只有字段没有方法，只能存储数据，但是仍然可以new</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataOnly</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOnly</span>();</span><br></pre></td></tr></table></figure><p>还可以给类里的字段赋值，句式是objectReference.member</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.i = <span class="number">47</span>;</span><br><span class="line">data.d = <span class="number">1.1</span>;</span><br><span class="line">data.b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果字段不是基本类型而是一个对象，你需要修改再下的字段，只需要<code>.</code>下去就行了</p><p>如果需要了解成员方法的运行机制，就需要了解<code>参数</code>和<code>返回值</code></p><h4 id="基本成员默认值"><a href="#基本成员默认值" class="headerlink" title="基本成员默认值"></a>基本成员默认值</h4><p>类里的基本数据类型即使没有初始化，Java也会给一个默认值。</p><p><strong>当变量作为累的成员使用时，Java才确保给默认值</strong></p><p>如果是“局部”变量，而不是某个类的字段，可能会得到任意值，而不是被初始化为0。如果没有初始化Java会在编译时直接报错。</p><img src="/2022/08/23/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_4_1_1基本类型默认值对照表.png" alt="2_4_1_1基本类型默认值对照表"><h2 id="2-5-方法、参数和返回值"><a href="#2-5-方法、参数和返回值" class="headerlink" title="2.5 方法、参数和返回值"></a>2.5 方法、参数和返回值</h2><p>与其他编程语言用函数来描述子程序不同，Java使用<strong>方法</strong>来描述“做某些事的方式”（就是属于不一样了而已）。</p><p>方法决定了一个对象能接收什么样的消息。方法的基本组成包括名称、参数、返回值和方法体。</p><p>返回类型是调用方法后从方法返回的值。</p><p>Java的方法只能作为类的一部分来创建，只有通过对象才能被调用。句式是<code>对象名.方法名(参数)</code></p><p>如果对象a下有一个f()方法返回值是int 就可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.f();</span><br></pre></td></tr></table></figure><h3 id="2-5-1-参数列表"><a href="#2-5-1-参数列表" class="headerlink" title="2.5.1 参数列表"></a>2.5.1 参数列表</h3><p>参数列表指定给方法传递的信息。</p><p>方法结束用<code>return</code>表示已经完成 离开此方法，并且可以把方法产生的值放在return后面返回</p><p>如果没有想返回的值，可以修改方法的返回类型为<code>void</code>就不会有返回值，也不用写return</p><h2 id="2-6-构建一个Java程序"><a href="#2-6-构建一个Java程序" class="headerlink" title="2.6 构建一个Java程序"></a>2.6 构建一个Java程序</h2><h3 id="2-6-1-名字可见性"><a href="#2-6-1-名字可见性" class="headerlink" title="2.6.1 名字可见性"></a>2.6.1 名字可见性</h3><p>翻转域名来确保唯一性，其他的包用<code>.</code>划分目录</p><h3 id="2-6-2-运用其他构建"><a href="#2-6-2-运用其他构建" class="headerlink" title="2.6.2 运用其他构建"></a>2.6.2 运用其他构建</h3><p>想导入包，需要先知道包在哪</p><p>比如你想使用ArrayList类 就这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure><p>还想使用<code>java.util</code>下的其他包，又不想一个一个写出来，可以用通配符<code>*</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><h3 id="2-6-3-static-关键字"><a href="#2-6-3-static-关键字" class="headerlink" title="2.6.3 static 关键字"></a>2.6.3 static 关键字</h3><p>创建类时只是在描述这个类有什么字段和方法，只有这个类被new出来的时候才被分配数据存储空间。</p><p>如果只想为某特定区域分配单一存储空间，根本不想创建对象，或者不希望方法与包含的类关联在一起。就是不创建对象也想调用方法的时候，可以使用<code>static</code>关键字。</p><p>当声明一个事物是static时，意味着这个域或者这个方法不会与包含着那个类的任何对象有实际联系。即使从未创建某个类的任何对象，也可以调用他的static方法或者访问他的static域。</p><p>只需要将static关键字放在定义之前，字或者方法就会被设定为static。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticTest</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使你创建了两个StaticTest对象，StaticTest.i也是公用一个存储空间，共享一个i</p><p>如果你修改其中一个i的值，另一个i的值也会一起改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StaticTest</span> <span class="variable">st1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTest</span>();</span><br><span class="line"><span class="type">StaticTest</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticTest</span>();</span><br><span class="line">System.out.println(st1.i);<span class="comment">//47</span></span><br><span class="line">System.out.println(st2.i);<span class="comment">//47</span></span><br><span class="line">st1.i += <span class="number">1</span>;</span><br><span class="line">System.out.println(st1.i);<span class="comment">//48</span></span><br><span class="line">System.out.println(st2.i);<span class="comment">//48</span></span><br><span class="line">st2.i += <span class="number">2</span>;</span><br><span class="line">System.out.println(st1.i);<span class="comment">//50</span></span><br><span class="line">System.out.println(st2.i);<span class="comment">//50</span></span><br></pre></td></tr></table></figure><p>对于static变量，可以直接用类名引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(StaticTest.i);<span class="comment">//50</span></span><br></pre></td></tr></table></figure><p>这种方式也可以定义静态方法，只要在方法前面加上static关键字</p><p>对于static字段来说他的用处可能是共用一个地址一个字段保持数据一致，但是对于static方法来说他的重要用途就是可以直接用类名引用方法，省去一个new。对于main()方法很重要。</p><h2 id="2-7-你的第一个Java程序"><a href="#2-7-你的第一个Java程序" class="headerlink" title="2.7 你的第一个Java程序"></a>2.7 你的第一个Java程序</h2><p>编写一个完整的程序，打印一个字符串，然后打印一个日期（用标准库中的date类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HelloDate.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello,it&#x27;s: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序文件开头要声明import引入额外类（特定类在java.lang下，这些是不用导入的）</p><img src="/2022/08/23/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_7_1java文档.png" alt="2_7_1java文档"><p>而我们所需要打印的日期类（Date）不在java.long下，就需要手动import</p><p>在java.long下 我们还能看见System 这里有有关输出的语法解释</p><img src="/2022/08/23/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_7_2system.png" alt="2_7_2system"><p>类的名字必须和文件名相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloDate</span>&#123;</span><br></pre></td></tr></table></figure><p>类中必须包含一个main()方法，程序会从这里开始运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br></pre></td></tr></table></figure><p>其中public表示这是一个公有的方法，可以由外部调用</p><p>参数是一个String对象的数组</p><p>这个程序没有用到args，但是Java编译器要求要用args来存储命令行参数</p><p>打印日期代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure><p>这里传出来的是一个Date对象，创建完成后他的值就会被自动转换为String类型然后发送给println()。</p><p>这个语句执行完毕后Date对象将不再被使用，Java的垃圾回收器会发现并回收这个对象释放内存。</p><p><strong>system的其他用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ShowProperties.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShowProperties</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.getProperties().list(System.out);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;user.name&quot;</span>));</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.library.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-1-编译和运行"><a href="#2-7-1-编译和运行" class="headerlink" title="2.7.1 编译和运行"></a>2.7.1 编译和运行</h3><p>安装好java环境后 编译代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloDate.java</span><br></pre></td></tr></table></figure><p>然后运行编译后的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java HelloDate</span><br></pre></td></tr></table></figure><h2 id="2-8-注释和嵌入式文档"><a href="#2-8-注释和嵌入式文档" class="headerlink" title="2.8 注释和嵌入式文档"></a>2.8 注释和嵌入式文档</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">阿巴巴巴</span></span><br><span class="line"><span class="comment">阿巴阿巴阿巴</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行阿巴阿巴阿巴</span></span><br></pre></td></tr></table></figure><h3 id="2-8-1-注释文档"><a href="#2-8-1-注释文档" class="headerlink" title="2.8.1 注释文档"></a>2.8.1 注释文档</h3><p>写程序得有文档，如果代码和文档是分离的，那么每次修改代码都得修改相应的文档</p><p>javadoc解决这一问题，可以自动把注释和毗邻的类名和方法名抽取出来输出一个HTML文件</p><h3 id="2-8-2-语法"><a href="#2-8-2-语法" class="headerlink" title="2.8.2 语法"></a>2.8.2 语法</h3><p>所有javadoc的命令都只能在<code>/**</code>中体现（在IDEA中，在接口代码前输入<code>/**</code>回车会自动生成相关格式）</p><img src="/2022/08/23/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_8_2_1自动生成javadoc相关格式.png" alt="2_8_2_1自动生成javadoc相关格式"><p>注意javadoc只能为public（公共）和protected（受保护）两种类型的成员生成文档注释，另外两种类型的注释会被忽略掉。（也只有public和protected的成员能在文件外被使用，这两种类型的文档才有意义）</p><h3 id="2-8-3-嵌入式HTML"><a href="#2-8-3-嵌入式HTML" class="headerlink" title="2.8.3 嵌入式HTML"></a>2.8.3 嵌入式HTML</h3><p>能生成就行了</p><h4 id="2-8-4-一些标签示例"><a href="#2-8-4-一些标签示例" class="headerlink" title="2.8.4 一些标签示例"></a>2.8.4 一些标签示例</h4><p>用的时候再看 在书的85页 PDF的67页</p><p>有作者有时间有版本有输入输出有异常抛出就行</p><h3 id="2-8-5-文档示例"><a href="#2-8-5-文档示例" class="headerlink" title="2.8.5 文档示例"></a>2.8.5 文档示例</h3><p>按照自己喜好来就行啦</p><h2 id="2-9-编码风格"><a href="#2-9-编码风格" class="headerlink" title="2.9 编码风格"></a>2.9 编码风格</h2><p>为了大家看着都舒服而建立的一套规则，一般记得遵守<strong>驼峰命名法</strong>即可，其他的东西可以看《阿里巴巴Java开发手册》</p><h2 id="2-10-总结"><a href="#2-10-总结" class="headerlink" title="2.10 总结"></a>2.10 总结</h2><p>对简单编写的HelloDate有较为深入的了解，知道是怎么回事了。</p><h2 id="2-11-练习"><a href="#2-11-练习" class="headerlink" title="2.11 练习"></a>2.11 练习</h2><img src="/2022/08/23/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/2_11_1练习题目.png" alt="2_11_1练习题目">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2-一切都是对象&quot;&gt;&lt;a href=&quot;#2-一切都是对象&quot; class=&quot;headerlink&quot; title=&quot;2. 一切都是对象&quot;&gt;&lt;/a&gt;2. 一切都是对象&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;“如果我们说另一种不同的语言,那么我们就会发觉一个有些不同的世界。”&lt;br&gt;——Luduing Wittgerstein (1889-1951)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管Java是基于C++的，但是相比之下，Java是一种更“ 纯粹”的面向对象程序设计语言。&lt;/p&gt;</summary>
    
    
    
    <category term="hwcd" scheme="https://www.szjm.online/categories/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/categories/hwcd/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="hwcd" scheme="https://www.szjm.online/tags/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/tags/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>对象导论</title>
    <link href="https://www.szjm.online/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/"/>
    <id>https://www.szjm.online/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</id>
    <published>2022-08-22T10:01:27.000Z</published>
    <updated>2022-08-26T12:55:20.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-对象导论"><a href="#1-对象导论" class="headerlink" title="1. 对象导论"></a>1. 对象导论</h1><blockquote><p>我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来…除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。</p><p>——Benjamin Lee Whorf (1897 ~ 1941)</p></blockquote><p>​        计算机有更多的用途，越来越不像机器，有多种表达方式。<strong>面向对象程序设计(Object-oriented Programming, OOP)便是这种以计算机作为表<br>达媒体的大趋势中的组成部分。</strong><span id="more"></span></p><h2 id="1-1-抽象过程"><a href="#1-1-抽象过程" class="headerlink" title="1.1 抽象过程"></a>1.1 抽象过程</h2><p><strong>所有的编程语言都提供抽象机制。</strong>汇编语言是对底层机器语言的轻微抽象。（把一堆0011编程<code>jump $</code> ?）</p><p>命令语言在汇编的基础上有改进，但是模型需要自己建立，费力，维护代价高，产生了“编程方法”行业。</p><p>另一种对机器建模的方式，只对待解决的问题建模，只针对特定领域。</p><p>面向对象方式通过向程序员提供表示问题空间中的元素的工具而更进一步。这种表示方式非常通用，使得程序员不会受限于任何特定类型的问题。<strong>我们将问题空间中的元素及其在解空间中的表示称为“对象”。</strong>这种思想的实质是：程序可以通过添加新类型的对象使自身适用于某个特定问题。相比以前我们所使用的语言，这是一种更灵活和更强有力的语言抽象。所以，OOP允许<strong>根据问题来描述问题</strong>，而不是根据运行解决方案的计算机来描述问题。</p><p>Alan Kay曾经总结了第一个成功的面向对象语言、同时也是Java所基于的语言之一的Smalltak的五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式：</p><ol><li>万物皆为对象。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件(狗、建筑物、服务等)，将其表示为程序中的对象。</li><li>程序是对象的集合，它们通过发送消息来告知彼此所要做的。要想请求一个对象，就必须对该对象发送一条消息。 更具体地说，可以把消息想像为对某个特定对象的方法的调用请求。</li><li>每个对象都有自己的由其他对象所构成的存储。换句话说，可以通过创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。</li><li>每个对象都拥有其类型。按照通用的说法，“每个对象都是某个类(class) 的一个实例(instance)”，这里“类”就是“类型”的同义词。每个类最重要的区别于其他类的特性就是“可以发送什么样的消息给它”。</li><li>某一特定类型的所有对象都可以接收同样的消息。这是一句意味深长的表述，你在稍后便会看到。因为“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这意味着可以编写与“几何形”交互并自动处理所有与几何形性质相关的事物的代码。这种可替代性(substitutability) 是OOP中最强有力的概念之一。</li></ol><p>Booch对对象提出了一个更加简洁的描述：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据(它们给出了该对象的状态)和方法(它们产生行为),并且每一个对象都可以唯一地与其他对象区分开来，具体说来，就是每一个对象在内存中都有一个唯一的地址。</p><h2 id="1-2-每个对象都有一个接口"><a href="#1-2-每个对象都有一个接口" class="headerlink" title="1.2 每个对象都有一个接口"></a>1.2 每个对象都有一个接口</h2><p>所有的对象都是唯一的， 但同时也是具有相同的特性和行为的对象所归属的类的一部分。</p><p>这种思想被直接应用于第一个面向对象语言Simula-67,它在程序中使用基本关键字class来引入新的类型。<br>Simula是为了开发诸如经典的“ 银行出纳员问题”(bank teller problem)这样的仿真程序而创建的。</p><p>在银行出纳员问题中，有出纳、客户、账户、交易和货币单位等许多“对象”。在程序执行期间具有不同的状态而其他方面都相似的对象会被分组到对象的类中，这就是关键字class的由来。</p><p>创建抽象数据类型(类)是面向对象程序设计的基本概念之一。抽象数据类型的运行方式与内置(built-in) 类型几乎完全一致:你可以创建某一类型的变量(按照面向对象的说法，称其为对象或实例)，然后操作这些变量(称其为发送消息或请求；发送消息，对象就知道要做什么)。每个类的成员或元素都具有某种共性:每个账户都有结余金额，每个出纳都可以处理存款请求等。同时，每个成员都有其自身的状态:每个账户都有不同的结余金额，每个出纳都有自己的姓名。因此，出纳、客户、账户、交易等都可以在计算机程序中被表示成唯一的实体。这些实体就是对象，每一个对象都属于定义了特性和行为的某个特定的类。</p><p>程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。</p><p><strong>可以根据需求，通过添加新的数据类型来扩展编程语言。</strong>编程系统欣然接受新的类，并且像对待内置类型一样地照管它们和进行类型检查。</p><p>一旦类被建立，就可以随心所欲的创建类的任意个对象，然后去操作。</p><p>有用的对象，必须有某种方式产生对对象的请求，使对象完成各种任务。</p><img src="/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_2_1用灯泡来举例.png" alt="1_2_1用灯泡来举例"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Light</span> <span class="variable">lt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">lt.on();</span><br></pre></td></tr></table></figure><p>接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码。这些代码与隐藏的数据一起构成了实现。</p><p>在类型中，每一个可能的请求都有一个方法与之相关联，当向对象发送请求时，与之相关联的方法就会被调用。此过程通常被概括为: <strong>向某个对象“ 发送消息”(产生请求)</strong>,这个对象便知道此消息的目的，然后执行对应的程序代码。</p><h2 id="1-3-每个对象都提供服务"><a href="#1-3-每个对象都提供服务" class="headerlink" title="1.3 每个对象都提供服务"></a>1.3 每个对象都提供服务</h2><p>当正在试图开发或理解-一个程序设计时,最好的方法之一就是将对象想像为“服务提供者”。</p><p>程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这-一目的。你的目标就是去创建(或者最好是在现有代码库中寻找)能够提供理想的服务来解决问题的一系列对象。</p><p>将对象看作是服务提供者还有一个附带的好处:它有助于提高对象的内聚性。</p><p><strong>高内聚</strong>是软件设计的基本质量要求之一：这意味着一个软件构件(例如一个对象，当然它也有可能是指一个方法或一个对象库)的各个方面“组合”得很好。人们在设计对象时所面临的一个问题是，将过多的功能都塞在一个对象中。</p><p>例如，在检查打印模式的模块中，你可以这样设计一个对象，让它了解所有的格式和打印技术。</p><p>你可能会发现，这些功能对于一个对象来说太多了，你需要的是三个甚至更多个对象，其中，一个对象可以是所有可能的支票排版的目录，它可以被用来查询有关如何打印一张支票的信息；另一个对象(或对象集合)可以是一个通用的打印接口，它知道有关所有不同类型的打印机的信息(但是不包含任何有关簿记的内容，它更应该是一个需要购买而不是自己编写的对象) ；第三个对象通过调用另外两个对象的服务来完成打印任务。这样，每个对象都有一个它所能提供服务的内聚的集合。 </p><p>在良好的面向对象设计中，<strong>每个对象都可以很好地完成一项任务，但是它并不试图做更多的事。</strong>就像在这里看到的，不仅允许通过购买获得某些对象(打印机接口对象)，而且还可以创建能够在别处复用的新对象(支票排版目录对象)。</p><h2 id="1-4-被隐藏的具体实现"><a href="#1-4-被隐藏的具体实现" class="headerlink" title="1.4 被隐藏的具体实现"></a>1.4 被隐藏的具体实现</h2><p>将程序开发人员按照角色分为<code>类创建者</code>(那些创建新数据类型的程序员)和<code>客户端程序员</code>(那些在其应用中使用数据类型的类消费者)是大有裨益的。</p><p>客户端程序员的目标是收集各种用来实现快速应用开发的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，而隐藏其他部分。为什么要这样呢？因为如果加以隐藏，那么客户端程序员将不能够访问它，这意味着类创建者可以任意修改被隐藏的部分，而不用担心对其他任何人造成影响。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或不知内情的客户端程序员所毁坏，因此将实现隐藏起来可以减少程序bug。</p><p><strong>访问控制</strong>存在的原因：</p><ol><li>让客户端程序员无法触及他们不应该触及到的部分（客户端程序员能调用就行）</li><li>允许库的设计者可以改变类内部的工作方式而不用担心影响到客户端程序员（将3*3&#x3D;9的计算方式由3+3+3改变成3<code>*</code>3，但是对于客户端程序员来说，他们调用的乘法接口方式没变，结果没变）</li></ol><p>Java用三个关键字在类的内部设定边界:**<code> public</code>**、 **<code>private</code>**、 <strong><code>protected</code><strong>。 这些访问指定词(access specifier) 决定了紧跟其后被定义的东西可以被谁使用。<code>public</code>表示紧随其后的元素对任何人都是可用的，而<code>private</code>这个关键字表示除类型创建者和类型的内部方法之外的任何人都不能访问的元素。<code>private</code>就像你 与客户端程序员之间的一堵砖墙,如果有人试图访问<code>private</code>成员，就会在编译时得到错误信息。<code>protected</code>关键字与<code>private</code>作用相当，差别仅在于继承的类可以访问<code>protected</code>成员，但是不能访问<code>private</code>成员。稍后将会对继承进行介绍。<br>Java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。这种权限通常被称为</strong>包访问权限</strong>，因为在这种权限下，类可以访问在同一个包(库构件)中的其他类的成员，但是在包之外，这些成员如同指定了<code>private</code>一样。</p><h2 id="1-5-复用具体体现"><a href="#1-5-复用具体体现" class="headerlink" title="1.5 复用具体体现"></a>1.5 复用具体体现</h2><p>一旦类被创建并被测试完，那么它就应该(在理想情况下)代表一个有用的代码单元。</p><p>代码复用是面向对象程序设计语言所提供的最了不起的优点之一。</p><p>最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为<strong>创建一个成员对象</strong>。</p><p>新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。因为是在使用现有的类合成新的类，所以这种概念被称为组合composition), 如果组合是动态发生的，那么它通常被称为聚合(aggregation)。 组合经常被视为“has-a” (拥有)关系，就像我们常说的“汽车拥有引擎”一样。</p><p>组合带来了极大的灵活性。新类的成员对象通常都被声明为private,使得使用新类的客户端程序员不能访问它们。这也使得你可以在不干扰现有客户端代码的情况下，修改这些成员。也可以在运行时修改这些成员对象，以实现动态修改程序的行为。</p><h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6 继承"></a>1.6 继承</h2><p>对象这种观念，本身就是十分方便的工具，使得你可以通过概念将数据和功能封装到一起，因此可以对问题空间的观念给出恰当的表示，而不用受制于必须使用底层机器语言。这些概念用关键字class来表示，它们形成了编程语言中的基本单位。</p><p>有其他麻烦：在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。如果我们能够以现有的类为基础，复制它，然后通过添加和修改这个副本来创建新类那就要好多了。通过继承便可以达到这样的效果，不过也有例外，当源类(被称为基类、超类<code>super</code>或父类)发生变动时，被修改的“ 副本”(被称为导出类、继承类或子类)也会反映出这些变动。</p><p>类型不仅仅值是描述了作用于一个对象上的约束条件，同时还有与其他类型之间的关系。</p><p>两个类型可以有相同的特性和行为（属性和方法），但是一个比另一个含有更多的特性，可以处理更多的消息。</p><p>举例： </p><ol><li>垃圾回收机，它用来归类散落的垃圾。“垃圾”是基类型,每一件垃圾都有重量、价值等特性，可以被切碎、熔化或分解。在此基础上，可以通过添加额外的特性(例如瓶子有颜色)或行为(例如铝罐可以被压碎，铁罐可以被磁化)导出更具体的垃圾类型。此外，某些行为可能不同(例如纸的价值取决于其类型和状态)。可以通过使用继承来构建-一个类型层次结构，以此来表示待求解的某种类型的问题。</li><li>几何形。基类是几何形，每一个几何形都具有尺寸、颜色、位置等，同时每一个几何形都可以被绘制、擦除、移动和着色等。在此基础上，可以导出(继承出)具体的几何形状一圆形、 正方形、三角形等每一种都具有额外的特性和行为，例如某些形状可以被翻转。某些行为可能并不相同，例如计算几何形状的面积。类型层次结构同时体现了几何形状之间的相似性和差异性。</li></ol><img src="/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_6_1几何形.png" alt="1_6_1几何形"><p>当继承现有类型时，也就创造了新的类型。这个新的类型不仅包括现有类型的所有成员(尽管private成员被隐藏了起来，并且不可访问)，而且更重要的是它复制了基类的接口。也就是说，<strong>所有可以发送给基类对象的消息同时也可以发送给导出类对象</strong>。由于通过发送给类的消息的类型可知类的类型，所以这也就意味着导出类与基类具有相同的类型。在前面的例子中，“一个圆形也就是一个几何形”。通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛。</p><p>子类和父类有相同的基础接口，伴随接口就会有具体实现的方法。当被调用时，必须有代码去执行。</p><p>如果只是继承了一个类而没有其他操作，那么子类会直接继承父类的方法。这样子类不仅与父类拥有相同的类型，还拥有相同的行为，这样没有特别的意义。</p><p>有两种方法可以使父类和子类产生差异：</p><ol><li><p>直接在子类中写新的方法，这些方法不是父类的。在使用这种方法时，应该考虑父类是否也需要这种方法。</p><img src="/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_6_2新增.png" alt="1_6_2新增"></li><li><p>改变现有父类的方法（覆盖）。此时，虽然使用着相同的方法，但是做的事情不一样。</p><img src="/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_6_3重写.png" alt="1_6_3重写"></li></ol><h3 id="1-6-1-“是一个”与“像是一个”关系"><a href="#1-6-1-“是一个”与“像是一个”关系" class="headerlink" title="1.6.1 “是一个”与“像是一个”关系"></a>1.6.1 “是一个”与“像是一个”关系</h3><ul><li><p><strong>是一个:</strong> 不新增方法 只在原有的方法上进行修改。父类和子类是相同的类型，具有相同的接口，可以用子类对象完全替代父类对象。这被视为<code>纯粹替代</code>，通常称之为<code>替代原则</code>，这是一种理想的继承方式，<code>is-a</code>（是一个）关系。例如“一个<code>圆形</code>是一个<code>几何形状</code>”。<strong>判断是否继承，就是确定是否可以用is-a来描述两个类之间的关系</strong></p></li><li><p><strong>像是一个：</strong>新增方法。有时必须在子类中新增方法扩展接口。这个新的子类仍然可以替代父类，但是这种替代并不完美，因为他有父类没有的新方法。父类也无法访问新添加的方法。这种情况可以描述成<code>is-like-a</code>（像是一个）关系。例如，家里的旧空调（父类）只有调节温度的功能，最近新买的物联网空调（子类）不仅有作为空调的基本的调节温度功能（继承父类的方法），还能接入物联网（新增的方法）。</p></li></ul><h2 id="1-7-伴随多态的可互换对象"><a href="#1-7-伴随多态的可互换对象" class="headerlink" title="1.7 伴随多态的可互换对象"></a>1.7 伴随多态的可互换对象</h2><p>在处理类型的层次结构是，经常把一个对象不当做他所属的特定类型来对待，而是将其作为父类的对象来对待。这样可以编写不依赖特定对象的代码。</p><p>在“几何图形”的例子里，方法操作都是泛化（generic）的形状，不用在意他是方形圆形还是三角形。所有的几何形状都可以执行父类（几何形）的方法，被绘制、擦除、移动。这些方法都是直接对几何形这个父类的，不用担心子类如何处理。</p><p>这样的代码不会受到新增的类型（子类）的影响。例如，新增几何形的子类星型，星型可以完全继承几何形的泛化方法，不用自己重写绘制、擦除、移动这些方法。这能极大地改善我们的设计，同时也能降低软件维护的代价。</p><p>试图将子类的对象当做父类的对象来看待时（把圆看成几何形），仍存在问题。让一个泛化的类执行方法时，比如让一个几何形绘制自己，编译器是不知道应该执行哪一段代码的。调用这种方法时，程序员并不想知道哪一段代码将被执行，他的子类，圆形、正方形、三角形，会根据自己的具体类型来执行恰当的代码。</p><p>编译器无法精确地了解哪一段代码将会被执行，那么改怎么办呢？这是面向程序设计的最重要的东西。</p><p>编译器不能在编译时产生传统意义上的函数调用，一个非面向对象的编译器产生的函数调用会引起所谓的<code>前期绑定</code>，这样编译器将产生对一个具体函数的调用，运行时这个调用会被解析到执行代码的绝对地址。</p><p>然而在OOP中，程序直到运行时才能够确定代码的地址，所以在调用泛化对象的方法时，必须使用其他的机制。</p><p>面向对象设计语言使用了<code>后期绑定</code>的概念。当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查(无法提供此类保证的语言被称为是弱类型的)，但是并不知道将被执行的确切代码。</p><p>为了执行后期绑定，Java使用了一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道对这条消息应该做些什么。</p><p>在某些语言中，必须明确地声明希望某个方法具备后期绑定属性所带来的灵活性。在这些语言中，方法在默认情况下不是动态绑定的。而在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。</p><p>还是用几何形举例。</p><p>父类几何形新增有参函数<code>doSomething</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几何形的子类使用这些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line"><span class="type">Triangle</span> <span class="variable">triangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>();</span><br><span class="line"><span class="type">Line</span> <span class="variable">line</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Line</span>();</span><br><span class="line">doSomething(circle);</span><br><span class="line">doSomething(triangle);</span><br><span class="line">doSomething(line);</span><br></pre></td></tr></table></figure><p>不管是Circle、Triangle还是Line，他们类型的参数都可以使用doSomething方法</p><p>Circle可以被doSomething()看做是Shape，也就是说，doSomething()可以发送给Shape的任何消息，Circle都可以接收。</p><p>把子类看成父类的过程成为<code>向上转型</code>（upcasting）。</p><p>一个面向对象程序肯定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放出来的关键。让我们再看看doSomething()中的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shape.erase();</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure><p>注意这些代码并不是说“ 如果是Circle,请这样做;如果是Square,请那样做…“如果编写了那种检查Shape所有实际可能类型的代码，那么这段代码肯定是杂乱不堪的，而且在每次添加了Shape的新类型之后都要去修改这段代码。这里所要表达的意思仅仅是“你是一个Shape,我知道你可以erase()和draw()你自己，那么去做吧，但是要注意细节的正确性。”<br>doSomething()的代码给人印象深刻之处在于，不知何故，它总是做了该做的。调用Circle的draw()方法所执行的代码与调用Square或Line的draw()方法所执行的代码是不同的，而且当draw(消息被发送给-一个 匿名的Shape时，也会基于该Shape的实际类型产生正确的行为。这相当神奇，因为就像在前面提到的，当Java编译 器在编译doSomething()的代码时，并不能确切知道doSomething()要处理的确切类型。所以通常会期望它的编译结果是调用基类Shape的erase()和draw()版本，而不是具体的Circle、Square或Line的相应版本。正是因为多态才使得事情总是能够被正确处理。编译器和运行系统会处理相关的细节，你需要马上知道的只是事情会发生，更重要的是怎样通过它来设计。当向一个对象发送消息时，即使涉及向上转型，该对象也知道要执行什么样的正确行为。</p><h2 id="1-8-单根继承结构"><a href="#1-8-单根继承结构" class="headerlink" title="1.8 单根继承结构"></a>1.8 单根继承结构</h2><p>在面向对象编程中，自C++面世以来就有一个瞩目的问题，是否所有的类最终都继承自单一的父类。</p><p>在Java中(事实上还包括除C++以外的所有OOP语言)是的，这个终极父类的名字就是<code>Object</code>。事实证明，单根继承结构带来了很多好处。</p><p>在单根继承结构中的所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。另一种(C++所提供的)结构是无法确保所有对象都属于同一个基本类型。从向后兼容的角度看，这么做能够更好地适应C模型，而且受限较少，但是当要进行完全的面向对象程序设计时，则必须构建自己的继承体系，使得它可以提供其他OOP语言内置的便利。并且在所获得的任何新类库中，总会用到一些不兼容的接口，需要花力气(有可能要通过多重继承)来使新接口融入你的设计之中。这么做来换取C++额外的灵活性是否值得呢?如果需要的话一-如果在C上面投资巨大，这么做就很有价值。如果是刚刚从头开始，那么像Java这样的选择通常会有更高的生产率。</p><p>单根继承结构保证所有对象都具备某些功能。因此你知道，在你的系统中你<strong>可以在每个对象上执行某些基本操作</strong>。所有对象都可以很容易地在堆上创建，而参数传递也得到了极大的简化。</p><p>单根继承结构使垃圾回收器的实现变得容易得多，而垃圾回收器正是Java相对C++的重要改进之一。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。</p><p>这对于系统级操作(如异常处理)显得尤其重要，并且给编程带来了更大的灵活性。</p><h2 id="1-9-容器"><a href="#1-9-容器" class="headerlink" title="1.9 容器"></a>1.9 容器</h2><p>如果不知道在解决某个特定问题时需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。如何才能知道需要多少空间来创建这些对象呢?</p><p>答案是不可能知道，因为这类信息只有在运行时才能获得。</p><p>解决方法是：<strong>创建另一种对象类型。</strong></p><p>这种新的对象类型持有对其他对象的引用。当然，你可以用在大多数语言中都有的数组类型来实现相同的功能。但是这个通常被称为容器(也称为集合)的新对象，在任何需要时都可扩充自己以容纳你置于其中的所有东西。因此不需要知道将来会把多少个对象置于容器中，只需要创建一个容器对象，然后让它处理所有细节。</p><h3 id="1-9-1-参数化类型"><a href="#1-9-1-参数化类型" class="headerlink" title="1.9.1 参数化类型"></a>1.9.1 参数化类型</h3><p>在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型: Object。 单根继承结构意味着所有东西都是Object类型，所以可以存储Object的容器可以存储任何东西。这使得容器很容易被复用。</p><p>要使用这样的容器，只需在其中置入对象引用，稍后还可以将它们取回。但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，因此它会丢失其身份。当把它取回时，就获取了一个对Object对象的引用，而不是对置入时的那个类型的对象的引用。</p><p>所以，怎样才能将它变回先前置人容器中时的具有实用接口的对象呢?</p><p>这里再度用到了转型，但这一次不是向继承结构的上层转型为一个更泛化的类型，而是向下转型为更具体的类型。这种转型的方式称为<code>向下转型</code>。我们知道，向上转型是安全的，例如Circle是一种Shape类型；但是不知道某个Object是Circle还是Shape,所以<strong>除非确切知道所要处理的对象的类型，否则向下转型几乎是不安全的。</strong></p><p>向下转型和运行时的检查需要额外的程序运行时间，也需要程序员付出更多的心血。如果有这样一种容器，它<strong>知道自己所保存的对象的类型，从而不需要向下转型</strong>以及消除犯错误的可能，这样不是更有意义吗？</p><p>这种解决方案被称为参数化类型机制。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。例如，通过使用参数化类型，编译器可以定制一个只接纳和取出Shape对象的容器。</p><p>Java SE5的重大变化之一就是增加了<code>参数化类型</code>，在Java中它称为范型。一对尖括号,中间包含类型信息，通过这些特征就可以识别对范型的使用。例如，可以用下面这样的语句来创建一个存储Shape的ArrayList:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Shape&gt;();</span><br></pre></td></tr></table></figure><h2 id="1-10-对象的创建和生命期"><a href="#1-10-对象的创建和生命期" class="headerlink" title="1.10 对象的创建和生命期"></a>1.10 对象的创建和生命期</h2><p>在使用对象时，最关键的问题之一便是它们的生成和销毁方式。</p><p>每个对象为了生存都需要资源，尤其是内存。当我们不再需要一个对象时，它必须被清理掉，使其占有的资源可以被释放和重用。简单的程序中这不是问题，但是不是所有的程序都那么简单。</p><p>例如，一个机场空中交通管理系统。</p><ul><li><strong>简单版：</strong>创建一个容器，保存所有飞机。<ul><li>新增：为每一架进入空中控制区域的飞机新建一个飞机对象，将其至于容器内</li><li>清理： 在飞机离开控制区域时删除相关的飞机对象。</li></ul></li><li><strong>困难版：</strong>小型飞机的飞行计划<ul><li>新增：无论何时，只要有小型飞机对象创建，就要有第二个容器来存放对应的飞行计划</li><li>销毁：何时销毁？？？</li></ul></li></ul><ol><li>C++认为效率控制是最重要的议题，所以给程序员提供了选择的权力。为了追求最大的执行速度，对象的存储空间和生命周期可以在编写程序时确定。这种方式将存储空间分配和释放置于优先考虑的位置，某些情况下这样控制非常有价值。但是，也牺牲了灵活性，因为必须在编写程序时知道对象确切的数量、生命周期和类型。如果试图解决更一般化的问题，例如计算机辅助设计、仓库管理或者空中交通控制，这种方式就显得过于受限了。</li><li>第二种方式是在被称为堆(heap) 的内存池中动态地创建对象。在这种方式中，直到运行时才知道需要多少对象，它们的生命周期如何，以及它们的具体类型是什么。这些问题的答案只能在程序运行时相关代码被执行到的那一刻才能确定。如果需要一个新对象，可以在需要的时刻直接在堆中创建。因为存储空间是在运行时被动态管理的，所以需要大量的时间在堆中分配存储空间，这可能要远远大于在堆栈中创建存储空间的时间。在堆栈中创建存储空间和释放存储空间通常各需要一条汇编指令即可，分别对应将栈顶指针向下移动和将栈顶指针向上移动。创建堆存储空间的时间依赖于存储机制的设计。</li></ol><p>动态方式有这样一个一般性的逻辑假设:对象趋向于变得复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大冲击。</p><p>动态方式所带来的更大的灵活性正是解决一般化编程问题的要点所在。</p><p><strong>Java完全采用了动态内存分配方式。</strong>每当想要创建新对象是，就要使用new关键字来构建此对象的动态实例。</p><p>还有一个问题，就是生命周期。</p><p>对于允许在堆栈上创建对象的语言，编译器可以确定对象存活的时间，并可以自动销毁。</p><p>可是，在堆上创建对象，编译器就会对它的生命周期一无所知。在C++上，必须通过编程方式类确定何时销毁对象，这可能会因为处理不正确导致内存泄露。</p><p>Java中提供了内存回收机制，能自动发现对象何时不再被使用，并继而销毁它。回收机制被设计用来处理内存释放问题，它”知道“对象何时不再被使用，并且自动释放对象占用的内存。</p><p>这是因为所有的对象都继承自单根基类Object以及只能用一种方式创建对象（在堆上创建）这两个特性。</p><h2 id="1-11-异常处理：处理错误"><a href="#1-11-异常处理：处理错误" class="headerlink" title="1.11 异常处理：处理错误"></a>1.11 异常处理：处理错误</h2><p>错误处理始终是最困难的问题之一。</p><p>异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。</p><p>异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。 因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。因为不需要被迫定期检查错误，这往往使得代码编写变得简单。</p><p>此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。</p><p><strong>异常不能被忽略</strong>，所以它保证一定会在某处得到处理。</p><p>Java的异常处理在众多的编程语言中格外引人注目，因为Java一开始就内置了异常处理，而且强制你必须使用它。它是唯一可接受的错误报告方式。如果没有编写正确的处理异常的代码，那么就会得到一条编译时的出错消息。这种有保障的一致性有时会使得错误处理非常容易。</p><h2 id="1-12-并发编程"><a href="#1-12-并发编程" class="headerlink" title="1.12 并发编程"></a>1.12 并发编程</h2><p>在计算机编程中有一个基本概念，就是在同一时刻处理多个任务的思想。</p><p>许多程序设计问题都要求，程序能够停下正在做的工作，转而处理某个其他问题，然后再返回主进程。有许多<br>方法可以实现这个目的。最初，程序员们用所掌握的有关机器底层的知识来编写中断服务程序，主进程的挂起是通过硬件中断来触发的。尽管这么做可以解决问题，但是其难度太大，而且不能移植，所以使得将程序移植到新型号的机器上时，既费时又费力。</p><p>有时中断对于处理时间性强的任务是必需的，但是对于大量的其他问题，我们只是想把问题切分成多个可独立运行的部分(任务)，从而提高程序的响应能力。</p><p>在程序中，这些彼此独立运行的部分称之为线程，上述概念被称为 “并发”。并发最常见的例子就是用户界面。通过使用任务，<strong>用户可以在揿下按钮后快速得到一个响应，而不用被迫等待到程序完成当前任务为止。</strong></p><p>通常，线程只是一种为单一处理器分配执行时间的手段。但是如果操作系统支持多处理器，那么每个任务都可以被指派给不同的处理器，并且它们是在真正地并行执行。在语言级别上，多线程所带来的便利之一便是程序员不用再操心机器上是有多个处理器还是只有一个处理器。</p><p>由于程序在逻辑上被分为线程，所以如果机器拥有多个处理器，那么程序不需要特殊调整也能执行得更快。</p><p>所有这些都使得并发看起来相当简单，但是<strong>有一个隐患：共享资源</strong>。如果有多个并行任务都要访问同一项资源，那么就会出问题。</p><p>例如，两个进程不能同时向一台打印机发送信息。为了解决这个问题，可以共享的资源，例如打印机，必须在使用期间被锁定。因此，整个过程是：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。<br><strong>Java的并发是内置于语言中的</strong>，JavaSE5已经增添了大量额外的库支持。</p><h2 id="1-13-Java与Internet"><a href="#1-13-Java与Internet" class="headerlink" title="1.13 Java与Internet"></a>1.13 Java与Internet</h2><p>为什么Java如此重要？</p><h3 id="1-13-1-Web是什么"><a href="#1-13-1-Web是什么" class="headerlink" title="1.13.1 Web是什么"></a>1.13.1 Web是什么</h3><h4 id="1-客户-x2F-服务器计算技术"><a href="#1-客户-x2F-服务器计算技术" class="headerlink" title="1. 客户&#x2F;服务器计算技术"></a>1. 客户&#x2F;服务器计算技术</h4><p>系统具有一个中央信息存储池(central repository of information)，用来存储某种数据，它通常存在于数据库中，你可以根据需要将它分发给某些人员或机器集群。</p><p>客户&#x2F;服务器概念的关键在于信息存储池的位置集中于中央，这使得它可以被修改，并且这些修改将被传播给信息消费者。总之，信息存储池、用于分发信息的软件以及信息与软件所驻留的机器或机群被总称为服务器。驻留在用户机器上的软件与服务器进行通信，以获取信息、处理信息，然后将它们显示在被称为客户机的用户机器上。</p><p>客户&#x2F;服务器计算技术的基本概念并不复杂。问题在于<strong>你只有单一的服务器，却要同时为多个客户服务。</strong>通常，这会涉及数据库管理系统，因此设计者把数据“均衡”分布于数据表中,以取得最优的使用效果。此外，系统通常允许客户在服务器中插入新的信息。这意味着必须<strong>保证一个客户插入的新数据不会覆盖另一个客户插入的新数据，也不会在将其添加到数据库的过程中丢失(这被称为事务处理)。</strong>如果客户端软件发生变化，那么它必须被重新编译、调试并安装到客户端机器上，事实证明这比想像的要更加复杂与费力。如果想支持多种不同类型的计算机和操作系统，问题将更麻烦。最后还有一个最重要的性能问题:可能在任意时刻都有成百上千的客户向服务器发出请求，所以任何小的延迟都会产生重大影响。为了将延迟最小化，程序员努力减轻处理任务的负载，通常是分散给客户端机器处理，但有时也会使用所谓的中间件将负载分散给在服务器端的其他机器。(中间件也被用来提高可维护性。)</p><h4 id="2-Web就是一台巨型服务器"><a href="#2-Web就是一台巨型服务器" class="headerlink" title="2. Web就是一台巨型服务器"></a>2. Web就是一台巨型服务器</h4><p>在某一时刻怎么连接到一个服务器上与之交互。</p><p>对服务器产生请求，服务器返回文件，本地解读。</p><p>人们希望能直接操作服务器的数据库。</p><p>Web浏览器出现了，一些信息不需要任何修改就可以在任意型号的计算机上显示。但是当时的浏览器不具备显著的交互性，需要编程来实现的任务还需要把信息发到服务器去处理，这样对于程序的排错比较困难。但是因为他只能观察，不能执行任何程序，所以有很高的安全性。</p><p>为了解决这个问题，人们采用了不同的方法。为了解决这个问题，人们采用了各种不同的方法。首先，图形标准得到了增强，使得在浏览器中可以播放质量更好的动画和视频。剩下的问题通过引人在客户端浏览器中运行程序的能<br>力就可以解决。这被称为“客户端编程”。</p><h3 id="1-13-2-客户端编程"><a href="#1-13-2-客户端编程" class="headerlink" title="1.13.2 客户端编程"></a>1.13.2 客户端编程</h3><p>Web最初的“服务器-浏览器”设计是为了提供交互性的内容，但是交互性由服务器提供。</p><p>服务器产生静态界面(HyperText Markup Language，超文本标记语言)，提供给只能解释并显示的客户端浏览器。</p><p>提交动作通过所有的Web服务器都提供的通用网关接口(common gateway interface, CGI) 传递。</p><p>提交内容会告诉CGI应该如何处理它。最常见的动作就是运行一个在服务器中常被命名为“cgi-bin”的目录下的一个程序。(如果网页地址有<code>cgi-bin</code>)几乎所有的语言都可以用来编写这些程序，PerI已经成为最常见的选择，因为它被设计用来处理文本，并且是解释型语言，因此无论服务器的处理器和操作系统如何，它都适于安装。<br>当今许多有影响力的网站完全构建于CGI之上的，实际上你几乎可以通过CGI做任何事。然而，构建于CGI程序之上的网站可能会迅速变得过于复杂而难以维护，并同时产生响应时间过长的问题。CGI程序的响应时间依赖于所必须发送的数据量的大小，以及服务器和Internet的负载。(此外，启动CGI程序也相当慢。) </p><p>你肯定经历过对Web输入表单进行数据验证的过程:你按下网页上的提交按钮，数据被发送回服务器;服务器启动一个CGI程序来检查、发现错误，并将错误组装为一个HTML页面，然后将这个页面发回给你；之后你必须回退一个页面，然后重新再试。这个过程不仅很慢，而且不太优雅。（注册界面有很多项目需要填写，你好不容易全填写晚了，但是最后的验证码过期了导致你注册失败，上面的这些东西你又要全部重新填写）</p><p>解决方法是客户端编程。大多数运行Web浏览器的机器都是能够执行大型任务的强有力的引擎。在使用原始的静态HTML方式的情况下，它们只是闲在那里，等着服务器送来下一个页面。客户端编程意味着Web浏览器能用来执行任何它可以完成的工作，使得返回给用户的结果更加迅捷，而且使得你的网站更加具有交互性。</p><p>客户端编程的问题是：它与通常意义上的编程十分不同，参数几乎相同，而平台却不同。Web浏览器就像一个功能受限的操作系统。 </p><p>最终，你仍然必须编写程序，而且还得处理那些令人头晕眼花的成堆的问题，并以客户端编程的方式来产生解决方案。</p><h4 id="1-插件"><a href="#1-插件" class="headerlink" title="1. 插件"></a>1. 插件</h4><p>客户端编程所迈出的最重要的一步就是插件(plug-in) 的开发。通过这种方式，程序员可以下载一段代码，并将其插入到浏览器中适当的位置，以此来为浏览器舔加新功能。它告诉浏览器：从现在开始，你可以采取这个新行动了**(只需要下载一次插件即可)**。</p><p>某些更快更强大的行为都是通过插件添加到服务器中的。但是编写插件并不是件轻松的事，也不是构建某特定网<br>站的过程中所要做的事情。插件对于客户端编程的价值在于：它允许专家级的程序员不需经过浏览器生产厂商的许可，就可以开发某种语言扩展，并将它们添加到服务器中。因此，插件提供了一个“后门”，使得可以创建新的客户端编程语言(但是并不是所有的客户端编程语言都是以插件的形式实现的)。</p><h4 id="2-脚本语言"><a href="#2-脚本语言" class="headerlink" title="2.脚本语言"></a>2.脚本语言</h4><p>插件引发了浏览器脚本语言(scripting language) 的开发。通过使用某种脚本语言，你可以将客户端程序的源代码直接嵌人到HTML页面中，解释这种语言的插件在HTML页面被显示时自动激活。脚本语言先天就相当易于理解，<strong>因为它们只是作为HTML页面一部分的简单文本，当服务器收到要获取该页面的请求时，它们可以被快速加载。</strong>此方法的缺点是代码会暴露给任何人去浏览(或窃取)。但是，通常不会使用脚本语言去做相当复杂的事情，所以这个缺点并不太严重。</p><p>如果你期望有一种脚本语言在Web浏览器不需要任何插件的情况下就可以得到支持，那它非JavaScript莫属。</p><p>在Web浏览器内部使用的脚本语言实际上总是被用来解决特定类型的问题，主要是用来创建更丰富、更具有交互性的图形化用户界面(graphic user interface, GUI)。但是，脚本语言可以解决客户端编程中所遇到的百分之八十的问题。</p><p>你的问题可能正好落在这百分之八十的范围之内，由于脚本语言提供了更容易、更快捷的开发方式，因此你应该在考虑诸如Java这样的更复杂的解决方案之前，先考虑脚本语言。</p><h4 id="3-Java"><a href="#3-Java" class="headerlink" title="3. Java"></a>3. Java</h4><p>如果脚本语言可以解决客户端编程百分之八十的问题，剩下那百分之二十Java是处理它们最流行的解决方案。</p><p>Java不仅是一种功能强大的、安全的、跨平台的、国际化的编程语言，而且它还在不断地被扩展，以提供更多的语言功能和类库，能够优雅地处理在传统编程语言中很难解决的问题，例如并发、数据库访问、网络编程和分布式计算。Java是通过applet以及使用Java Web Start来进行客户端编程的。</p><p>applet是只在Web浏览器中运行的小程序，它是作为网页的一部分而自动下载的(就像网页中的图片被自动下载一样)。 当applet被激活时，它便开始执行一个程序。</p><p>它提供一种分发软件的方法，一旦用户需要客户端软件时，就自动从服务器把客户端软件分发给用户。用户获取最新版本的客户端软件时不会产生错误，而且也不需要很麻烦的重新安装过程。Java的这种设计方式，使得程序员只需创建单一的程序，而只要一台计算机有浏览器，且浏览器具有内置的Java解释器(大多数的机器都如此),那么这个程序就可以自动在这台计算机上运行。由于Java是一种成熟的编程语言，所以在提出对服务器的请求之前和之后，可以在客户端尽可能多地做些事情。例如，不必跨网络地发送一张请求表单来检查自己是否填写了错误的日期或其他参数，客户端计算机就可以快速地标出错误数据，而不用等待服务器作出标记并给你传回图片。这不仅立即就获得了高速度和快速的响应能力，而且也降低了网络流量和服务器负载，从而不会使整个Internet的速度都慢了下来。</p><h4 id="4-备选方案"><a href="#4-备选方案" class="headerlink" title="4. 备选方案"></a>4. 备选方案</h4><p>好久远的例子</p><h4 id="5-NET和C"><a href="#5-NET和C" class="headerlink" title="5. .NET和C#"></a>5. .NET和C#</h4><p>.net平台大致相当于java虚拟机（JVM）和java类库</p><h4 id="6-Internet与Intranet（企业内部网）"><a href="#6-Internet与Intranet（企业内部网）" class="headerlink" title="6. Internet与Intranet（企业内部网）"></a>6. Internet与Intranet（企业内部网）</h4><p>在公网上需要注意平台兼容性与安全性 在Intranet需要注意代码质量，并且在发现bug后进行修复（？？？）</p><h3 id="1-13-3-服务器端编程"><a href="#1-13-3-服务器端编程" class="headerlink" title="1.13.3 服务器端编程"></a>1.13.3 服务器端编程</h3><p>Java成功的因素之一。</p><p>对服务器提出请求后，一般发送文件之类的浏览器会进行解释。但是更复杂的对于数据库操作的请求会执行一些程序之后返回一个HTML界面给客户端。</p><h2 id="1-14-总结"><a href="#1-14-总结" class="headerlink" title="1.14 总结"></a>1.14 总结</h2><ul><li>要知道过程型语言看起来像什么样子：数据定义和函数调用。</li><li>要通读函数调用和低层概念，以在脑海里建立一个模型。</li></ul><p>这正是我们过程式程序，需要中间表示形式的原因。<br>因为OOP在你能够在过程型语言中找到的概念的基础上，又添加了许多新概念<br>编写良好的Java程序通常比过程型程序要简单得多，而且也易于理解得多。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-对象导论&quot;&gt;&lt;a href=&quot;#1-对象导论&quot; class=&quot;headerlink&quot; title=&quot;1. 对象导论&quot;&gt;&lt;/a&gt;1. 对象导论&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来…除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。&lt;/p&gt;
&lt;p&gt;——Benjamin Lee Whorf (1897 ~ 1941)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​        计算机有更多的用途，越来越不像机器，有多种表达方式。&lt;strong&gt;面向对象程序设计(Object-oriented Programming, OOP)便是这种以计算机作为表&lt;br&gt;达媒体的大趋势中的组成部分。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="hwcd" scheme="https://www.szjm.online/categories/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/categories/hwcd/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
    
    <category term="hwcd" scheme="https://www.szjm.online/tags/hwcd/"/>
    
    <category term="java" scheme="https://www.szjm.online/tags/java/"/>
    
    <category term="学习" scheme="https://www.szjm.online/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java编程思想" scheme="https://www.szjm.online/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>instanceof和类型转换</title>
    <link href="https://www.szjm.online/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://www.szjm.online/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-08-20T15:08:47.000Z</published>
    <updated>2022-08-21T10:39:30.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="instanceof和类型转换"><a href="#instanceof和类型转换" class="headerlink" title="instanceof和类型转换"></a>instanceof和类型转换</h3><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p><code>instanceof</code> 可以判断两个类之间是否存在父子关系<span id="more"></span></p><p>新增Teacher类继承与Person</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类新增指向Student的Object 测试继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Person;</span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Student;</span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/指向Student的Object继承关系.png" alt="指向Student的Object继承关系"><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/此时的继承树.png" alt="此时的继承树"><p>测试指向student的Person和Student</p><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/编译不通过直接爆红.png" alt="编译不通过直接爆红"><p>将这几行注释掉继续运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Person;</span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Student;</span><br><span class="line"><span class="keyword">import</span> com.oop.Demo06.Teacher;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);</span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Student);</span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Person);</span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Teacher);</span><br><span class="line"><span class="comment">//        System.out.println(person instanceof String);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(student <span class="keyword">instanceof</span> Student);</span><br><span class="line">        System.out.println(student <span class="keyword">instanceof</span> Person);</span><br><span class="line">        System.out.println(student <span class="keyword">instanceof</span> Object);</span><br><span class="line"><span class="comment">//        System.out.println(student instanceof Teacher);</span></span><br><span class="line"><span class="comment">//        System.out.println(student instanceof String);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/teacher和student的运行结果.png" alt="teacher和student的运行结果"><ol><li>比如Person X &#x3D; new Student()，我们知道左边Person是引用类型，右边Student是实际类型</li><li>X instanceof Y，然后看X的类型（就是引用类型Person）和Y有没有继承关系，没有就直接报错，有就下一步</li><li>然后判断X的实际类型（就是右边的Student），是不是Y本身或者他的子类，是就true，不是就false</li><li>注意的是实际类型不能是Y的父类，不然就会false</li></ol><p><strong>编译看左边 运行看右边</strong></p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;instanceof和类型转换&quot;&gt;&lt;a href=&quot;#instanceof和类型转换&quot; class=&quot;headerlink&quot; title=&quot;instanceof和类型转换&quot;&gt;&lt;/a&gt;instanceof和类型转换&lt;/h3&gt;&lt;h4 id=&quot;instanceof&quot;&gt;&lt;a href=&quot;#instanceof&quot; class=&quot;headerlink&quot; title=&quot;instanceof&quot;&gt;&lt;/a&gt;instanceof&lt;/h4&gt;&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt; 可以判断两个类之间是否存在父子关系&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>什么是多态</title>
    <link href="https://www.szjm.online/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112_%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81/"/>
    <id>https://www.szjm.online/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112_%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81/</id>
    <published>2022-08-20T15:01:59.000Z</published>
    <updated>2022-08-20T15:07:39.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><ul><li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li><li>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多<span id="more"></span></li><li>多态存在的条件<ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象</li></ul></li><li>注意:多态是方法的多态，属性没有多态性</li><li>instanceof 类型转换（引用类型的转换）</li></ul><h4 id="一个对象的实际类型是确定的"><a href="#一个对象的实际类型是确定的" class="headerlink" title="一个对象的实际类型是确定的"></a>一个对象的实际类型是确定的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><h4 id="可以指向的引用类型就不确定了-父类的引用指向子类"><a href="#可以指向的引用类型就不确定了-父类的引用指向子类" class="headerlink" title="可以指向的引用类型就不确定了 父类的引用指向子类"></a>可以指向的引用类型就不确定了 父类的引用指向子类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><h4 id="当父类有方法时，子类s1和父类s2都可以调用方法"><a href="#当父类有方法时，子类s1和父类s2都可以调用方法" class="headerlink" title="当父类有方法时，子类s1和父类s2都可以调用方法"></a>当父类有方法时，子类s1和父类s2都可以调用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">s2.run();</span><br><span class="line">s1.run();</span><br></pre></td></tr></table></figure><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112_%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81/子类父类调用父类方法.png" alt="子类父类调用父类方法"><h4 id="当子类重写了方法时，子类父类都可以调用这个都有的方法，但是显示的是子类的结果"><a href="#当子类重写了方法时，子类父类都可以调用这个都有的方法，但是显示的是子类的结果" class="headerlink" title="当子类重写了方法时，子类父类都可以调用这个都有的方法，但是显示的是子类的结果"></a>当子类重写了方法时，子类父类都可以调用这个都有的方法，但是显示的是子类的结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112_%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81/子类父类调用子类重写方法.png" alt="子类父类调用子类重写方法"><h4 id="如果这个方法只有子类有-父类无法常规调用"><a href="#如果这个方法只有子类有-父类无法常规调用" class="headerlink" title="如果这个方法只有子类有 父类无法常规调用"></a>如果这个方法只有子类有 父类无法常规调用</h4><ul><li>对象能执行哪些方法，主要看&#x3D;左边是什么类型，和右边关系不大</li><li>子类能调用自己的或者继承父类的方法</li><li>父类可以指向子类，但是不能调用子类独有的方法</li></ul><h4 id="多态注意事项："><a href="#多态注意事项：" class="headerlink" title="多态注意事项："></a>多态注意事项：</h4><ol><li><p>多态是方法的多态，属性没有多态</p></li><li><p>父类和子类需要有联系 不能强转 （类型转换异常 <code>ClassCastException</code>!）</p></li><li><p>多态存在条件：①要有继承关系 ②方法要重写 ③父类引用指向子类对象 <code>Father f1 = new Son();</code></p></li></ol><h4 id="哪些方法不能被重写"><a href="#哪些方法不能被重写" class="headerlink" title="哪些方法不能被重写"></a>哪些方法不能被重写</h4><ol><li><code>static</code> 静态方法 属于类，不属于实例</li><li><code>final</code> 常量</li><li><code>private</code> 私有的 不能重写</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是多态&quot;&gt;&lt;a href=&quot;#什么是多态&quot; class=&quot;headerlink&quot; title=&quot;什么是多态&quot;&gt;&lt;/a&gt;什么是多态&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;即同一方法可以根据发送对象的不同而采用多种不同的行为方式。&lt;/li&gt;
&lt;li&gt;一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>方法重写</title>
    <link href="https://www.szjm.online/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/"/>
    <id>https://www.szjm.online/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/</id>
    <published>2022-08-17T13:52:45.000Z</published>
    <updated>2022-08-17T13:52:47.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>新增A、B两个类，A类继承B类，两类各新增输出不同的test方法<span id="more"></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写都是方法的重写 与属性无关</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.A;</span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.B;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.test();</span><br><span class="line"></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        b.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然都是new的A类 但是两次输出结果不同</p><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/两次输出结果不同.png" alt="两次输出结果不同"><p>父类的引用指向了子类</p><p>用B类新建了A类的对象，把A赋值给了B，这时候B是A，A又继承了B类，向上转型。所以调用B类方法的时候，也就是B&#x3D;&gt;test</p><p>解释一下什么是多态？答：父类的引用可以指向子类的实现</p><p>方法的调用只和左边，定义的数据类型有关</p><h4 id="无static"><a href="#无static" class="headerlink" title="无static"></a>无static</h4><p>A、B两类不使用static</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写都是方法的重写 与属性无关</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="comment">//    public static void test()&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="comment">//    public static void test()&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A=&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时两次的输出结果都是a的</p><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/此时两次的输出结果都是a的.png" alt="此时两次的输出结果都是a的"><p>行数栏上有o标识 表示重写</p><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/重写标识.png" alt="重写标识"><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/快捷重写.png" alt="快捷重写"><img src="/2022/08/17/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111_%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/快捷重写2.png" alt="快捷重写2"><p>即b是A new出来的对象，因此调用了A的方法</p><p>因为静态方法是类的方法，而非静态是对象的方法</p><p>有static时，b调用了B类的方法，因为b是用b类定义的</p><p>没有static时，b调用的是对象的方法，而b是用A类new的</p><p>子类重写了父类的方法</p><p><strong>静态方法只能被继承，不能被重写</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>重写：需要有继承关系 子类重写父类的方法</p><p>​           子类和父类的方法必须一致 方法体不同 </p><ol><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符：范围可以扩大不能缩小  public&gt;protected&gt;default&gt;private</li><li>抛出异常： 范围可以被缩小不能扩大</li></ol><p>为什么需要重写？？？</p><ol><li>父类的功能子类不一定需要或者不一定满足</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;方法重写&quot;&gt;&lt;a href=&quot;#方法重写&quot; class=&quot;headerlink&quot; title=&quot;方法重写&quot;&gt;&lt;/a&gt;方法重写&lt;/h3&gt;&lt;h4 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h4&gt;&lt;p&gt;新增A、B两个类，A类继承B类，两类各新增输出不同的test方法&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Super详解</title>
    <link href="https://www.szjm.online/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.szjm.online/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-08-16T14:29:12.000Z</published>
    <updated>2022-08-16T14:30:04.184Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Super详解"><a href="#Super详解" class="headerlink" title="Super详解"></a>Super详解</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>在父类person中新建一个受保护的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;szjm&quot;</span>;</span><br></pre></td></tr></table></figure><p>在子类Student中新建一个私有类和一个公有方法 输出<code>name</code>、<code>this.name</code>和<code>super.name</code> <span id="more"></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hxd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">    System.out.println(<span class="built_in">super</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类调用<code>student.test</code>查看输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.test(<span class="string">&quot;szjm&quot;</span>);</span><br></pre></td></tr></table></figure><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/三种name输出.png" alt="三种name输出"><ul><li>第一个name是<code>传递的值</code></li><li>第二个name是<code>当前类的值</code></li><li>第三个name是<code>父类的值</code></li></ul><h4 id="公有方法"><a href="#公有方法" class="headerlink" title="公有方法"></a>公有方法</h4><p>在父类person中新建一个公有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类student中新建公有方法和公有test2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    print();</span><br><span class="line">    <span class="built_in">this</span>.print();</span><br><span class="line">    <span class="built_in">super</span>.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类查看输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.test2();</span><br></pre></td></tr></table></figure><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/三种公有方法输出.png" alt="三种公有方法输出"><ul><li><p>print方法中定义了输出的值 所以不需要传递的值</p></li><li><p>第一个方法是<code>当前类</code></p></li><li><p>第二个方法是<code>当前类</code></p></li><li><p>第三个方法是<code>父类</code></p></li></ul><h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>私有方法无法被继承（其实可以继承 只是无法访问）</p><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><p>在父类新增无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person无参执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类新增无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Student无参执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类构造student</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p>执行发现父类的无参构造被执行了</p><p>也就是说在调用子类的时候会执行父类的无参构造</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/调用子类时执行了父类的无参构造.png" alt="调用子类时执行了父类的无参构造"><p>如果子类没有无参构造 也会执行父类的无参构造</p><h4 id="隐藏代码"><a href="#隐藏代码" class="headerlink" title="隐藏代码"></a>隐藏代码</h4><p>其实是在无参构造的时候执行了一句隐藏代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>();</span><br></pre></td></tr></table></figure><p>而且这行代码必须在子类无参构造的第一句</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/必须是构造函数主体的第一条语句.png" alt="必须是构造函数主体的第一条语句"><p>this();也必须是在子类无参构造的第一句，所以父类和子类只能选一个</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110_Super%E8%AF%A6%E8%A7%A3/this也必须是在子类无参构造的第一句.png" alt="this也必须是在子类无参构造的第一句"><h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><p>如果父类使用有参构造，就不能使用无参构造，子类也不能使用无参构造</p><p>父类使用有参构造 子类也能使用有参构造 同时可以调用父类的有参构造</p><p>如果父类使用了有参构造 子类必须有对应的可用的构造函数</p><h4 id="Super注意点："><a href="#Super注意点：" class="headerlink" title="Super注意点："></a>Super注意点：</h4><ol><li>super调用父类的构造方法，必须在构造方法的第一个</li><li>super必须只能出现在子类的方法或者构造方法中！</li><li>super和this 不能同时调用构造方法!</li></ol><h4 id="Super与this对比："><a href="#Super与this对比：" class="headerlink" title="Super与this对比："></a>Super与this对比：</h4><ul><li>代表的对象不同：<ul><li>this：本身调用者这个对象</li><li>super：代表父类对象的应用</li></ul></li><li>前提<ul><li>this：没哟继承也可以使用</li><li>super：只能在继承条件才可以使用</li></ul></li><li>构造方法<ul><li>this()：本类的构造</li><li>super()：父类的构造</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Super详解&quot;&gt;&lt;a href=&quot;#Super详解&quot; class=&quot;headerlink&quot; title=&quot;Super详解&quot;&gt;&lt;/a&gt;Super详解&lt;/h3&gt;&lt;h4 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h4&gt;&lt;p&gt;在父类person中新建一个受保护的类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;szjm&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在子类Student中新建一个私有类和一个公有方法 输出&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;this.name&lt;/code&gt;和&lt;code&gt;super.name&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>什么是继承</title>
    <link href="https://www.szjm.online/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.szjm.online/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/</id>
    <published>2022-08-16T08:14:16.000Z</published>
    <updated>2022-08-16T08:14:27.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><ul><li>继承的本质是对某-批类的抽象，从而实现对现实世界更好的建模。</li><li><strong>extends</strong>的意思是“扩展”。子类是父类的扩展。</li><li><strong>JAVA中类只有单继承，没有多继承！</strong></li><li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li><li>继承关系的俩个类，一个为子类(派生类),一个为父类(基类)。 子类继承父类，,使用关键字<strong>extends</strong>来表示。</li><li>子类和父类之间，从意义上讲应该具有**”is a”**的关系.</li></ul><span id="more"></span><ul><li>object类</li><li>super</li><li>方法重写</li></ul><h4 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student is Person 从person继承，子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    Person person;<span class="comment">//组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父类Person中新建say方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 人 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中调用student类 student类可以直接使用say方法</p><h4 id="子类继承了父类-就会拥有父类的全部方法"><a href="#子类继承了父类-就会拥有父类的全部方法" class="headerlink" title="子类继承了父类 就会拥有父类的全部方法"></a><strong>子类继承了父类 就会拥有父类的全部方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();使用父类的方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不仅是方法-属性也能继承"><a href="#不仅是方法-属性也能继承" class="headerlink" title="不仅是方法 属性也能继承"></a><strong>不仅是方法 属性也能继承</strong></h4><p>父类新增属性money</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 人 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类继承了父类的money属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();</span><br><span class="line"></span><br><span class="line">        System.out.print(student.money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/子类继承了父类的money属性.png" alt="子类继承了父类的money属性"><h4 id="私有类不能被继承"><a href="#私有类不能被继承" class="headerlink" title="私有类不能被继承"></a>私有类不能被继承</h4><p>朕给你的 才是你的</p><p>父类新增属性Emperor 新增方法kill</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 人 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> <span class="string">&quot;Emperor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拖下去斩了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类没有Emperor属性</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/子类没有Emperor属性.png" alt="子类没有Emperor属性"><p>子类不能使用kill方法</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/子类不能使用kill方法.png" alt="子类不能使用kill方法"><h4 id="不建议直接继承属性-可以使用get-set方法（封装）"><a href="#不建议直接继承属性-可以使用get-set方法（封装）" class="headerlink" title="不建议直接继承属性 可以使用get set方法（封装）"></a>不建议直接继承属性 可以使用get set方法（封装）</h4><p>设置money为私有 设置get set两个公有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 人 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> <span class="string">&quot;Emperor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拖下去斩了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以通过set方法更改money 通过get方法查看money</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.demo05.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();</span><br><span class="line"></span><br><span class="line">        System.out.println(student.getMoney());</span><br><span class="line">        student.setMoney(student.getMoney()-<span class="number">500</span>);</span><br><span class="line">        System.out.println(student.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/子类使用getset方法.png" alt="子类使用getset方法"><h4 id="快捷键-Ctrl-H"><a href="#快捷键-Ctrl-H" class="headerlink" title="快捷键 Ctrl+H"></a>快捷键 Ctrl+H</h4><p>在子类的大括号内使用可以查看<strong>继承树</strong></p><ul><li>student继承树</li></ul><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/student继承树.png" alt="student继承树"><ul><li><p>person继承树</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/person继承树.png" alt="person继承树"></li></ul><h3 id="了解Object类"><a href="#了解Object类" class="headerlink" title="了解Object类"></a>了解Object类</h3><p>我们可以看到在person类上面还有一个Object类</p><p>在删除掉person类里的所有方法之后 person仍然可以使用很多方法 这些都是object类的方法</p><img src="/2022/08/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A109_%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF/person仍然可以使用一些方法.png" alt="person仍然可以使用一些方法"><p><strong>在Java中，所有的类都默认直接或者间接继承Object类</strong></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是继承&quot;&gt;&lt;a href=&quot;#什么是继承&quot; class=&quot;headerlink&quot; title=&quot;什么是继承&quot;&gt;&lt;/a&gt;什么是继承&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;继承的本质是对某-批类的抽象，从而实现对现实世界更好的建模。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;extends&lt;/strong&gt;的意思是“扩展”。子类是父类的扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JAVA中类只有单继承，没有多继承！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。&lt;/li&gt;
&lt;li&gt;继承关系的俩个类，一个为子类(派生类),一个为父类(基类)。 子类继承父类，,使用关键字&lt;strong&gt;extends&lt;/strong&gt;来表示。&lt;/li&gt;
&lt;li&gt;子类和父类之间，从意义上讲应该具有**”is a”**的关系.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>登录的实现</title>
    <link href="https://www.szjm.online/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.szjm.online/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-06-05T02:33:23.000Z</published>
    <updated>2022-08-15T12:39:47.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-4-登录"><a href="#1-4-登录" class="headerlink" title="1.4 登录"></a>1.4 登录</h2><h3 id="1-4-1-寻找对应后端"><a href="#1-4-1-寻找对应后端" class="headerlink" title="1.4.1 寻找对应后端"></a>1.4.1 寻找对应后端</h3><h4 id="1-4-1-1-通过开发者工具"><a href="#1-4-1-1-通过开发者工具" class="headerlink" title="1.4.1.1 通过开发者工具"></a>1.4.1.1 通过开发者工具</h4><span id="more"></span><img src="/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/1.4.1.1_1通过开发者工具负载.png"><img src="/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/1.4.1.1_2通过开发者工具标头.png"><img src="/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/1.4.1.1_3通过开发者工具预览.png"><img src="/2022/06/05/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/4.%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0/1.4.1.1_4通过开发者工具cookie.png"><p>分别可以看到</p><ul><li><p>请求地址是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dev-api/login</span><br></pre></td></tr></table></figure></li><li><p>传递的json是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uuid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ac4ccbd519eb4007b603e4c2f22427c5&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>返回的响应是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;操作成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzUxMiJ9.eyJsb2dpbl91c2VyX2tleSI6IjBkYzA5MjAwLTM3YjAtNDQ0My04N2Y1LTU1NDEwMjMzYjY1ZiJ9.F7h_9cWQyFejRpAh4trc8nOQ17jeSStG0g3vNm-SPUY0oQOKuM1fpLnLipKUO58bxUsOy-V7QSJ8ivfp4jIVBg&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>修改了username、rememberMe、password三项cookie</p></li></ul><h4 id="1-4-1-2-查看前端代码"><a href="#1-4-1-2-查看前端代码" class="headerlink" title="1.4.1.2 查看前端代码"></a>1.4.1.2 查看前端代码</h4><p>一共4个表单 分别保存了用户名、密码、验证码答案、记住用户4项，登录按钮是<code>handleLogin</code>方法</p><p>查看<code>handleLogin</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleLogin</span>(<span class="string">&quot;&gt; &#123;</span></span><br><span class="line"><span class="string">  this.$refs.loginForm.validate(valid =&gt; &#123;</span></span><br><span class="line"><span class="string">    if (valid&quot;</span>&gt; &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">rememberMe</span><span class="string">&quot;&gt; &#123;</span></span><br><span class="line"><span class="string">        Cookies.set(&quot;</span>username<span class="string">&quot;, this.loginForm.username, &#123; expires: 30 &#125;&quot;</span>&gt;;</span><br><span class="line">        <span class="title class_">Cookies</span>.<span class="title function_">set</span>(<span class="string">&quot;password&quot;</span>, <span class="title function_">encrypt</span>(<span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">password</span><span class="string">&quot;&gt;, &#123; expires: 30 &#125;&quot;</span>&gt;;</span><br><span class="line">        <span class="title class_">Cookies</span>.<span class="title function_">set</span>(<span class="string">&#x27;rememberMe&#x27;</span>, <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">rememberMe</span>, &#123; <span class="attr">expires</span>: <span class="number">30</span> &#125;<span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">      &#125; else &#123;</span></span><br><span class="line"><span class="string">        Cookies.remove(&quot;</span>username<span class="string">&quot;&quot;</span>&gt;;</span><br><span class="line">        <span class="title class_">Cookies</span>.<span class="title function_">remove</span>(<span class="string">&quot;password&quot;</span><span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">        Cookies.remove(&#x27;rememberMe&#x27;&quot;</span>&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;Login&quot;</span>, <span class="variable language_">this</span>.<span class="property">loginForm</span><span class="string">&quot;&gt;.then((&quot;</span>&gt; =&gt; &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="variable language_">this</span>.<span class="property">redirect</span> || <span class="string">&quot;/&quot;</span> &#125;<span class="string">&quot;&gt;.catch((&quot;</span>&gt;=&gt;&#123;&#125;<span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">      &#125;&quot;</span>&gt;.<span class="title function_">catch</span>((<span class="string">&quot;&gt; =&gt; &#123;</span></span><br><span class="line"><span class="string">        this.loading = false;</span></span><br><span class="line"><span class="string">        if (this.captchaOnOff&quot;</span>&gt; &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">getCode</span>(<span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;&quot;</span>&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="string">&quot;&gt;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>记住用户</p><p>  判断是否勾选了记住用户</p><p>  如果是 保存用户名、密码、记住用户到cookie30天</p><p>  如果没有 从cookie清除这三项</p></li><li><p>登录方法</p><p>  ![1.4.1.2_1查看login方法1](4.登录的实现&#x2F;1.4.1.2_1查看login方法1.png”&gt;</p><p>  ![1.4.1.2_2查看login方法2](4.登录的实现&#x2F;1.4.1.2_2查看login方法2.png”&gt;</p><p>  ![1.4.1.2_3查看login方法3](4.登录的实现&#x2F;1.4.1.2_3查看login方法3.png”&gt;</p><p>  就是把这四项打包成json传到<code>/login</code>方法</p></li></ul><h4 id="1-4-1-3-查看后端代码"><a href="#1-4-1-3-查看后端代码" class="headerlink" title="1.4.1.3 查看后端代码"></a>1.4.1.3 查看后端代码</h4><ul><li><p>找到后端代码</p><p>还是使用在文件中查找的方式搜索<code>/login</code> (Ctrl+Shift+F”&gt;</p><p>![1.4.1.3_1在文件中查找login](4.登录的实现&#x2F;1.4.1.3_1在文件中查找login.png”&gt;</p></li><li><p>打断点确认</p><p>![1.4.1.3_2打断点确认](4.登录的实现&#x2F;1.4.1.3_2打断点确认.png”&gt;</p><p>可以看到<code>loginBody</code>的值</p></li><li><p>判断是否登录成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> loginService.login(loginBody.getUsername(<span class="string">&quot;&gt;, loginBody.getPassword(&quot;</span>&gt;, loginBody.getCode(<span class="string">&quot;&gt;,loginBody.getUuid(&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span><br></pre></td></tr></table></figure><p>通过一个<code>loginService.login</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password, String code, String uuid<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">&#123;</span></span></span><br><span class="line"><span class="string"><span class="params">    boolean captchaOnOff = configService.selectCaptchaOnOff(&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    // 验证码开关</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (captchaOnOff<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="params">        validateCaptcha(username, code, uuid&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    // 用户验证</span></span><br><span class="line"><span class="params">    Authentication authentication = <span class="literal">null</span>;</span></span><br><span class="line"><span class="params">    <span class="keyword">try</span></span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">        // 该方法会去调用UserDetailsServiceImpl.loadUserByUsername</span></span><br><span class="line"><span class="params">        authentication = authenticationManager</span></span><br><span class="line"><span class="params">            .authenticate(new UsernamePasswordAuthenticationToken(username, password<span class="string">&quot;&gt;&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">catch</span> (Exception e<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="params">        if (e instanceof BadCredentialsException&quot;</span>&gt;</span></span><br><span class="line"><span class="params">        &#123;</span></span><br><span class="line"><span class="params">            AsyncManager.me(<span class="string">&quot;&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, MessageUtils.message(&quot;</span>user.password.not.match<span class="string">&quot;&quot;</span>&gt;<span class="string">&quot;&gt;&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">            throw new UserPasswordNotMatchException(<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="params">        else</span></span></span><br><span class="line"><span class="string"><span class="params">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="params">            AsyncManager.me(&quot;</span>&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, e.getMessage(<span class="string">&quot;&gt;&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">            throw new ServiceException(e.getMessage(&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="params">    AsyncManager.me(&quot;</span>&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_SUCCESS, MessageUtils.message(<span class="string">&quot;user.login.success&quot;</span><span class="string">&quot;&gt;&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    LoginUser loginUser = (LoginUser&quot;</span>&gt; authentication.getPrincipal(<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    recordLoginInfo(loginUser.getUserId(&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    // 生成token</span></span></span><br><span class="line"><span class="string"><span class="params">    return tokenService.createToken(loginUser&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>首先判断验证码验证是否开启，如果开启去验证验证码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateCaptcha</span><span class="params">(String username, String code, String uuid<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">&#123;</span></span></span><br><span class="line"><span class="string"><span class="params">    String verifyKey = Constants.CAPTCHA_CODE_KEY + StringUtils.nvl(uuid, &quot;</span><span class="string">&quot;&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    String captcha = redisCache.getCacheObject(verifyKey<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    redisCache.deleteObject(verifyKey&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (captcha == <span class="literal">null</span><span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="params">        AsyncManager.me(&quot;</span>&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, MessageUtils.message(<span class="string">&quot;user.jcaptcha.expire&quot;</span><span class="string">&quot;&gt;&quot;</span>&gt;<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">        throw new CaptchaExpireException(&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (!code.equalsIgnoreCase(captcha<span class="string">&quot;&gt;&quot;</span>&gt;</span></span><br><span class="line"><span class="params">    &#123;</span></span><br><span class="line"><span class="params">        AsyncManager.me(<span class="string">&quot;&gt;.execute(AsyncFactory.recordLogininfor(username, Constants.LOGIN_FAIL, MessageUtils.message(&quot;</span>user.jcaptcha.error<span class="string">&quot;&quot;</span>&gt;<span class="string">&quot;&gt;&quot;</span>&gt;;</span></span><br><span class="line"><span class="params">        throw new CaptchaException(<span class="string">&quot;&gt;;</span></span></span><br><span class="line"><span class="string"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>  用固定字段<code>captcha_codes:</code>和<code>uuid</code>生成key</p><p>  从redis获取验证码答案</p><p>  删除答案</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-4-登录&quot;&gt;&lt;a href=&quot;#1-4-登录&quot; class=&quot;headerlink&quot; title=&quot;1.4 登录&quot;&gt;&lt;/a&gt;1.4 登录&lt;/h2&gt;&lt;h3 id=&quot;1-4-1-寻找对应后端&quot;&gt;&lt;a href=&quot;#1-4-1-寻找对应后端&quot; class=&quot;headerlink&quot; title=&quot;1.4.1 寻找对应后端&quot;&gt;&lt;/a&gt;1.4.1 寻找对应后端&lt;/h3&gt;&lt;h4 id=&quot;1-4-1-1-通过开发者工具&quot;&gt;&lt;a href=&quot;#1-4-1-1-通过开发者工具&quot; class=&quot;headerlink&quot; title=&quot;1.4.1.1 通过开发者工具&quot;&gt;&lt;/a&gt;1.4.1.1 通过开发者工具&lt;/h4&gt;</summary>
    
    
    
    <category term="楠哥" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="开源项目学习" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="若依前后端分离版" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/%E8%8B%A5%E4%BE%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="若依" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="楠哥" scheme="https://www.szjm.online/tags/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="若依" scheme="https://www.szjm.online/tags/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>验证码的后端实现</title>
    <link href="https://www.szjm.online/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.szjm.online/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-06-04T13:34:57.000Z</published>
    <updated>2022-08-15T12:40:51.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-3-1-2-查看Java代码"><a href="#1-3-1-2-查看Java代码" class="headerlink" title="1.3.1.2 查看Java代码"></a>1.3.1.2 查看Java代码</h4><ul><li><p>找到后端代码<span id="more"></span></p><ol><li>后端一共6个模块 其中<code>ruoyi-admin</code>是主要模块 也就是我们启动的模块<img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_1一共6个模块.png"></li><li>现在对于后端的代码还是不了解的，我们使用IDEA的工具搜索</li><li>搜索接口名称<code>captchaImage</code><ol><li>在包名<code>ruoyi-admin</code>上右击 选择<code>在文件中查找</code><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_2选择在文件中查找.png"></li><li>输入接口名<code>captchaImage</code></li><li>发现在<code>CaptchaController</code>的44行</li><li>双击定位到代码位置<img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_3查询功能的使用.png"></li></ol></li></ol></li><li><p>打断点验证</p><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_4打上断点.png"><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_5验证码加载失败.png"><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_6后端检测到断点响应.png"><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_7取消断点后响应成功.png"></li><li><p>分析后端代码</p><ol><li><p>大类前面没有接口注解 保证访问的是我们需要的接口<img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_8没有接口注解.png"></p></li><li><p>创建<code>AjaxResult</code>类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AjaxResult</span> <span class="variable">ajax</span> <span class="operator">=</span> AjaxResult.success();</span><br></pre></td></tr></table></figure><p>  一层一层点下去</p>  <img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_9Ajax_1.png">  <img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_10Ajax_2.png">  <img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_11Ajax_3.png">  <img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_12Ajax_4.png"></li><li><p>判断验证是否开启</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">captchaOnOff</span> <span class="operator">=</span> configService.selectCaptchaOnOff();</span><br><span class="line">ajax.put(<span class="string">&quot;captchaOnOff&quot;</span>, captchaOnOff);</span><br><span class="line"><span class="keyword">if</span> (!captchaOnOff)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ajax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果没有开启 直接return结束</p></li><li><p>保存验证码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存验证码信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> IdUtils.simpleUUID();</span><br><span class="line"><span class="type">String</span> <span class="variable">verifyKey</span> <span class="operator">=</span> Constants.CAPTCHA_CODE_KEY + uuid;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">capStr</span> <span class="operator">=</span> <span class="literal">null</span>, code = <span class="literal">null</span>;</span><br><span class="line"><span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_13CAPTCHA_CODE_KEY.png"><p>生成UUID，将CAPTCHA_CODE_KEY与UUID拼成新字符串作为Redis的key</p><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_14生成的key.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisCache.setCacheObject(verifyKey, code, Constants.CAPTCHA_EXPIRATION, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure><p><code>verifyKey</code> captcha_codes： + 生成的UUID</p><p><code>code</code> 刚才那道算术题的答案</p><p><code>Constants.CAPTCHA_EXPIRATION</code> 值为2 就是有效期2分钟</p><img src="/2022/06/04/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/3.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.2_15存储到redis.png"></li><li><p>将验证码保存为图片</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换流信息写出</span></span><br><span class="line"><span class="type">FastByteArrayOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ImageIO.write(image, <span class="string">&quot;jpg&quot;</span>, os);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AjaxResult.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  转换成jpg格式的图片</p></li><li><p>传给前端</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax.put(<span class="string">&quot;uuid&quot;</span>, uuid);</span><br><span class="line">ajax.put(<span class="string">&quot;img&quot;</span>, Base64.encode(os.toByteArray()));</span><br><span class="line"><span class="keyword">return</span> ajax;</span><br></pre></td></tr></table></figure><p>  将<em>UUID</em>也就是key值和生成的<em>图片</em>传给前端</p></li></ol></li></ul><h4 id="1-3-1-3-综合"><a href="#1-3-1-3-综合" class="headerlink" title="1.3.1.3 综合"></a>1.3.1.3 综合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getCode</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">getCodeImg</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">captchaOnOff</span> = res.<span class="property">captchaOnOff</span> === <span class="literal">undefined</span> ? <span class="literal">true</span> : res.<span class="property">captchaOnOff</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">captchaOnOff</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">codeUrl</span> = <span class="string">&quot;data:image/gif;base64,&quot;</span> + res.<span class="property">img</span>;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">uuid</span> = res.<span class="property">uuid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><ul><li>访问<code>captchaImage</code>接口 判</li><li>断返回的<code>captchaOnOff</code>是否为空 如果为空赋值为true，如果不为空赋值后端返回的值</li><li>如果<code>this.captchaOnOff</code>为真执行后续操作</li><li>后端返回的图片赋值给<code>this.codeUrl</code></li><li>后端返回的UUID赋值给<code> this.loginForm.uuid</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-3-1-2-查看Java代码&quot;&gt;&lt;a href=&quot;#1-3-1-2-查看Java代码&quot; class=&quot;headerlink&quot; title=&quot;1.3.1.2 查看Java代码&quot;&gt;&lt;/a&gt;1.3.1.2 查看Java代码&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;找到后端代码&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="楠哥" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="开源项目学习" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="若依前后端分离版" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/%E8%8B%A5%E4%BE%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="若依" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="楠哥" scheme="https://www.szjm.online/tags/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="若依" scheme="https://www.szjm.online/tags/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>验证码的前端实现</title>
    <link href="https://www.szjm.online/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.szjm.online/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-06-03T03:32:42.000Z</published>
    <updated>2022-08-15T02:46:10.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-3-验证"><a href="#1-3-验证" class="headerlink" title="1.3 验证"></a>1.3 验证</h2><h3 id="1-3-1-生成验证码"><a href="#1-3-1-生成验证码" class="headerlink" title="1.3.1 生成验证码"></a>1.3.1 生成验证码</h3><blockquote><p>基本思路</p></blockquote><ol><li>后端生成一个表达式，1+1&#x3D;2 写成1+1&#x3D;?@2</li><li>其中1+1&#x3D;?转换成图片验证码传到前端</li><li>答案2存入Redis</li><li>前端登录时 将输入框里的内容与Redis进行比对<span id="more"></span><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1_1Redis存储验证码答案.png"></li><li>如果修改Redis里的答案 即使验证码的答案与题目不一致 但是与Redis一致 也能成功登录</li></ol><h4 id="1-3-1-1-查看vue代码-ruoyi-ui-src-views-login-vue"><a href="#1-3-1-1-查看vue代码-ruoyi-ui-src-views-login-vue" class="headerlink" title="1.3.1.1 查看vue代码 ruoyi-ui/src/views/login.vue"></a>1.3.1.1 查看vue代码 <code>ruoyi-ui/src/views/login.vue</code></h4><ul><li><p>验证码是怎么展示的</p><ol><li>验证码应该是在初始化的时候加载的<img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_1初始化的方法.png"></li><li>看名字猜测是getCode<img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_2验证码的展示.png"></li><li>如果访问接口成功 获取图片的地址到<code>this.codeUrl</code>用来展示验证码图片 获取Redis的key值到<code>this.loginForm.uuid</code>用于验证码答案比对</li></ol></li><li><p>前端是怎么调用接口的</p><ol><li>追踪<code>getCodeImg()</code>，显示是从<code>@/api/login</code>引入的<img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_3追踪getCodeImg()1.png"> <img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_4追踪getCodeImg()2.png"></li><li>追踪<code>@/api/login</code>的<code>getCodeImg()</code>，注释表明是这个方法获取的验证码<img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_5注释写明是这个方法.png"><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_6与控制台的请求名称相同.png"></li><li>深入了解发现<code>request()</code>指向<code>@/utils/request</code><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_7追踪request()1.png"><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_8追踪request()2.png"></li><li>查看<code>@/utils/request</code>的<code>request()</code>，看到了<code>axios</code><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_9发现axios.png"><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_10接口注释对应1.png"><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_11接口注释对应2.png"></li></ol></li><li><p><code>Vue</code>的获取图片的请求到底是前端还是后端</p><p>我们看到vue获取验证码图片的地址是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dev-api/captchaImage</span><br></pre></td></tr></table></figure><p><strong>localhost后面没有跟端口号，也就是默认的80端口。而80是前端的端口号，后端的端口号是8080。</strong></p><p>反向代理 URL请求前端，进行代理，把前端映射到后端，解决跨域问题<br>前端还是在请求前端，所以没有跨越问题，代理将对于前端的请求转发到后端，完成请求</p></li><li><p>代理是在哪里做的</p><img src="/2022/06/03/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/2.%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0/1.3.1.1_12前端反向代理代码.png"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxy</span>: &#123;</span><br><span class="line">  <span class="comment">// detail: https://cli.vuejs.org/config/#devserver-proxy</span></span><br><span class="line">  [process.<span class="property">env</span>.<span class="property">VUE_APP_BASE_API</span>]: &#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="string">`http://localhost:8080`</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">      [<span class="string">&#x27;^&#x27;</span> + process.<span class="property">env</span>.<span class="property">VUE_APP_BASE_API</span>]: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong><code>pathRewrite</code> 路径重写</strong></p><p>将VUE_APP_BASE_API的<code>/dev-api</code> 替换成<code>&#39;&#39;</code> 再映射到 <code>http://localhost:8080</code></p><p><a href="http://localhost/dev-api/captchaImage">http://localhost/dev-api/captchaImage</a> 变成 <a href="http://localhost:8080/captchaImage">http://localhost:8080/captchaImage</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-3-验证&quot;&gt;&lt;a href=&quot;#1-3-验证&quot; class=&quot;headerlink&quot; title=&quot;1.3 验证&quot;&gt;&lt;/a&gt;1.3 验证&lt;/h2&gt;&lt;h3 id=&quot;1-3-1-生成验证码&quot;&gt;&lt;a href=&quot;#1-3-1-生成验证码&quot; class=&quot;headerlink&quot; title=&quot;1.3.1 生成验证码&quot;&gt;&lt;/a&gt;1.3.1 生成验证码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;基本思路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;后端生成一个表达式，1+1&amp;#x3D;2 写成1+1&amp;#x3D;?@2&lt;/li&gt;
&lt;li&gt;其中1+1&amp;#x3D;?转换成图片验证码传到前端&lt;/li&gt;
&lt;li&gt;答案2存入Redis&lt;/li&gt;
&lt;li&gt;前端登录时 将输入框里的内容与Redis进行比对&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="楠哥" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="开源项目学习" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="若依前后端分离版" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/%E8%8B%A5%E4%BE%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="若依" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="楠哥" scheme="https://www.szjm.online/tags/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="若依" scheme="https://www.szjm.online/tags/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>运行若依项目</title>
    <link href="https://www.szjm.online/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.szjm.online/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-05-21T10:18:48.000Z</published>
    <updated>2022-08-15T11:23:08.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-若依（前后端分离版）"><a href="#1-若依（前后端分离版）" class="headerlink" title="1. 若依（前后端分离版）"></a>1. 若依（前后端分离版）</h1><h2 id="1-1-什么是若依？"><a href="#1-1-什么是若依？" class="headerlink" title="1.1 什么是若依？"></a>1.1 什么是若依？</h2><p>开源项目 在此基础上二次开发</p><ul><li>学习开源项目的目标：</li></ul><ol><li>直接用，减少自己的工作量</li><li>学习优秀开源项目底层的编程思想，设计思路，提高自己的编程能力</li></ol><ul><li>官网： <a href="http://www.ruoyi.vip/">RuoYi 若依官方网站</a><span id="more"></span></li><li>基础：SpringBoot + Vue</li><li>环境要求：<ol><li>JDK1.8+</li><li>MySQL</li><li>Redis</li><li>Maven</li><li>Vue</li></ol></li></ul><h2 id="1-2-使用若依"><a href="#1-2-使用若依" class="headerlink" title="1.2 使用若依"></a>1.2 使用若依</h2><p>使用开源项目的步骤：</p><ol><li><p>下载并运行</p></li><li><p>看懂业务流程</p></li><li><p>进行二次开发</p></li></ol><h3 id="1-2-1-下载"><a href="#1-2-1-下载" class="headerlink" title="1.2.1 下载"></a>1.2.1 下载</h3><p>若依的项目托管与Gitee，直接从gitee上<code>git clone</code>即可</p><h3 id="1-2-2-配置数据库MySQL、Redis"><a href="#1-2-2-配置数据库MySQL、Redis" class="headerlink" title="1.2.2 配置数据库MySQL、Redis"></a>1.2.2 配置数据库MySQL、Redis</h3><ul><li><p>MySQL</p><ol><li>创建数据库<code>ry-vue</code>并导入数据脚本<code>ry_2021xxxx.sql</code>，<code>quartz.sql</code></li><li>在<code>ruoyi-admin/src/main/resources/application-druid.yml</code>中配置数据库连接</li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.2_1配置数据库连接.png"></li></ol></li><li><p>Redis</p><ol><li>在<code>ruoyi-admin/src/main/resources/application.yml</code>中配置Redis连接</li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.2_2配置Redis连接.png"></li></ol></li></ul><h2 id="1-2-3-运行后端"><a href="#1-2-3-运行后端" class="headerlink" title="1.2.3 运行后端"></a>1.2.3 运行后端</h2><ol><li>运行<code>ruoyi-admin/src/main/java/com/ruoyi/RuoYiApplication.java</code></li><li>启动成功</li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.3_1启动成功.png"></li><li>浏览器访问成功</li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.3_2浏览器访问成功.png"></li></ol><h3 id="1-2-4-运行前端"><a href="#1-2-4-运行前端" class="headerlink" title="1.2.4 运行前端"></a>1.2.4 运行前端</h3><ol><li><p>安装依赖环境 </p></li><li><pre><code class="powershell">npm install --registry=https://registry.npmmirror.com<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">3. 启动服务</span><br><span class="line"></span><br><span class="line">4. ```powershell</span><br><span class="line">   npm run dev</span><br></pre></td></tr></table></figure></code></pre></li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.4_1前端启动成功.png"></li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.4_2浏览器访问成功.png"></li><li><img src="/2022/05/21/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBVue/1.%E8%BF%90%E8%A1%8C%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE/1.2.4_3成功进入系统.png"></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-若依（前后端分离版）&quot;&gt;&lt;a href=&quot;#1-若依（前后端分离版）&quot; class=&quot;headerlink&quot; title=&quot;1. 若依（前后端分离版）&quot;&gt;&lt;/a&gt;1. 若依（前后端分离版）&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是若依？&quot;&gt;&lt;a href=&quot;#1-1-什么是若依？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是若依？&quot;&gt;&lt;/a&gt;1.1 什么是若依？&lt;/h2&gt;&lt;p&gt;开源项目 在此基础上二次开发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习开源项目的目标：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;直接用，减少自己的工作量&lt;/li&gt;
&lt;li&gt;学习优秀开源项目底层的编程思想，设计思路，提高自己的编程能力&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;官网： &lt;a href=&quot;http://www.ruoyi.vip/&quot;&gt;RuoYi 若依官方网站&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="楠哥" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="开源项目学习" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="若依前后端分离版" scheme="https://www.szjm.online/categories/%E6%A5%A0%E5%93%A5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/%E8%8B%A5%E4%BE%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%89%88/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="若依" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E8%8B%A5%E4%BE%9D/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="楠哥" scheme="https://www.szjm.online/tags/%E6%A5%A0%E5%93%A5/"/>
    
    <category term="若依" scheme="https://www.szjm.online/tags/%E8%8B%A5%E4%BE%9D/"/>
    
    <category term="前后端分离" scheme="https://www.szjm.online/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>语音播报</title>
    <link href="https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5/"/>
    <id>https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5/</id>
    <published>2022-05-09T03:33:22.000Z</published>
    <updated>2022-08-15T12:46:31.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语音播报"><a href="#语音播报" class="headerlink" title="语音播报"></a>语音播报</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><p>Python  3.10.4<span id="more"></span></p><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5/Python版本.png"></li><li><p>库</p><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5/pip库.png"></li></ul><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p><a href="https://blog.csdn.net/qq_41185868/article/details/84946859">Py之pyttsx：pyttsx&#x2F;pyttsx3的简介、安装、使用方法之详细攻略</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工具模块</span></span><br><span class="line"><span class="keyword">import</span> pyttsx3 <span class="comment">#导入</span></span><br><span class="line"><span class="comment">#创建  初始化</span></span><br><span class="line">engine = pyttsx3.init()</span><br><span class="line"><span class="comment">#说话</span></span><br><span class="line">engine.say(<span class="string">&#x27;经过广州&#x27;</span>)</span><br><span class="line"><span class="comment">#运行</span></span><br><span class="line">engine.runAndWait()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;语音播报&quot;&gt;&lt;a href=&quot;#语音播报&quot; class=&quot;headerlink&quot; title=&quot;语音播报&quot;&gt;&lt;/a&gt;语音播报&lt;/h2&gt;&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Python  3.10.4&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.szjm.online/categories/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/categories/Python/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Python" scheme="https://www.szjm.online/tags/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>运动抓拍</title>
    <link href="https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/"/>
    <id>https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/</id>
    <published>2022-05-09T03:31:47.000Z</published>
    <updated>2022-08-15T14:45:34.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运动抓拍"><a href="#运动抓拍" class="headerlink" title="运动抓拍"></a>运动抓拍</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Python  3.10.4<span id="more"></span><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/Python版本.png"></li><li>库<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/pip库.png"></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 保存截图地址</span></span><br><span class="line">save_path = <span class="string">&#x27;E:\\0\\autoimg\\&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义摄像头对象，其参数0表示第一个摄像头</span></span><br><span class="line">camera = cv2.VideoCapture(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># camera = cv2.VideoCapture(0)</span></span><br><span class="line"><span class="comment"># camera = cv2.VideoCapture(0, cv2.CAP_DSHOW)</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 判断视频是否打开</span></span><br><span class="line"><span class="keyword">if</span> (camera.isOpened()):</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;Open&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;摄像头未打开&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 测试用,查看视频size</span></span><br><span class="line">size = (<span class="built_in">int</span>(camera.get(cv2.CAP_PROP_FRAME_WIDTH)),</span><br><span class="line">  <span class="built_in">int</span>(camera.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;size:&#x27;</span>+<span class="built_in">repr</span>(size))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 帧率</span></span><br><span class="line">fps = <span class="number">30</span></span><br><span class="line"><span class="comment"># 总是取前一帧做为背景（不用考虑环境影响）</span></span><br><span class="line">pre_frame = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line"> start = time.time()</span><br><span class="line"> <span class="comment"># 读取视频流</span></span><br><span class="line"> ret, frame = camera.read()</span><br><span class="line"> <span class="comment"># 转灰度图</span></span><br><span class="line"> gray_lwpCV = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line"> end = time.time()</span><br><span class="line"> </span><br><span class="line"> cv2.imshow(<span class="string">&quot;capture&quot;</span>, frame)</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 运动检测部分</span></span><br><span class="line"> seconds = end - start</span><br><span class="line"> <span class="keyword">if</span> seconds &lt; <span class="number">1.0</span> / fps:</span><br><span class="line">  time.sleep(<span class="number">1.0</span> / fps - seconds)</span><br><span class="line"> gray_lwpCV = cv2.resize(gray_lwpCV, (<span class="number">500</span>, <span class="number">500</span>))</span><br><span class="line"> <span class="comment"># 用高斯滤波进行模糊处理</span></span><br><span class="line"> gray_lwpCV = cv2.GaussianBlur(gray_lwpCV, (<span class="number">21</span>, <span class="number">21</span>), <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 如果没有背景图像就将当前帧当作背景图片</span></span><br><span class="line"> <span class="keyword">if</span> pre_frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">  pre_frame = gray_lwpCV</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">  <span class="comment"># absdiff把两幅图的差的绝对值输出到另一幅图上面来</span></span><br><span class="line">  img_delta = cv2.absdiff(pre_frame, gray_lwpCV)</span><br><span class="line">  <span class="comment">#threshold阈值函数(原图像应该是灰度图,对像素值进行分类的阈值,当像素值高于（有时是小于）阈值时应该被赋予的新的像素值,阈值方法)</span></span><br><span class="line">  thresh = cv2.threshold(img_delta, <span class="number">25</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</span><br><span class="line">  <span class="comment"># 膨胀图像</span></span><br><span class="line">  thresh = cv2.dilate(thresh, <span class="literal">None</span>, iterations=<span class="number">2</span>)</span><br><span class="line">  <span class="comment"># findContours检测物体轮廓(寻找轮廓的图像,轮廓的检索模式,轮廓的近似办法)</span></span><br><span class="line">  contours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">  <span class="comment"># image, contours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span></span><br><span class="line">  <span class="keyword">for</span> c <span class="keyword">in</span> contours:</span><br><span class="line">   <span class="comment"># 设置敏感度</span></span><br><span class="line">   <span class="comment"># contourArea计算轮廓面积</span></span><br><span class="line">   <span class="keyword">if</span> cv2.contourArea(c) &lt; <span class="number">1000</span>:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># print(&quot;出现目标物，请求核实&quot;)</span></span><br><span class="line">    <span class="comment"># # 保存图像</span></span><br><span class="line">    <span class="comment"># cv2.imwrite(save_path + str(time.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;,time.localtime(time.time()))) + &#x27;.jpg&#x27;, frame)</span></span><br><span class="line">    <span class="comment"># print(&quot;抓拍1&quot;)</span></span><br><span class="line"></span><br><span class="line">    cv2.imwrite(save_path + <span class="built_in">str</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H_%M_%S&#x27;</span>,time.localtime(time.time()))) + <span class="string">&quot;.jpg&quot;</span>, frame)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;抓拍2&quot;</span> + <span class="built_in">str</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H_%M_%S&#x27;</span>,time.localtime(time.time()))))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  pre_frame = gray_lwpCV</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># release()释放摄像头</span></span><br><span class="line">camera.release()</span><br><span class="line"><span class="comment">#destroyAllWindows()关闭所有图像窗口</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><ul><li>运行窗口<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/运行窗口.png"></li><li>命令行输出<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/命令行输出.png"></li><li>抓拍截图<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E5%8A%A8%E6%80%81%E6%8A%93%E6%8B%8D/抓拍截图.png"></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;运动抓拍&quot;&gt;&lt;a href=&quot;#运动抓拍&quot; class=&quot;headerlink&quot; title=&quot;运动抓拍&quot;&gt;&lt;/a&gt;运动抓拍&lt;/h2&gt;&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Python  3.10.4&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.szjm.online/categories/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/categories/Python/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Python" scheme="https://www.szjm.online/tags/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>调用电脑摄像头</title>
    <link href="https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    <id>https://www.szjm.online/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/</id>
    <published>2022-05-09T03:04:19.000Z</published>
    <updated>2022-08-15T12:44:29.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调用电脑摄像头"><a href="#调用电脑摄像头" class="headerlink" title="调用电脑摄像头"></a>调用电脑摄像头</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Python  3.10.4<span id="more"></span><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/Python版本.png"></li><li>库<img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/pip库.png"></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">1</span>) <span class="comment">#设置摄像头 0是默认的摄像头 如果你有多个摄像头的话呢，可以设置1,2,3....</span></span><br><span class="line"><span class="comment"># cap = cv2.VideoCapture(0) #设置摄像头 0是默认的摄像头 如果你有多个摄像头的话呢，可以设置1,2,3....</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:   <span class="comment">#进入无限循环</span></span><br><span class="line">ret,frame = cap.read() <span class="comment">#将摄像头拍到的图像作为frame值</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;frame&#x27;</span>,frame) <span class="comment">#将frame的值显示出来 有两个参数 前一个是窗口名字，后面是值</span></span><br><span class="line">c = cv2.waitKey(<span class="number">1</span>) <span class="comment">#判断退出的条件 当按下&#x27;Q&#x27;键的时候呢，就退出</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">cap.release()  <span class="comment">#常规操作</span></span><br><span class="line">cv2.DestroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><img src="/2022/05/09/Python%E5%B0%8F%E5%B7%A5%E5%85%B7/%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/窗口拍摄.png">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;调用电脑摄像头&quot;&gt;&lt;a href=&quot;#调用电脑摄像头&quot; class=&quot;headerlink&quot; title=&quot;调用电脑摄像头&quot;&gt;&lt;/a&gt;调用电脑摄像头&lt;/h2&gt;&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Python  3.10.4&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="Python" scheme="https://www.szjm.online/categories/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/categories/Python/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Python" scheme="https://www.szjm.online/tags/Python/"/>
    
    <category term="小工具" scheme="https://www.szjm.online/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>封装详解</title>
    <link href="https://www.szjm.online/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.szjm.online/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-16T14:09:29.000Z</published>
    <updated>2022-08-15T11:07:58.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><p>该露的露，该藏的藏</p><ul><li>我们程序设计要追求<strong>“高内聚，低耦合”</strong>。<ul><li>高内聚：就是类的内部数据操作细节自己完成，不允许外部干涉。</li><li>低耦合：仅暴露少量的方法给外部使用。<span id="more"></span></li></ul></li></ul></li><li><p>封装(数据的隐藏)</p><ul><li>通常, 应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。</li></ul></li><li><p>记住这句话就够了：<strong>属性私有，get&#x2F;set</strong></p><p>私有属性直接调用会报错</p></li></ul> <img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/私有属性直接调用会报错.png">  <h4 id="快速生成set-x2F-get方法"><a href="#快速生成set-x2F-get方法" class="headerlink" title="快速生成set&#x2F;get方法"></a>快速生成set&#x2F;get方法</h4><img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/alt+insert.png"><img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/选择需要构造的属性.png"><img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/点击ok生成成功.png"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>提高数据安全性 保护数据</p></li><li><p>隐藏代码实现细节</p></li><li><p>统一接口</p></li><li><p>提高系统可维护性</p></li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop.Demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">//类 private:私有</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//    名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;         <span class="comment">//    学号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;       <span class="comment">//    性别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;        <span class="comment">//    年龄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供一些可以操作这个属性的方法</span></span><br><span class="line"><span class="comment">//    public 的 get/set方法</span></span><br><span class="line"><span class="comment">//    get 获得数据/属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    set 给这个数据设置值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    alt+insert 快速生成get/set方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="comment">//        对于不合法的数据可以在这里做限制</span></span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">150</span> &amp;&amp; age &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.oop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.oop.Demo04.Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个项目只存在一个main方法 在Application测试类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setName(<span class="string">&quot;SZJM&quot;</span>);</span><br><span class="line">        System.out.println(s1.getName());</span><br><span class="line">        s1.setAge(<span class="number">999</span>);</span><br><span class="line">        System.out.println(s1.getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/04/16/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A108_%E5%B0%81%E8%A3%85%E8%AF%A6%E8%A7%A3/Demo04.png">]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;该露的露，该藏的藏&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们程序设计要追求&lt;strong&gt;“高内聚，低耦合”&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;高内聚：就是类的内部数据操作细节自己完成，不允许外部干涉。&lt;/li&gt;
&lt;li&gt;低耦合：仅暴露少量的方法给外部使用。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="狂神" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="狂神说Java" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/"/>
    
    <category term="Java零基础学习视频通俗易懂" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"/>
    
    <category term="Java面向对象" scheme="https://www.szjm.online/categories/%E7%8B%82%E7%A5%9E/%E7%8B%82%E7%A5%9E%E8%AF%B4Java/Java%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="自学" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/"/>
    
    <category term="Java" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/categories/%E8%87%AA%E5%AD%A6/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="Java" scheme="https://www.szjm.online/tags/Java/"/>
    
    <category term="狂神" scheme="https://www.szjm.online/tags/%E7%8B%82%E7%A5%9E/"/>
    
    <category term="面向对象" scheme="https://www.szjm.online/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
