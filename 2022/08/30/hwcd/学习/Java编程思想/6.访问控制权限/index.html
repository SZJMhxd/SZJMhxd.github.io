<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="访问控制权限"><meta name="keywords" content="自学,hwcd,java,Java编程思想"><meta name="author" content="十早九木"><meta name="copyright" content="十早九木"><title>访问控制权限 | 十早九木のBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7681d949619b1341034a17f1337d10ec";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="十早九木のBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90"><span class="toc-number">1.</span> <span class="toc-text">6. 访问控制权限</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%8C%85%EF%BC%9A%E5%BA%93%E5%8D%95%E5%85%83"><span class="toc-number">1.1.</span> <span class="toc-text">6.1 包：库单元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.1.</span> <span class="toc-text">6.1.1 代码组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%88%9B%E5%BB%BA%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%8C%85%E5%90%8D"><span class="toc-number">1.1.2.</span> <span class="toc-text">6.1.2 创建独一无二的包名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E5%AE%9A%E5%88%B6%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">6.1.3 定制工具库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-%E7%94%A8import%E6%94%B9%E5%8F%98%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.1.4.</span> <span class="toc-text">6.1.4 用import改变行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-%E5%AF%B9%E4%BD%BF%E7%94%A8%E5%8C%85%E7%9A%84%E5%BF%A0%E5%91%8A"><span class="toc-number">1.1.5.</span> <span class="toc-text">6.1.5 对使用包的忠告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E8%AF%8D"><span class="toc-number">1.2.</span> <span class="toc-text">6.2 Java访问权限修饰词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%8C%85%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">6.2.1 包访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-public-%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">6.2.2 public: 接口访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-private%EF%BC%9A%E4%BD%A0%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.3.</span> <span class="toc-text">6.2.3 private：你无法访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-protected-%E7%BB%A7%E6%89%BF%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.2.4.</span> <span class="toc-text">6.2.4 protected: 继承访问权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">6.3 接口和实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.4.</span> <span class="toc-text">6.4 类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">6.5 总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">十早九木</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/szjmhxd">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">122</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">60</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">十早九木のBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">时间线</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">访问控制权限</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6/">自学</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/hwcd/">hwcd</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/hwcd/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6/Java/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">8.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 25 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="6-访问控制权限"><a href="#6-访问控制权限" class="headerlink" title="6. 访问控制权限"></a>6. 访问控制权限</h1><p>访问控制(或隐藏具体实现)与“最初的实现并不恰当“有关。<span id="more"></span></p>
<p>作品的某些部分需要多次编辑才会变得完美，有时回头看自己的代码，就能发现更好的实现方式，这就是重构的原动力之一。</p>
<p>重构就是重写代码，使其更可读、更易理解，并因此而更具可维护性。</p>
<p>但是，通常有一些客户端程序员需要在代码的某些部分保持不变，这时候就需要考虑“如何把变动的事物和保持不变的事物区分开来”。</p>
<p>这对类库（library）而言十分重要，对于客户端程序员而言，他们知道库被更新了，但是只需要修改使用的库名字，而不需要修改自己的代码；而对于类库开发者而言，能保证自己能对类库进行修改，而客户端程序员不能。</p>
<p>反过来，类库开发者也不知道那些代码被客户端程序员使用了，不知道那些代码可以修改，那些代码不能。</p>
<p>为了解决这一问题，Java提供了可以限制访问权限的关键字，从最大权限到最小权限依次为<code>public</code>，<code>protected</code>，<code>default</code>(包访问权限 友好的),<code>private</code>。</p>
<p>作为类库开发者，应该尽可能的将一切方法都设置为<code>private</code>，仅仅向客户端程序员开放你愿意让他们使用的方法。</p>
<p>构建类库的概念以及对于谁有权用该类库构件的控制问题还是不完善的。如何将构件捆绑到一个内聚的类库单元？可以用package控制。</p>
<h2 id="6-1-包：库单元"><a href="#6-1-包：库单元" class="headerlink" title="6.1 包：库单元"></a>6.1 包：库单元</h2><p>包内包含有一组类，他们在单一的名字空间之下被组织在了一起。</p>
<p>在Java的标准发布中有一个工具库，在java.util名字空间下。其中的ArrayList类的一种使用方式就是用全名<code>java.util.ArrayList</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FullQualification</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.util.<span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式会使程序语句非常冗长，可以使用另一种方式<code>import</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleImport</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        ArrayList list = new java.util.ArrayList();</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//现在可以直接这么写</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们只是导入了ArrayList，如果我们想使用java.util中其他的类，还得新写一个导入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>

<p>可以用这种方法，使用java.util下所有的类。</p>
<p>之所以要导入是因为要提供一个管理名字空间的机制，所有的类成员的名称都是彼此隔离的。如果你本地有一个stack类，然而你又在网络上下载了一个同名的stack类，怎么区分呢？这时候为每个类创建唯一标识符就成了非常重要的事情。</p>
<p>目前为止书里的示例都在单一文件中，专为local use（本地使用）而设计，所以没有受到包名的干扰。</p>
<p>其实他们已经在包里了，<code>未命名包</code>，或者叫<code>默认包</code>。虽然为了简单起见，书里目前其他部分都是本地默认包，不过如果准备准备编写在其他机器上能共存的类库的话，就需要考虑防止类名称之间的冲突问题。</p>
<p>编写Java源代码文件时，这个文件通常被称之为编译单元（或者叫转译单元）。</p>
<p>每个编译单元必须有一个后缀<code>.java</code>，而编译单元内可以有一个public类，这个类的名字必须与文件名字相同（包括大小写，但是不包括后缀）。</p>
<p>每个编译单元只能有一个public类，如果在编译单元之中还有别的类，包外是无法看见这些类的，因为他们不是public类，主要用来为主类提供支持。</p>
<h3 id="6-1-1-代码组织"><a href="#6-1-1-代码组织" class="headerlink" title="6.1.1 代码组织"></a>6.1.1 代码组织</h3><p>编译.java文件时，文件里的每个类都会有一个输出文件，同名，但是后缀改成了.class。</p>
<p>在编译少量的.java文件会得到大量的class文件。</p>
<p>编译型语言是对于编译器产生一个中间件文件，再通过连接器或者类库产生器产生的其他同类文件捆绑在一起。</p>
<p>Java是把可运行程序打包并压缩为一个Java文档文件jar，Java解释器负责这些文件的查找、装载和解释。</p>
<p>类库实际上是一组类文件，每个文件都有一个public类，以及任意数量的非public类，因此每个文件都有一个构件，如果希望这些构件从属于一个群组，可以使用关键字package。</p>
<p>使用package语句必须在文件除注释外第一句，在文件的起始处。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> access;</span><br></pre></td></tr></table></figure>

<p>这声明该编译单元是名为access类库的一部分，你正在声明这个编译类在该编译单元中的public类在access名称的保护伞下，任何使用该名称的人都需要在使用前给出选择，指定全名或者使用import关键字。（Java包的命名规则全部使用小写字母，包括中间的字）</p>
<p>假设文件的名称是MyClass.java，这就意味着该文件中有且只有一个public类，该类的名称必须是MyClass（大小写必须一致）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:access/mypackage/MyClass.java</span></span><br><span class="line"><span class="keyword">package</span> access.mypackage</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在如果有人想使用MyClass或者access中任何其他public类，就必须使用import关键字或者使用全名引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QyalifiedMyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        access.mypackage.<span class="type">MyClass</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">access</span>.mypackage.MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般使用简洁的import关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access.mypackage.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImportedMyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类库设计员需要牢记package和import关键字允许做的是将单一的全局名字空间分割开来，这样无论多少人使用网络和Java的开始编写类，都不会出现名称冲突的问题。</p>
<h3 id="6-1-2-创建独一无二的包名"><a href="#6-1-2-创建独一无二的包名" class="headerlink" title="6.1.2 创建独一无二的包名"></a>6.1.2 创建独一无二的包名</h3><p>既然一个包从未真正的被打包包装成单一的文件，并且可以由许多.class文件构成，这样情况就会变得复杂。</p>
<p>为了避免这种情况，一种方法是把特定包的所有.class文件都置于一个目录下，利用操作系统的层次化文件结构来解决这个问题。</p>
<p>所有的文件收入子目录还可以解决另外两个问题：</p>
<ol>
<li><p>怎样创建独一无二的名称</p>
</li>
<li><p>怎样查找可能隐藏域目录结构某处的类</p>
</li>
</ol>
<p>这些任务通过将.class文件所在的路径位置编码成package的名称来实现。</p>
<p>如果按照使用域名为包名的惯例，因为域名是全网惟一的，所以package的名称也将是独一无二的，就不会出现名称冲突的问题，当然你也可以用其他的命名方法，如果你想要发布你的Java程序代码，最好还是取得一个域名。</p>
<p>把package名称分解为机器上的目录，当Java程序运行并且需要加载class文件的时候，就可以确定.class文件在目录上所处的位置。Java运行过程如下：</p>
<p>首先，找出环境变量CLASSPATH，CLASSPATH包含一个或多个目录，用作查找.class文件的根目录，从根目录开始，解释器获取包名并且将每个<code>.</code>替换成<code>/</code>或者<code>\</code>或者取决于操作系统的其他符号，解释器会在转换后的地址中查找与你所需要创建的类名称的相关class文件。</p>
<p>以我的域名szjm.online为例，把他的顺序倒过来，全部转换成小写，online.szjm就成为了我创建的类的独一无二的全局名称，如果在创建一个<code>simple</code>类，那么这个包的名称就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> online.szjm.simple;</span><br></pre></td></tr></table></figure>

<p>实际使用中就是这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> online.szjm.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;online.szjm.simple.Vector&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个包的相对路径是在<code>online\szjm\simple\Vector</code>，那么这个路径之前的部分是什么呢，是CLASSPATH设定的地址。</p>
<p>从Java5开始CLASSPATH默认就是当前路径，一般情况下就不需要再设定了。若使用Java5以前的版本，需要设置环境变量CLASSPATH为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">CLASSPATH</span></span><br><span class="line">.;%<span class="variable constant_">JAVA_HOME</span>%\lib\dt.<span class="property">jar</span>;%<span class="variable constant_">JAVA_HOME</span>%\lib\tools.<span class="property">jar</span></span><br></pre></td></tr></table></figure>

<p>其中dt.jar是关于java运行环境的类库；tools.jar是工具类库</p>
<p>一旦类路径得到正确确认，使用类包的文件就可以在任何位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> online.szjm.simple.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LibTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">        <span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">List</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译器碰到simple的import语句时，就会在CLASSPATH所指定的目录中查找<code>online\szjm\simple</code>，然后从已编译的文件中查找名称相符的（Vector对应Vector.class  List对应List.class），这里要注意这两个方法需要是public</p>
<p>如果两个含有相同名称的类库都使用*的方式导入，会怎么样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> online.szjm.simple.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>

<p>由于java.util.*和我们定义的online.szjm.simple.*都包含Vector类，那么我们在用new创建类时，就会产生冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Vector</span> <span class="variable">V</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br></pre></td></tr></table></figure>

<p>这里到底用的哪个类呢？编译器是不知道的，就会报错，强制程序员明确指明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.<span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Vector();</span><br></pre></td></tr></table></figure>

<p>这种写法配合CLASSPATH就可以完全指明Vector的位置，然而这种情况下如果不需要使用java.util下的其他内容，就可以不用写<code>import java.util.*;</code>语句了。</p>
<h3 id="6-1-3-定制工具库"><a href="#6-1-3-定制工具库" class="headerlink" title="6.1.3 定制工具库"></a>6.1.3 定制工具库</h3><p>现在可以创建自己的类库来减少或消除重复的程序代码了，比如可以新写一个输出类来替代System.out</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> online.szjm.tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        System.out.print(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PrintStream <span class="title function_">printf</span><span class="params">(String format, Object... args)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.out.printf(format, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译完后，就可以用import static语句在系统上使用静态的print和println方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.C6.C1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> online.szjm.tools.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;自定义的换行输出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>经过我的测试在命令行javac需要手动配置CLASSPATH 还可能需要加包名，在IDEA环境需要手动导入库，如果只是这个项目使用就导入项目设置里的库，如果是以后也使用就导入全局库，记得要是class文件的，所以在IDEA一般是out输出文件夹</strong></p>
<img src="/2022/08/30/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/6.%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/6_1_3_1IDEA导入库.png" alt="6_1_3_1IDEA导入库">

<p>从现在开始，你无论何时创建的有用的新工具都可以添加到自己的类库中。</p>
<h3 id="6-1-4-用import改变行为"><a href="#6-1-4-用import改变行为" class="headerlink" title="6.1.4 用import改变行为"></a>6.1.4 用import改变行为</h3><p>Java没有C的条件编译功能，该功能可以使你不必更改任何程序代码，就能够切换开关并产生不同的行为。Java去掉此功能的原因可能是因为C在绝大多数情况下是用此功能来解决跨平台问题的，即程序代码的不同部分是根据不同的平台来编译的。由于Java自身可以自动跨越不同的平台，因此这个功能对Java而言是没有必要的。</p>
<p>然而，条件编译还有其他一些有价值的用途。调试就是一个很常见的用途。调试功能在开发过程中是开启的，而在发布的产品中是禁用的。可以通过修改被导入的package的方法来实现这一目的，修改的方法是将你程序中用到的代码从调试版改为发布版。这一技术可以适用于任何种类的条件代码。</p>
<h3 id="6-1-5-对使用包的忠告"><a href="#6-1-5-对使用包的忠告" class="headerlink" title="6.1.5 对使用包的忠告"></a>6.1.5 对使用包的忠告</h3><p>无论何时创建包，都已经在给定的包的名称的时候隐含的指定了目录结构，这个包必须位于其名称所指定的目录中，而该目录必须是在以CLASSPATH开始的目录中可以查询的。</p>
<p>除非遵守“包的名字对应目录路径”的规则，否则就可能报错，告知无法找到特定的类，哪怕这个类在同一个目录中。</p>
<p>如果遇到类似报错，注释掉package语句，如果这样程序就能运行，就知道问题在哪了。</p>
<p>编译过的代码通常与源代码在不同的目录里，但是必须保证JVM可以使用CLASSPATH找到该路径。</p>
<h2 id="6-2-Java访问权限修饰词"><a href="#6-2-Java访问权限修饰词" class="headerlink" title="6.2 Java访问权限修饰词"></a>6.2 Java访问权限修饰词</h2><p><code>public</code>、<code>protected</code>和<code>private</code>这几个Java访问权限修饰词在使用时，是置于类中每个成员的定义之前的，无论它是一个域还是一个方法。每个访问权限修饰词仅控制它所修饰的特定定义的访问权。</p>
<p>如果不提供任何访问权限修饰词，则意味着它是“包访向权限”。因此，无论如何，所有事<br>物都具有某种形式的访问权限控制。</p>
<h3 id="6-2-1-包访问权限"><a href="#6-2-1-包访问权限" class="headerlink" title="6.2.1 包访问权限"></a>6.2.1 包访问权限</h3><p>之前的所有示例都没有使用任何访问权限修饰词。默认访向权限没有任何关键字，但通常是指包访问权限(有时也表示成为friendly)。这就意味着当前的包中的所有其他类对那个成员都有访问权限，但对于这个包之外的所有类，这个成员却是private。由于一个编译单元(即一个文件)， 只能隶属于一个包，所以经由包访问权限，处于同一个编译单元中的所有类彼此之间都是自动可访问的。</p>
<p>包访问权限允许将包内所有相关的类组合起来，以使它们彼此之间可以轻松地相互作用。</p>
<p>当把类组织起来放进一个包内之时， 也就给它们的包访向权限的成员赋予了相互访向的权限，你“拥有”了该包内的程序代码。“只有你拥有的程序代码才可以访向你所拥有的其他程序代码”,这是合理的。</p>
<p>应该说，包访问权限为把类群聚在一个包中的做法提供了意义和理由。在许多语言中，在文件内组织定义的方式是任意的，但在Java中，则要强制你以一种合理的方式对它们加以组织。另外，你可能还想要排除这样的类，它们不应该访问在当前包中所定义的类。</p>
<p>类控制着哪些代码有权限访问自己的成员，取得对某成员的访问权的唯一途径是：</p>
<ol>
<li>使该成员成为public。于是，无论是谁，无论在哪里，都可以访问该成员。</li>
<li>不加访问权限修饰词，并将其他类放置于同一个包内，给成员赋予包访问权。于是包内的其他类也就可以访问该成员了。</li>
<li>在第7章将会介绍继承技术，继承而来的类既可以访间public成员也可以访向protected成员(但访问private成员却不行)。 只有在两个类都处于同一个包内时，它才可   以访问包访问权限的成员。但现在不必担心继承和protected。</li>
<li>提供访问器(acessor) 和变异器(mutator) 方法(也称作getset方法),以读取和改变数值。对OOP而言，这是最优雅的方式，而且这也是JavaBeans的基本原理。</li>
</ol>
<h3 id="6-2-2-public-接口访问权限"><a href="#6-2-2-public-接口访问权限" class="headerlink" title="6.2.2 public: 接口访问权限"></a>6.2.2 public: 接口访问权限</h3><p>使用关键字public,就意味着public之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。假设定义了一个包含下面编译单元的dessert包:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> access.dessert;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cookie</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cookie construcrot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bite</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bite&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个Cookie.java文件必须在<code>access\dessert</code>目录下。Java不是总是将当前目录视作查找行为的起点，如果CLASSPATH之中缺少了<code>.</code>作为路径，Java就不会查找那里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access.dessert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dinner</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就创建了一个Cookie对象，他的构造器是public而且类也是public，但是bite只向在dessert包中的类提供访问权，所以bite成员在dinner之间是无法访问的。</p>
<p>下面这个代码虽然看起来破坏了规则，但是可以编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:access/Cake.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cake</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pie</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pie</span>();</span><br><span class="line">        x.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个处于相同目录的文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:access/Pie.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pie</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pie.f()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能会有人认为这两个文件毫不相关，但是Cake却可以创建一个Pie对象并调用他的f()方法</p>
<p>Cake能访问Pie是因为这两个包都没有给自己设定任何包名称，Java就会将这样的文件看做隶属于该目录的默认包，该目录的所有文件都有互相访问的权限。</p>
<h3 id="6-2-3-private：你无法访问"><a href="#6-2-3-private：你无法访问" class="headerlink" title="6.2.3 private：你无法访问"></a>6.2.3 private：你无法访问</h3><p>关键字private的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员。由于处于同一个包内的其他类是不可以访问private成员的，因此这等于说是自己隔离了自己。</p>
<p>从另一方面说，让许多人共同合作来创建一个包也是不大可能的，为此private就允许你随意改变该成员，而不必考虑这样做是否会影响到包内其他的类。</p>
<p>默认的包访问权限通常已经提供了充足的隐藏措施。请记住，使用类的客户端程序员是无法访问包访问权限成员的。</p>
<p>这样做很好，因为默认访问权限是一种我们常用的权限，同时也是一种在忘记添加任何访问权限控制时能够自动得到的权限。因此，通常考虑的是，哪些成员是想要明确公开给客户端程序员使用的，从而将它们声明为public,而在最初，你可能不会认为自己经常会需要使用关键字private,因为没有它，照样可以工作。然而，事实很快就会证明，对private的使用是多么的重要，在多线程环境下更是如此。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sundae</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Sundae</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Sundae <span class="title function_">makeASundae</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sundae</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IceCream</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="comment">//Sundae x = new Sundae();</span></span><br><span class="line">            <span class="type">Sundae</span> <span class="variable">x</span> <span class="operator">=</span> Sundae.makeASundae();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很好的说明private的例子，这个例子中，不能够通过构造器来创建Sundae对象，必须通过makeASundae()方法来达到这个目的。</p>
<p>任何可以肯定只是该类的一个“ 助手”方法的方法，都可以把它指定为private,以确保不会在包内的其他地方误用到它，于是也就防止了你会去改变或删除这个方法。将方法指定为private确保了你拥有这种选择权。</p>
<p>这对于类中的private域同样适用。除非必须公开底层实现细目(此种境况很少见)，否则就应该将所有的域指定为private。<strong>然而，不能因为在类中某个对象的引用是private,就认为其他的对象无法拥有该对象的public引用</strong>。</p>
<h3 id="6-2-4-protected-继承访问权限"><a href="#6-2-4-protected-继承访问权限" class="headerlink" title="6.2.4 protected: 继承访问权限"></a>6.2.4 protected: 继承访问权限</h3><p>关键字protected处理的是继承的概念，通过继承可以利用一个现有类，我们将其称为基类（父类），然后将新成员添加到该现有类中而不必碰该现有类。还可以改变该类的现有成员的行为。</p>
<p>为了从现有类中继承，需要声明新类extends (扩展)了一 个现有类，就像这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">extends</span> <span class="title class_">Bar</span> &#123;</span><br></pre></td></tr></table></figure>

<p>类定义中的其他部分看起来都是一样的。</p>
<p>如果创建了一个新包，并自另一个包中继承类，那么唯一可以访问的成员就是源包的public成员。(当然，如果在同一个包内执行继承工作，就可以操纵所有的拥有包访向权限的成员。)</p>
<p>有时，基类的创建者会希望有某个特定成员，把对它的访问权限赋予派生类而不是所有类。这就需要protected来完成这一工作。 protected 也提供包访问权限，也就是说，相同包内的其他类可以访问protected元素。</p>
<p>回顾一下先前的例子Cookie.java,就可以得知下面的类是不可以调用拥有包访问权限的成员bite()的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access.dessert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChocolateChip</span> <span class="keyword">extends</span> <span class="title class_">Cookie</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ChocolateChip</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;ChocolateChip constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chomp</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//! bite();</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ChocolateChip</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChocolateChip</span>();</span><br><span class="line">        x. chomp() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关继承技术的一个很有趣的事情是，如果类Cookie中存在一个方法bite()的话， 那么该方法同时也存在于任何一个从Cookie继承而来的类中。但是由于bite()有包访向权限而且它位于另一个包内，所以我们在这个包内是无法使用它的。</p>
<p>当然，也可以把它指定为public,但是这样做所有的人就都有了访问权限，而且很可能这并不是你所希望的。如果我们将类Cookie像这样加以更改: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> access.cookie2;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cookie</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cookie construcrot&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">bite</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bite&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在对于所有继承自Cookie的类而言，bite()都是可用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access.cookie2.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class ChocolateChip2 <span class="keyword">extends</span> <span class="title class_">Cookie</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ChocolateChip2</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;ChocolateChip2 constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chomp</span><span class="params">()</span>&#123;</span><br><span class="line">        bite();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="type">ChocolateChip2</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChocolateChip2</span>();</span><br><span class="line">        x.chomp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里尽管bite()也具有包访问权限但是他仍旧不是public的。</p>
<h2 id="6-3-接口和实现"><a href="#6-3-接口和实现" class="headerlink" title="6.3 接口和实现"></a>6.3 接口和实现</h2><p>访问权限的控制常被称为是具体实现的隐藏。</p>
<p>把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是封装。其结果是一个同时带有特征和行为的数据类型。</p>
<p>出于两个很重要的原因，访问权限控制将权限的边界划在了数据类型的内部。</p>
<ol>
<li>要设定客户端程序员可以使用和不可以使用的界限。可以在结构中建立自己的内部机制，而<br>不必担心客户端程序员会偶然地将内部机制当作是他们可以使用的接口的一部分。这个原因直接引出了第二个原因。</li>
<li>即将接口和具体实现进行分离。如果结构是用于一组程序之中，而客户端程序员除了可以向接口发送信息之外什么也不可以做的话，那么就可以随意更改所有不是public的东西( 例如有包访问权限、protected 和private的成员)，而不会破坏客户端代码。</li>
</ol>
<p>为了清楚起见，可能会采用一种将public成员置于开头，后面跟着protected.包访问权限和private成员的创建类的形式。这样做的好处是类的使用者可以从头读起，首先阅读对他们而言最为重要的部分(即public成员， 因为可以从文件外部调用它们)，等到遇见作为内部实现细节的非public成员时停止阅读:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class OrganizedByAccess &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pub1</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pub2</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pub3</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">priv1</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">priv2</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> vo1d <span class="title function_">priv3</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做仅能使程序阅读起来稍微容易一些，因为接口和具体实现仍旧混在一起。也就是说，仍能看到源代码的实现部分，因为它就在类中。另外，javadoc所提供的注释文档功能降低了程序代码的可读性对客户端程序员的重要性。将接口展现给某个类的使用者实际上是类浏览器的任务。</p>
<p>类浏览器是一种以非常有用的方式来查阅所有可用的类，并告诉你用它们可以做些什么(也就是显示出可用成员)的工具。在Java中，用Web浏览器浏览JDK文档可以得到使用类浏览器的相同效果。</p>
<h2 id="6-4-类的访问权限"><a href="#6-4-类的访问权限" class="headerlink" title="6.4 类的访问权限"></a>6.4 类的访问权限</h2><p>在Java中，访问权限修饰词也可以用于确定库中的哪些类对于该库的使用者是可用的。如果希望某个类可以为某个客户端程序员所用，就可以通过把关键字public作用于整个类的定义来达到目的。这样做甚至可以控制客户端程序员是否能创建一个该类的对象。</p>
<p>为了控制某个类的访问权限，修饰词必须出现于关键字class之前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br></pre></td></tr></table></figure>

<p>现在如果库的名字是access，那么任何客户端程序员都可以通过下面的声明访问Widget</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> access .Widget;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">import</span> access.*;</span><br></pre></td></tr></table></figure>

<p>然而，这里还有一些额外的限制:</p>
<ol>
<li>每个编译单元(文件)都只能有一个public类。这表示，每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某个编译单元内有一个以上的public类，编译器就会给出出错信息。</li>
<li>public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。所以对于Widget而言，文件的名称必须是Widget.java，而不是widget.java或WIDGET.java。如果不匹配，同样将得到编译时错误。</li>
<li>虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下，可以随意对文件命名。(尽管随意命名会使得人们在阅读和维护代码时产生混淆。)</li>
</ol>
<p>如果获取了一个在access内部的类，用来完成Widget或是其他在access中的public类所要执行的任务，将会出现什么样的情况呢?你不想自找麻烦去为客户端程序员创建说明文档，而且你认为不久可能会想要完全改变原有方案并将旧版本一起删除，代之以一种不同的版本。为了保留此灵活性，需要确保客户端程序员不会依赖于隐藏在access之中的任何特定实现细节。为了达到这一点，只需将关键字public从类中拿掉，这个类就拥有了包访问权限。(该类只可以用于该包之中。)</p>
<p>在创建一个包访问权限的类时，仍旧是在将该类的域声明为private时才有意义，应尽可能地总是将域指定为私有的，但是通常来说，将与类(包访问权限)相同的访问权限赋予方法也是很合理的。</p>
<p>既然一个有包访问权限的类通常只能被用于包内，那么如果对你有强制要求，在此种情况下，编译器会告诉你，你只需要将这样的类的方法设定为public就可以了。</p>
<p>请注意，类既不可以是private的(这样会使得除该类之外，其他任何类都不可以访向它)，也不可以是protected的。所以对于类的访问权限，仅有两个选择:包访问权限或public。 </p>
<p>如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而阻止任何人<br>创建该类的对象，但是有一个例外，就是你在该类的static成员内部可以创建。</p>
<p>如果我们把构造器定义为private，那就谁也无法创建这个类型的对象。这种情况下还是有方法使用这两个类。</p>
<p>在Soup1中创建一个static方法，创建一个新的Soup1对象并返回一个对它的引用。这样如果想在返回引用之前做一些额外的工作，或者是记录创建了多少个Soup1对象都可以。</p>
<p>Soup2用到了所谓的设计模式，这种模式被称之为singleton（单例），这是因为你始终只能创建它的一个对象。Soup2类的对象是作为Soup2的一个static private成员而创建的，所以有且只有一个，除非是通过public方法access()，否则无法访问到。</p>
<p>之前提到过，如果没有为类访问权限指定一个修饰符，那么会默认得到包访问权限，意味着该类的对象可以由包内任何其他类来创建，而包外是不行的。如果某个static成员是public的话，客户端程序员仍然可以调用这个static成员，尽管他们并不能生成该类的对象。</p>
<h2 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h2><p>无论什么关系，为各成员创建需要遵守的界限是很重要的。当创建了类库之后，也就与该类库的用户建立了某种关系。客户端程序员会用你的类库聚合成一个应用程序或者创建更大的类库。</p>
<p>如果不指定规则，客户端程序员就可以对类的所有成员为所欲为。</p>
<p>控制对成员的访问权限有两个原因。</p>
<ul>
<li>第一是为了使用户不要碰触那些他们不该碰触的部分，这些部分对于类内部的操作是必要的，但是它并不属于客户端程序员所需接口的一部分。 因此，将方法和域指定成private，对客户端程序员而言是一种服务。 因为这样他们可以很清楚地看到什么对他们重要，什么是他们可以忽略的。这样简化了他们对类的理解。</li>
<li>第二个原因，也是最重要的原因，是为了让类库设计者可以更改类的内部工作方式，而不必担心这样会对客户端程序员产生重大的影响。例如，最初可能会以某种方式创建一个类，然后发现如果更改程序结构，可以大大提高运行速度。如果接口和实现可以被明确地隔离和加以保护，那么就可以实现这一目的，而不必强制客户端程序员重新编写代码。访问权限控制可以确保不会有任何客户端程序员依赖于某个类的底层实现的任何部分。</li>
</ul>
<p>类的公共接口是用户真正能够看到的，所以这一部分是在分析和设计的过程中决定该类是否正确的最重要的部分。</p>
<p>尽管如此，你仍然有进行改变的空间。如果在最初无法创建出正确的接口，那么只要不删除任何客户端程序员在他们的程序中已经用到的东西,就可以在以后添加更多的方法。</p>
<p>注意，访问权限控制专注于类库创建者和该类库的外部使用者之间的关系，这种关系也是一种通信方式。 然而，在许多情况下事情并非如此。例如，你自己编写了所有的代码，或者你在一个组员聚集在一起的项目组中工作，所有的东西都放在同一个包中。这些情况是另外一种不同的通信方式，因此严格地遵循访问权限规则并不一定是最佳选择，默认(包)访问权限也许只是可行而已。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">十早九木</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.szjm.online/2022/08/30/hwcd/学习/Java编程思想/6.访问控制权限/">https://www.szjm.online/2022/08/30/hwcd/学习/Java编程思想/6.访问控制权限/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.szjm.online">十早九木のBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%AD%A6/">自学</a><a class="post-meta__tags" href="/tags/hwcd/">hwcd</a><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="../../../../../../../wx.jpg"><div class="post-qr-code__desc">来杯奶茶吧</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="../../../../../../../zfb.jpg"><div class="post-qr-code__desc">圣代我也喜欢</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/08/30/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/7.%E5%A4%8D%E7%94%A8%E7%B1%BB/"><i class="fa fa-chevron-left">  </i><span>复用类</span></a></div><div class="next-post pull-right"><a href="/2022/08/26/hwcd/%E6%97%A5%E5%BF%97/2022.08/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%202022%E5%B9%B48%E6%9C%8829%E6%97%A5%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC/"><span>访问控制权限</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By 十早九木</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>