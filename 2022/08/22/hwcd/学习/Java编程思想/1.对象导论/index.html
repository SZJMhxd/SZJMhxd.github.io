<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="对象导论"><meta name="keywords" content="hwcd,java,学习,Java编程思想"><meta name="author" content="十早九木"><meta name="copyright" content="十早九木"><title>对象导论 | 十早九木のBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?7681d949619b1341034a17f1337d10ec";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.2.0'
} </script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="十早九木のBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">1. 对象导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 抽象过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 每个对象都有一个接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 每个对象都提供服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 被隐藏的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%A4%8D%E7%94%A8%E5%85%B7%E4%BD%93%E4%BD%93%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 复用具体体现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E2%80%9C%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E4%B8%8E%E2%80%9C%E5%83%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.6.1 “是一个”与“像是一个”关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E4%BC%B4%E9%9A%8F%E5%A4%9A%E6%80%81%E7%9A%84%E5%8F%AF%E4%BA%92%E6%8D%A2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 伴随多态的可互换对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E5%8D%95%E6%A0%B9%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 单根继承结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.9.</span> <span class="toc-text">1.9 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-1-%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">1.9.1 参数化类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="toc-number">1.10.</span> <span class="toc-text">1.10 对象的创建和生命期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">1.11.</span> <span class="toc-text">1.11 异常处理：处理错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.12.</span> <span class="toc-text">1.12 并发编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-Java%E4%B8%8EInternet"><span class="toc-number">1.13.</span> <span class="toc-text">1.13 Java与Internet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-1-Web%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.13.1.</span> <span class="toc-text">1.13.1 Web是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%A2%E6%88%B7-x2F-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">1. 客户&#x2F;服务器计算技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Web%E5%B0%B1%E6%98%AF%E4%B8%80%E5%8F%B0%E5%B7%A8%E5%9E%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">2. Web就是一台巨型服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-number">1.13.2.</span> <span class="toc-text">1.13.2 客户端编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%92%E4%BB%B6"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">1. 插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">2.脚本语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Java"><span class="toc-number">1.13.2.3.</span> <span class="toc-text">3. Java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%87%E9%80%89%E6%96%B9%E6%A1%88"><span class="toc-number">1.13.2.4.</span> <span class="toc-text">4. 备选方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-NET%E5%92%8CC"><span class="toc-number">1.13.2.5.</span> <span class="toc-text">5. .NET和C#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Internet%E4%B8%8EIntranet%EF%BC%88%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E7%BD%91%EF%BC%89"><span class="toc-number">1.13.2.6.</span> <span class="toc-text">6. Internet与Intranet（企业内部网）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-number">1.13.3.</span> <span class="toc-text">1.13.3 服务器端编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-%E6%80%BB%E7%BB%93"><span class="toc-number">1.14.</span> <span class="toc-text">1.14 总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">十早九木</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/szjmhxd">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">84</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">51</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">十早九木のBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">时间线</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">对象导论</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/hwcd/">hwcd</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/hwcd/java/">java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/hwcd/java/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">12.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 37 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="1-对象导论"><a href="#1-对象导论" class="headerlink" title="1. 对象导论"></a>1. 对象导论</h1><blockquote>
<p>我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协定的参与者，这个协定以语言的形式固定下来…除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈。</p>
<p>——Benjamin Lee Whorf (1897 ~ 1941)</p>
</blockquote>
<p>​        计算机有更多的用途，越来越不像机器，有多种表达方式。<strong>面向对象程序设计(Object-oriented Programming, OOP)便是这种以计算机作为表<br>达媒体的大趋势中的组成部分。</strong><span id="more"></span></p>
<h2 id="1-1-抽象过程"><a href="#1-1-抽象过程" class="headerlink" title="1.1 抽象过程"></a>1.1 抽象过程</h2><p><strong>所有的编程语言都提供抽象机制。</strong>汇编语言是对底层机器语言的轻微抽象。（把一堆0011编程<code>jump $</code> ?）</p>
<p>命令语言在汇编的基础上有改进，但是模型需要自己建立，费力，维护代价高，产生了“编程方法”行业。</p>
<p>另一种对机器建模的方式，只对待解决的问题建模，只针对特定领域。</p>
<p>面向对象方式通过向程序员提供表示问题空间中的元素的工具而更进一步。这种表示方式非常通用，使得程序员不会受限于任何特定类型的问题。<strong>我们将问题空间中的元素及其在解空间中的表示称为“对象”。</strong>这种思想的实质是：程序可以通过添加新类型的对象使自身适用于某个特定问题。相比以前我们所使用的语言，这是一种更灵活和更强有力的语言抽象。所以，OOP允许<strong>根据问题来描述问题</strong>，而不是根据运行解决方案的计算机来描述问题。</p>
<p>Alan Kay曾经总结了第一个成功的面向对象语言、同时也是Java所基于的语言之一的Smalltak的五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式：</p>
<ol>
<li>万物皆为对象。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件(狗、建筑物、服务等)，将其表示为程序中的对象。</li>
<li>程序是对象的集合，它们通过发送消息来告知彼此所要做的。要想请求一个对象，就必须对该对象发送一条消息。 更具体地说，可以把消息想像为对某个特定对象的方法的调用请求。</li>
<li>每个对象都有自己的由其他对象所构成的存储。换句话说，可以通过创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。</li>
<li>每个对象都拥有其类型。按照通用的说法，“每个对象都是某个类(class) 的一个实例(instance)”，这里“类”就是“类型”的同义词。每个类最重要的区别于其他类的特性就是“可以发送什么样的消息给它”。</li>
<li>某一特定类型的所有对象都可以接收同样的消息。这是一句意味深长的表述，你在稍后便会看到。因为“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这意味着可以编写与“几何形”交互并自动处理所有与几何形性质相关的事物的代码。这种可替代性(substitutability) 是OOP中最强有力的概念之一。</li>
</ol>
<p>Booch对对象提出了一个更加简洁的描述：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据(它们给出了该对象的状态)和方法(它们产生行为),并且每一个对象都可以唯一地与其他对象区分开来，具体说来，就是每一个对象在内存中都有一个唯一的地址。</p>
<h2 id="1-2-每个对象都有一个接口"><a href="#1-2-每个对象都有一个接口" class="headerlink" title="1.2 每个对象都有一个接口"></a>1.2 每个对象都有一个接口</h2><p>所有的对象都是唯一的， 但同时也是具有相同的特性和行为的对象所归属的类的一部分。</p>
<p>这种思想被直接应用于第一个面向对象语言Simula-67,它在程序中使用基本关键字class来引入新的类型。<br>Simula是为了开发诸如经典的“ 银行出纳员问题”(bank teller problem)这样的仿真程序而创建的。</p>
<p>在银行出纳员问题中，有出纳、客户、账户、交易和货币单位等许多“对象”。在程序执行期间具有不同的状态而其他方面都相似的对象会被分组到对象的类中，这就是关键字class的由来。</p>
<p>创建抽象数据类型(类)是面向对象程序设计的基本概念之一。抽象数据类型的运行方式与内置(built-in) 类型几乎完全一致:你可以创建某一类型的变量(按照面向对象的说法，称其为对象或实例)，然后操作这些变量(称其为发送消息或请求；发送消息，对象就知道要做什么)。每个类的成员或元素都具有某种共性:每个账户都有结余金额，每个出纳都可以处理存款请求等。同时，每个成员都有其自身的状态:每个账户都有不同的结余金额，每个出纳都有自己的姓名。因此，出纳、客户、账户、交易等都可以在计算机程序中被表示成唯一的实体。这些实体就是对象，每一个对象都属于定义了特性和行为的某个特定的类。</p>
<p>程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。</p>
<p><strong>可以根据需求，通过添加新的数据类型来扩展编程语言。</strong>编程系统欣然接受新的类，并且像对待内置类型一样地照管它们和进行类型检查。</p>
<p>一旦类被建立，就可以随心所欲的创建类的任意个对象，然后去操作。</p>
<p>有用的对象，必须有某种方式产生对对象的请求，使对象完成各种任务。</p>
<img src="/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_2_1用灯泡来举例.png" alt="1_2_1用灯泡来举例">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Light</span> <span class="variable">lt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">lt.on();</span><br></pre></td></tr></table></figure>

<p>接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码。这些代码与隐藏的数据一起构成了实现。</p>
<p>在类型中，每一个可能的请求都有一个方法与之相关联，当向对象发送请求时，与之相关联的方法就会被调用。此过程通常被概括为: <strong>向某个对象“ 发送消息”(产生请求)</strong>,这个对象便知道此消息的目的，然后执行对应的程序代码。</p>
<h2 id="1-3-每个对象都提供服务"><a href="#1-3-每个对象都提供服务" class="headerlink" title="1.3 每个对象都提供服务"></a>1.3 每个对象都提供服务</h2><p>当正在试图开发或理解-一个程序设计时,最好的方法之一就是将对象想像为“服务提供者”。</p>
<p>程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这-一目的。你的目标就是去创建(或者最好是在现有代码库中寻找)能够提供理想的服务来解决问题的一系列对象。</p>
<p>将对象看作是服务提供者还有一个附带的好处:它有助于提高对象的内聚性。</p>
<p><strong>高内聚</strong>是软件设计的基本质量要求之一：这意味着一个软件构件(例如一个对象，当然它也有可能是指一个方法或一个对象库)的各个方面“组合”得很好。人们在设计对象时所面临的一个问题是，将过多的功能都塞在一个对象中。</p>
<p>例如，在检查打印模式的模块中，你可以这样设计一个对象，让它了解所有的格式和打印技术。</p>
<p>你可能会发现，这些功能对于一个对象来说太多了，你需要的是三个甚至更多个对象，其中，一个对象可以是所有可能的支票排版的目录，它可以被用来查询有关如何打印一张支票的信息；另一个对象(或对象集合)可以是一个通用的打印接口，它知道有关所有不同类型的打印机的信息(但是不包含任何有关簿记的内容，它更应该是一个需要购买而不是自己编写的对象) ；第三个对象通过调用另外两个对象的服务来完成打印任务。这样，每个对象都有一个它所能提供服务的内聚的集合。 </p>
<p>在良好的面向对象设计中，<strong>每个对象都可以很好地完成一项任务，但是它并不试图做更多的事。</strong>就像在这里看到的，不仅允许通过购买获得某些对象(打印机接口对象)，而且还可以创建能够在别处复用的新对象(支票排版目录对象)。</p>
<h2 id="1-4-被隐藏的具体实现"><a href="#1-4-被隐藏的具体实现" class="headerlink" title="1.4 被隐藏的具体实现"></a>1.4 被隐藏的具体实现</h2><p>将程序开发人员按照角色分为<code>类创建者</code>(那些创建新数据类型的程序员)和<code>客户端程序员</code>(那些在其应用中使用数据类型的类消费者)是大有裨益的。</p>
<p>客户端程序员的目标是收集各种用来实现快速应用开发的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，而隐藏其他部分。为什么要这样呢？因为如果加以隐藏，那么客户端程序员将不能够访问它，这意味着类创建者可以任意修改被隐藏的部分，而不用担心对其他任何人造成影响。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心的或不知内情的客户端程序员所毁坏，因此将实现隐藏起来可以减少程序bug。</p>
<p><strong>访问控制</strong>存在的原因：</p>
<ol>
<li>让客户端程序员无法触及他们不应该触及到的部分（客户端程序员能调用就行）</li>
<li>允许库的设计者可以改变类内部的工作方式而不用担心影响到客户端程序员（将3*3&#x3D;9的计算方式由3+3+3改变成3<code>*</code>3，但是对于客户端程序员来说，他们调用的乘法接口方式没变，结果没变）</li>
</ol>
<p>Java用三个关键字在类的内部设定边界:**<code> public</code>**、 **<code>private</code>**、 <strong><code>protected</code><strong>。 这些访问指定词(access specifier) 决定了紧跟其后被定义的东西可以被谁使用。<code>public</code>表示紧随其后的元素对任何人都是可用的，而<code>private</code>这个关键字表示除类型创建者和类型的内部方法之外的任何人都不能访问的元素。<code>private</code>就像你 与客户端程序员之间的一堵砖墙,如果有人试图访问<code>private</code>成员，就会在编译时得到错误信息。<code>protected</code>关键字与<code>private</code>作用相当，差别仅在于继承的类可以访问<code>protected</code>成员，但是不能访问<code>private</code>成员。稍后将会对继承进行介绍。<br>Java还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。这种权限通常被称为</strong>包访问权限</strong>，因为在这种权限下，类可以访问在同一个包(库构件)中的其他类的成员，但是在包之外，这些成员如同指定了<code>private</code>一样。</p>
<h2 id="1-5-复用具体体现"><a href="#1-5-复用具体体现" class="headerlink" title="1.5 复用具体体现"></a>1.5 复用具体体现</h2><p>一旦类被创建并被测试完，那么它就应该(在理想情况下)代表一个有用的代码单元。</p>
<p>代码复用是面向对象程序设计语言所提供的最了不起的优点之一。</p>
<p>最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为<strong>创建一个成员对象</strong>。</p>
<p>新的类可以由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。因为是在使用现有的类合成新的类，所以这种概念被称为组合composition), 如果组合是动态发生的，那么它通常被称为聚合(aggregation)。 组合经常被视为“has-a” (拥有)关系，就像我们常说的“汽车拥有引擎”一样。</p>
<p>组合带来了极大的灵活性。新类的成员对象通常都被声明为private,使得使用新类的客户端程序员不能访问它们。这也使得你可以在不干扰现有客户端代码的情况下，修改这些成员。也可以在运行时修改这些成员对象，以实现动态修改程序的行为。</p>
<h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6 继承"></a>1.6 继承</h2><p>对象这种观念，本身就是十分方便的工具，使得你可以通过概念将数据和功能封装到一起，因此可以对问题空间的观念给出恰当的表示，而不用受制于必须使用底层机器语言。这些概念用关键字class来表示，它们形成了编程语言中的基本单位。</p>
<p>有其他麻烦：在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。如果我们能够以现有的类为基础，复制它，然后通过添加和修改这个副本来创建新类那就要好多了。通过继承便可以达到这样的效果，不过也有例外，当源类(被称为基类、超类<code>super</code>或父类)发生变动时，被修改的“ 副本”(被称为导出类、继承类或子类)也会反映出这些变动。</p>
<p>类型不仅仅值是描述了作用于一个对象上的约束条件，同时还有与其他类型之间的关系。</p>
<p>两个类型可以有相同的特性和行为（属性和方法），但是一个比另一个含有更多的特性，可以处理更多的消息。</p>
<p>举例： </p>
<ol>
<li>垃圾回收机，它用来归类散落的垃圾。“垃圾”是基类型,每一件垃圾都有重量、价值等特性，可以被切碎、熔化或分解。在此基础上，可以通过添加额外的特性(例如瓶子有颜色)或行为(例如铝罐可以被压碎，铁罐可以被磁化)导出更具体的垃圾类型。此外，某些行为可能不同(例如纸的价值取决于其类型和状态)。可以通过使用继承来构建-一个类型层次结构，以此来表示待求解的某种类型的问题。</li>
<li>几何形。基类是几何形，每一个几何形都具有尺寸、颜色、位置等，同时每一个几何形都可以被绘制、擦除、移动和着色等。在此基础上，可以导出(继承出)具体的几何形状一圆形、 正方形、三角形等每一种都具有额外的特性和行为，例如某些形状可以被翻转。某些行为可能并不相同，例如计算几何形状的面积。类型层次结构同时体现了几何形状之间的相似性和差异性。</li>
</ol>
<img src="/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_6_1几何形.png" alt="1_6_1几何形">

<p>当继承现有类型时，也就创造了新的类型。这个新的类型不仅包括现有类型的所有成员(尽管private成员被隐藏了起来，并且不可访问)，而且更重要的是它复制了基类的接口。也就是说，<strong>所有可以发送给基类对象的消息同时也可以发送给导出类对象</strong>。由于通过发送给类的消息的类型可知类的类型，所以这也就意味着导出类与基类具有相同的类型。在前面的例子中，“一个圆形也就是一个几何形”。通过继承而产生的类型等价性是理解面向对象程序设计方法内涵的重要门槛。</p>
<p>子类和父类有相同的基础接口，伴随接口就会有具体实现的方法。当被调用时，必须有代码去执行。</p>
<p>如果只是继承了一个类而没有其他操作，那么子类会直接继承父类的方法。这样子类不仅与父类拥有相同的类型，还拥有相同的行为，这样没有特别的意义。</p>
<p>有两种方法可以使父类和子类产生差异：</p>
<ol>
<li><p>直接在子类中写新的方法，这些方法不是父类的。在使用这种方法时，应该考虑父类是否也需要这种方法。</p>
<img src="/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_6_2新增.png" alt="1_6_2新增">
</li>
<li><p>改变现有父类的方法（覆盖）。此时，虽然使用着相同的方法，但是做的事情不一样。</p>
<img src="/2022/08/22/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/1.%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/1_6_3重写.png" alt="1_6_3重写"></li>
</ol>
<h3 id="1-6-1-“是一个”与“像是一个”关系"><a href="#1-6-1-“是一个”与“像是一个”关系" class="headerlink" title="1.6.1 “是一个”与“像是一个”关系"></a>1.6.1 “是一个”与“像是一个”关系</h3><ul>
<li><p><strong>是一个:</strong> 不新增方法 只在原有的方法上进行修改。父类和子类是相同的类型，具有相同的接口，可以用子类对象完全替代父类对象。这被视为<code>纯粹替代</code>，通常称之为<code>替代原则</code>，这是一种理想的继承方式，<code>is-a</code>（是一个）关系。例如“一个<code>圆形</code>是一个<code>几何形状</code>”。<strong>判断是否继承，就是确定是否可以用is-a来描述两个类之间的关系</strong></p>
</li>
<li><p><strong>像是一个：</strong>新增方法。有时必须在子类中新增方法扩展接口。这个新的子类仍然可以替代父类，但是这种替代并不完美，因为他有父类没有的新方法。父类也无法访问新添加的方法。这种情况可以描述成<code>is-like-a</code>（像是一个）关系。例如，家里的旧空调（父类）只有调节温度的功能，最近新买的物联网空调（子类）不仅有作为空调的基本的调节温度功能（继承父类的方法），还能接入物联网（新增的方法）。</p>
</li>
</ul>
<h2 id="1-7-伴随多态的可互换对象"><a href="#1-7-伴随多态的可互换对象" class="headerlink" title="1.7 伴随多态的可互换对象"></a>1.7 伴随多态的可互换对象</h2><p>在处理类型的层次结构是，经常把一个对象不当做他所属的特定类型来对待，而是将其作为父类的对象来对待。这样可以编写不依赖特定对象的代码。</p>
<p>在“几何图形”的例子里，方法操作都是泛化（generic）的形状，不用在意他是方形圆形还是三角形。所有的几何形状都可以执行父类（几何形）的方法，被绘制、擦除、移动。这些方法都是直接对几何形这个父类的，不用担心子类如何处理。</p>
<p>这样的代码不会受到新增的类型（子类）的影响。例如，新增几何形的子类星型，星型可以完全继承几何形的泛化方法，不用自己重写绘制、擦除、移动这些方法。这能极大地改善我们的设计，同时也能降低软件维护的代价。</p>
<p>试图将子类的对象当做父类的对象来看待时（把圆看成几何形），仍存在问题。让一个泛化的类执行方法时，比如让一个几何形绘制自己，编译器是不知道应该执行哪一段代码的。调用这种方法时，程序员并不想知道哪一段代码将被执行，他的子类，圆形、正方形、三角形，会根据自己的具体类型来执行恰当的代码。</p>
<p>编译器无法精确地了解哪一段代码将会被执行，那么改怎么办呢？这是面向程序设计的最重要的东西。</p>
<p>编译器不能在编译时产生传统意义上的函数调用，一个非面向对象的编译器产生的函数调用会引起所谓的<code>前期绑定</code>，这样编译器将产生对一个具体函数的调用，运行时这个调用会被解析到执行代码的绝对地址。</p>
<p>然而在OOP中，程序直到运行时才能够确定代码的地址，所以在调用泛化对象的方法时，必须使用其他的机制。</p>
<p>面向对象设计语言使用了<code>后期绑定</code>的概念。当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查(无法提供此类保证的语言被称为是弱类型的)，但是并不知道将被执行的确切代码。</p>
<p>为了执行后期绑定，Java使用了一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道对这条消息应该做些什么。</p>
<p>在某些语言中，必须明确地声明希望某个方法具备后期绑定属性所带来的灵活性。在这些语言中，方法在默认情况下不是动态绑定的。而在Java中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。</p>
<p>还是用几何形举例。</p>
<p>父类几何形新增有参函数<code>doSomething</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">    shape.erase();</span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几何形的子类使用这些方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line"><span class="type">Triangle</span> <span class="variable">triangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>();</span><br><span class="line"><span class="type">Line</span> <span class="variable">line</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Line</span>();</span><br><span class="line">doSomething(circle);</span><br><span class="line">doSomething(triangle);</span><br><span class="line">doSomething(line);</span><br></pre></td></tr></table></figure>

<p>不管是Circle、Triangle还是Line，他们类型的参数都可以使用doSomething方法</p>
<p>Circle可以被doSomething()看做是Shape，也就是说，doSomething()可以发送给Shape的任何消息，Circle都可以接收。</p>
<p>把子类看成父类的过程成为<code>向上转型</code>（upcasting）。</p>
<p>一个面向对象程序肯定会在某处包含向上转型，因为这正是将自己从必须知道确切类型中解放出来的关键。让我们再看看doSomething()中的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shape.erase();</span><br><span class="line">shape.draw();</span><br></pre></td></tr></table></figure>

<p>注意这些代码并不是说“ 如果是Circle,请这样做;如果是Square,请那样做…“如果编写了那种检查Shape所有实际可能类型的代码，那么这段代码肯定是杂乱不堪的，而且在每次添加了Shape的新类型之后都要去修改这段代码。这里所要表达的意思仅仅是“你是一个Shape,我知道你可以erase()和draw()你自己，那么去做吧，但是要注意细节的正确性。”<br>doSomething()的代码给人印象深刻之处在于，不知何故，它总是做了该做的。调用Circle的draw()方法所执行的代码与调用Square或Line的draw()方法所执行的代码是不同的，而且当draw(消息被发送给-一个 匿名的Shape时，也会基于该Shape的实际类型产生正确的行为。这相当神奇，因为就像在前面提到的，当Java编译 器在编译doSomething()的代码时，并不能确切知道doSomething()要处理的确切类型。所以通常会期望它的编译结果是调用基类Shape的erase()和draw()版本，而不是具体的Circle、Square或Line的相应版本。正是因为多态才使得事情总是能够被正确处理。编译器和运行系统会处理相关的细节，你需要马上知道的只是事情会发生，更重要的是怎样通过它来设计。当向一个对象发送消息时，即使涉及向上转型，该对象也知道要执行什么样的正确行为。</p>
<h2 id="1-8-单根继承结构"><a href="#1-8-单根继承结构" class="headerlink" title="1.8 单根继承结构"></a>1.8 单根继承结构</h2><p>在面向对象编程中，自C++面世以来就有一个瞩目的问题，是否所有的类最终都继承自单一的父类。</p>
<p>在Java中(事实上还包括除C++以外的所有OOP语言)是的，这个终极父类的名字就是<code>Object</code>。事实证明，单根继承结构带来了很多好处。</p>
<p>在单根继承结构中的所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。另一种(C++所提供的)结构是无法确保所有对象都属于同一个基本类型。从向后兼容的角度看，这么做能够更好地适应C模型，而且受限较少，但是当要进行完全的面向对象程序设计时，则必须构建自己的继承体系，使得它可以提供其他OOP语言内置的便利。并且在所获得的任何新类库中，总会用到一些不兼容的接口，需要花力气(有可能要通过多重继承)来使新接口融入你的设计之中。这么做来换取C++额外的灵活性是否值得呢?如果需要的话一-如果在C上面投资巨大，这么做就很有价值。如果是刚刚从头开始，那么像Java这样的选择通常会有更高的生产率。</p>
<p>单根继承结构保证所有对象都具备某些功能。因此你知道，在你的系统中你<strong>可以在每个对象上执行某些基本操作</strong>。所有对象都可以很容易地在堆上创建，而参数传递也得到了极大的简化。</p>
<p>单根继承结构使垃圾回收器的实现变得容易得多，而垃圾回收器正是Java相对C++的重要改进之一。由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局。</p>
<p>这对于系统级操作(如异常处理)显得尤其重要，并且给编程带来了更大的灵活性。</p>
<h2 id="1-9-容器"><a href="#1-9-容器" class="headerlink" title="1.9 容器"></a>1.9 容器</h2><p>如果不知道在解决某个特定问题时需要多少个对象，或者它们将存活多久，那么就不可能知道如何存储这些对象。如何才能知道需要多少空间来创建这些对象呢?</p>
<p>答案是不可能知道，因为这类信息只有在运行时才能获得。</p>
<p>解决方法是：<strong>创建另一种对象类型。</strong></p>
<p>这种新的对象类型持有对其他对象的引用。当然，你可以用在大多数语言中都有的数组类型来实现相同的功能。但是这个通常被称为容器(也称为集合)的新对象，在任何需要时都可扩充自己以容纳你置于其中的所有东西。因此不需要知道将来会把多少个对象置于容器中，只需要创建一个容器对象，然后让它处理所有细节。</p>
<h3 id="1-9-1-参数化类型"><a href="#1-9-1-参数化类型" class="headerlink" title="1.9.1 参数化类型"></a>1.9.1 参数化类型</h3><p>在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型: Object。 单根继承结构意味着所有东西都是Object类型，所以可以存储Object的容器可以存储任何东西。这使得容器很容易被复用。</p>
<p>要使用这样的容器，只需在其中置入对象引用，稍后还可以将它们取回。但是由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，因此它会丢失其身份。当把它取回时，就获取了一个对Object对象的引用，而不是对置入时的那个类型的对象的引用。</p>
<p>所以，怎样才能将它变回先前置人容器中时的具有实用接口的对象呢?</p>
<p>这里再度用到了转型，但这一次不是向继承结构的上层转型为一个更泛化的类型，而是向下转型为更具体的类型。这种转型的方式称为<code>向下转型</code>。我们知道，向上转型是安全的，例如Circle是一种Shape类型；但是不知道某个Object是Circle还是Shape,所以<strong>除非确切知道所要处理的对象的类型，否则向下转型几乎是不安全的。</strong></p>
<p>向下转型和运行时的检查需要额外的程序运行时间，也需要程序员付出更多的心血。如果有这样一种容器，它<strong>知道自己所保存的对象的类型，从而不需要向下转型</strong>以及消除犯错误的可能，这样不是更有意义吗？</p>
<p>这种解决方案被称为参数化类型机制。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。例如，通过使用参数化类型，编译器可以定制一个只接纳和取出Shape对象的容器。</p>
<p>Java SE5的重大变化之一就是增加了<code>参数化类型</code>，在Java中它称为范型。一对尖括号,中间包含类型信息，通过这些特征就可以识别对范型的使用。例如，可以用下面这样的语句来创建一个存储Shape的ArrayList:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Shape&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="1-10-对象的创建和生命期"><a href="#1-10-对象的创建和生命期" class="headerlink" title="1.10 对象的创建和生命期"></a>1.10 对象的创建和生命期</h2><p>在使用对象时，最关键的问题之一便是它们的生成和销毁方式。</p>
<p>每个对象为了生存都需要资源，尤其是内存。当我们不再需要一个对象时，它必须被清理掉，使其占有的资源可以被释放和重用。简单的程序中这不是问题，但是不是所有的程序都那么简单。</p>
<p>例如，一个机场空中交通管理系统。</p>
<ul>
<li><strong>简单版：</strong>创建一个容器，保存所有飞机。<ul>
<li>新增：为每一架进入空中控制区域的飞机新建一个飞机对象，将其至于容器内</li>
<li>清理： 在飞机离开控制区域时删除相关的飞机对象。</li>
</ul>
</li>
<li><strong>困难版：</strong>小型飞机的飞行计划<ul>
<li>新增：无论何时，只要有小型飞机对象创建，就要有第二个容器来存放对应的飞行计划</li>
<li>销毁：何时销毁？？？</li>
</ul>
</li>
</ul>
<ol>
<li>C++认为效率控制是最重要的议题，所以给程序员提供了选择的权力。为了追求最大的执行速度，对象的存储空间和生命周期可以在编写程序时确定。这种方式将存储空间分配和释放置于优先考虑的位置，某些情况下这样控制非常有价值。但是，也牺牲了灵活性，因为必须在编写程序时知道对象确切的数量、生命周期和类型。如果试图解决更一般化的问题，例如计算机辅助设计、仓库管理或者空中交通控制，这种方式就显得过于受限了。</li>
<li>第二种方式是在被称为堆(heap) 的内存池中动态地创建对象。在这种方式中，直到运行时才知道需要多少对象，它们的生命周期如何，以及它们的具体类型是什么。这些问题的答案只能在程序运行时相关代码被执行到的那一刻才能确定。如果需要一个新对象，可以在需要的时刻直接在堆中创建。因为存储空间是在运行时被动态管理的，所以需要大量的时间在堆中分配存储空间，这可能要远远大于在堆栈中创建存储空间的时间。在堆栈中创建存储空间和释放存储空间通常各需要一条汇编指令即可，分别对应将栈顶指针向下移动和将栈顶指针向上移动。创建堆存储空间的时间依赖于存储机制的设计。</li>
</ol>
<p>动态方式有这样一个一般性的逻辑假设:对象趋向于变得复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大冲击。</p>
<p>动态方式所带来的更大的灵活性正是解决一般化编程问题的要点所在。</p>
<p><strong>Java完全采用了动态内存分配方式。</strong>每当想要创建新对象是，就要使用new关键字来构建此对象的动态实例。</p>
<p>还有一个问题，就是生命周期。</p>
<p>对于允许在堆栈上创建对象的语言，编译器可以确定对象存活的时间，并可以自动销毁。</p>
<p>可是，在堆上创建对象，编译器就会对它的生命周期一无所知。在C++上，必须通过编程方式类确定何时销毁对象，这可能会因为处理不正确导致内存泄露。</p>
<p>Java中提供了内存回收机制，能自动发现对象何时不再被使用，并继而销毁它。回收机制被设计用来处理内存释放问题，它”知道“对象何时不再被使用，并且自动释放对象占用的内存。</p>
<p>这是因为所有的对象都继承自单根基类Object以及只能用一种方式创建对象（在堆上创建）这两个特性。</p>
<h2 id="1-11-异常处理：处理错误"><a href="#1-11-异常处理：处理错误" class="headerlink" title="1.11 异常处理：处理错误"></a>1.11 异常处理：处理错误</h2><p>错误处理始终是最困难的问题之一。</p>
<p>异常是一种对象，它从出错地点被“抛出”，并被专门设计用来处理特定类型错误的相应的异常处理器“捕获”。</p>
<p>异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。 因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。因为不需要被迫定期检查错误，这往往使得代码编写变得简单。</p>
<p>此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。</p>
<p><strong>异常不能被忽略</strong>，所以它保证一定会在某处得到处理。</p>
<p>Java的异常处理在众多的编程语言中格外引人注目，因为Java一开始就内置了异常处理，而且强制你必须使用它。它是唯一可接受的错误报告方式。如果没有编写正确的处理异常的代码，那么就会得到一条编译时的出错消息。这种有保障的一致性有时会使得错误处理非常容易。</p>
<h2 id="1-12-并发编程"><a href="#1-12-并发编程" class="headerlink" title="1.12 并发编程"></a>1.12 并发编程</h2><p>在计算机编程中有一个基本概念，就是在同一时刻处理多个任务的思想。</p>
<p>许多程序设计问题都要求，程序能够停下正在做的工作，转而处理某个其他问题，然后再返回主进程。有许多<br>方法可以实现这个目的。最初，程序员们用所掌握的有关机器底层的知识来编写中断服务程序，主进程的挂起是通过硬件中断来触发的。尽管这么做可以解决问题，但是其难度太大，而且不能移植，所以使得将程序移植到新型号的机器上时，既费时又费力。</p>
<p>有时中断对于处理时间性强的任务是必需的，但是对于大量的其他问题，我们只是想把问题切分成多个可独立运行的部分(任务)，从而提高程序的响应能力。</p>
<p>在程序中，这些彼此独立运行的部分称之为线程，上述概念被称为 “并发”。并发最常见的例子就是用户界面。通过使用任务，<strong>用户可以在揿下按钮后快速得到一个响应，而不用被迫等待到程序完成当前任务为止。</strong></p>
<p>通常，线程只是一种为单一处理器分配执行时间的手段。但是如果操作系统支持多处理器，那么每个任务都可以被指派给不同的处理器，并且它们是在真正地并行执行。在语言级别上，多线程所带来的便利之一便是程序员不用再操心机器上是有多个处理器还是只有一个处理器。</p>
<p>由于程序在逻辑上被分为线程，所以如果机器拥有多个处理器，那么程序不需要特殊调整也能执行得更快。</p>
<p>所有这些都使得并发看起来相当简单，但是<strong>有一个隐患：共享资源</strong>。如果有多个并行任务都要访问同一项资源，那么就会出问题。</p>
<p>例如，两个进程不能同时向一台打印机发送信息。为了解决这个问题，可以共享的资源，例如打印机，必须在使用期间被锁定。因此，整个过程是：某个任务锁定某项资源，完成其任务，然后释放资源锁，使其他任务可以使用这项资源。<br><strong>Java的并发是内置于语言中的</strong>，JavaSE5已经增添了大量额外的库支持。</p>
<h2 id="1-13-Java与Internet"><a href="#1-13-Java与Internet" class="headerlink" title="1.13 Java与Internet"></a>1.13 Java与Internet</h2><p>为什么Java如此重要？</p>
<h3 id="1-13-1-Web是什么"><a href="#1-13-1-Web是什么" class="headerlink" title="1.13.1 Web是什么"></a>1.13.1 Web是什么</h3><h4 id="1-客户-x2F-服务器计算技术"><a href="#1-客户-x2F-服务器计算技术" class="headerlink" title="1. 客户&#x2F;服务器计算技术"></a>1. 客户&#x2F;服务器计算技术</h4><p>系统具有一个中央信息存储池(central repository of information)，用来存储某种数据，它通常存在于数据库中，你可以根据需要将它分发给某些人员或机器集群。</p>
<p>客户&#x2F;服务器概念的关键在于信息存储池的位置集中于中央，这使得它可以被修改，并且这些修改将被传播给信息消费者。总之，信息存储池、用于分发信息的软件以及信息与软件所驻留的机器或机群被总称为服务器。驻留在用户机器上的软件与服务器进行通信，以获取信息、处理信息，然后将它们显示在被称为客户机的用户机器上。</p>
<p>客户&#x2F;服务器计算技术的基本概念并不复杂。问题在于<strong>你只有单一的服务器，却要同时为多个客户服务。</strong>通常，这会涉及数据库管理系统，因此设计者把数据“均衡”分布于数据表中,以取得最优的使用效果。此外，系统通常允许客户在服务器中插入新的信息。这意味着必须<strong>保证一个客户插入的新数据不会覆盖另一个客户插入的新数据，也不会在将其添加到数据库的过程中丢失(这被称为事务处理)。</strong>如果客户端软件发生变化，那么它必须被重新编译、调试并安装到客户端机器上，事实证明这比想像的要更加复杂与费力。如果想支持多种不同类型的计算机和操作系统，问题将更麻烦。最后还有一个最重要的性能问题:可能在任意时刻都有成百上千的客户向服务器发出请求，所以任何小的延迟都会产生重大影响。为了将延迟最小化，程序员努力减轻处理任务的负载，通常是分散给客户端机器处理，但有时也会使用所谓的中间件将负载分散给在服务器端的其他机器。(中间件也被用来提高可维护性。)</p>
<h4 id="2-Web就是一台巨型服务器"><a href="#2-Web就是一台巨型服务器" class="headerlink" title="2. Web就是一台巨型服务器"></a>2. Web就是一台巨型服务器</h4><p>在某一时刻怎么连接到一个服务器上与之交互。</p>
<p>对服务器产生请求，服务器返回文件，本地解读。</p>
<p>人们希望能直接操作服务器的数据库。</p>
<p>Web浏览器出现了，一些信息不需要任何修改就可以在任意型号的计算机上显示。但是当时的浏览器不具备显著的交互性，需要编程来实现的任务还需要把信息发到服务器去处理，这样对于程序的排错比较困难。但是因为他只能观察，不能执行任何程序，所以有很高的安全性。</p>
<p>为了解决这个问题，人们采用了不同的方法。为了解决这个问题，人们采用了各种不同的方法。首先，图形标准得到了增强，使得在浏览器中可以播放质量更好的动画和视频。剩下的问题通过引人在客户端浏览器中运行程序的能<br>力就可以解决。这被称为“客户端编程”。</p>
<h3 id="1-13-2-客户端编程"><a href="#1-13-2-客户端编程" class="headerlink" title="1.13.2 客户端编程"></a>1.13.2 客户端编程</h3><p>Web最初的“服务器-浏览器”设计是为了提供交互性的内容，但是交互性由服务器提供。</p>
<p>服务器产生静态界面(HyperText Markup Language，超文本标记语言)，提供给只能解释并显示的客户端浏览器。</p>
<p>提交动作通过所有的Web服务器都提供的通用网关接口(common gateway interface, CGI) 传递。</p>
<p>提交内容会告诉CGI应该如何处理它。最常见的动作就是运行一个在服务器中常被命名为“cgi-bin”的目录下的一个程序。(如果网页地址有<code>cgi-bin</code>)几乎所有的语言都可以用来编写这些程序，PerI已经成为最常见的选择，因为它被设计用来处理文本，并且是解释型语言，因此无论服务器的处理器和操作系统如何，它都适于安装。<br>当今许多有影响力的网站完全构建于CGI之上的，实际上你几乎可以通过CGI做任何事。然而，构建于CGI程序之上的网站可能会迅速变得过于复杂而难以维护，并同时产生响应时间过长的问题。CGI程序的响应时间依赖于所必须发送的数据量的大小，以及服务器和Internet的负载。(此外，启动CGI程序也相当慢。) </p>
<p>你肯定经历过对Web输入表单进行数据验证的过程:你按下网页上的提交按钮，数据被发送回服务器;服务器启动一个CGI程序来检查、发现错误，并将错误组装为一个HTML页面，然后将这个页面发回给你；之后你必须回退一个页面，然后重新再试。这个过程不仅很慢，而且不太优雅。（注册界面有很多项目需要填写，你好不容易全填写晚了，但是最后的验证码过期了导致你注册失败，上面的这些东西你又要全部重新填写）</p>
<p>解决方法是客户端编程。大多数运行Web浏览器的机器都是能够执行大型任务的强有力的引擎。在使用原始的静态HTML方式的情况下，它们只是闲在那里，等着服务器送来下一个页面。客户端编程意味着Web浏览器能用来执行任何它可以完成的工作，使得返回给用户的结果更加迅捷，而且使得你的网站更加具有交互性。</p>
<p>客户端编程的问题是：它与通常意义上的编程十分不同，参数几乎相同，而平台却不同。Web浏览器就像一个功能受限的操作系统。 </p>
<p>最终，你仍然必须编写程序，而且还得处理那些令人头晕眼花的成堆的问题，并以客户端编程的方式来产生解决方案。</p>
<h4 id="1-插件"><a href="#1-插件" class="headerlink" title="1. 插件"></a>1. 插件</h4><p>客户端编程所迈出的最重要的一步就是插件(plug-in) 的开发。通过这种方式，程序员可以下载一段代码，并将其插入到浏览器中适当的位置，以此来为浏览器舔加新功能。它告诉浏览器：从现在开始，你可以采取这个新行动了**(只需要下载一次插件即可)**。</p>
<p>某些更快更强大的行为都是通过插件添加到服务器中的。但是编写插件并不是件轻松的事，也不是构建某特定网<br>站的过程中所要做的事情。插件对于客户端编程的价值在于：它允许专家级的程序员不需经过浏览器生产厂商的许可，就可以开发某种语言扩展，并将它们添加到服务器中。因此，插件提供了一个“后门”，使得可以创建新的客户端编程语言(但是并不是所有的客户端编程语言都是以插件的形式实现的)。</p>
<h4 id="2-脚本语言"><a href="#2-脚本语言" class="headerlink" title="2.脚本语言"></a>2.脚本语言</h4><p>插件引发了浏览器脚本语言(scripting language) 的开发。通过使用某种脚本语言，你可以将客户端程序的源代码直接嵌人到HTML页面中，解释这种语言的插件在HTML页面被显示时自动激活。脚本语言先天就相当易于理解，<strong>因为它们只是作为HTML页面一部分的简单文本，当服务器收到要获取该页面的请求时，它们可以被快速加载。</strong>此方法的缺点是代码会暴露给任何人去浏览(或窃取)。但是，通常不会使用脚本语言去做相当复杂的事情，所以这个缺点并不太严重。</p>
<p>如果你期望有一种脚本语言在Web浏览器不需要任何插件的情况下就可以得到支持，那它非JavaScript莫属。</p>
<p>在Web浏览器内部使用的脚本语言实际上总是被用来解决特定类型的问题，主要是用来创建更丰富、更具有交互性的图形化用户界面(graphic user interface, GUI)。但是，脚本语言可以解决客户端编程中所遇到的百分之八十的问题。</p>
<p>你的问题可能正好落在这百分之八十的范围之内，由于脚本语言提供了更容易、更快捷的开发方式，因此你应该在考虑诸如Java这样的更复杂的解决方案之前，先考虑脚本语言。</p>
<h4 id="3-Java"><a href="#3-Java" class="headerlink" title="3. Java"></a>3. Java</h4><p>如果脚本语言可以解决客户端编程百分之八十的问题，剩下那百分之二十Java是处理它们最流行的解决方案。</p>
<p>Java不仅是一种功能强大的、安全的、跨平台的、国际化的编程语言，而且它还在不断地被扩展，以提供更多的语言功能和类库，能够优雅地处理在传统编程语言中很难解决的问题，例如并发、数据库访问、网络编程和分布式计算。Java是通过applet以及使用Java Web Start来进行客户端编程的。</p>
<p>applet是只在Web浏览器中运行的小程序，它是作为网页的一部分而自动下载的(就像网页中的图片被自动下载一样)。 当applet被激活时，它便开始执行一个程序。</p>
<p>它提供一种分发软件的方法，一旦用户需要客户端软件时，就自动从服务器把客户端软件分发给用户。用户获取最新版本的客户端软件时不会产生错误，而且也不需要很麻烦的重新安装过程。Java的这种设计方式，使得程序员只需创建单一的程序，而只要一台计算机有浏览器，且浏览器具有内置的Java解释器(大多数的机器都如此),那么这个程序就可以自动在这台计算机上运行。由于Java是一种成熟的编程语言，所以在提出对服务器的请求之前和之后，可以在客户端尽可能多地做些事情。例如，不必跨网络地发送一张请求表单来检查自己是否填写了错误的日期或其他参数，客户端计算机就可以快速地标出错误数据，而不用等待服务器作出标记并给你传回图片。这不仅立即就获得了高速度和快速的响应能力，而且也降低了网络流量和服务器负载，从而不会使整个Internet的速度都慢了下来。</p>
<h4 id="4-备选方案"><a href="#4-备选方案" class="headerlink" title="4. 备选方案"></a>4. 备选方案</h4><p>好久远的例子</p>
<h4 id="5-NET和C"><a href="#5-NET和C" class="headerlink" title="5. .NET和C#"></a>5. .NET和C#</h4><p>.net平台大致相当于java虚拟机（JVM）和java类库</p>
<h4 id="6-Internet与Intranet（企业内部网）"><a href="#6-Internet与Intranet（企业内部网）" class="headerlink" title="6. Internet与Intranet（企业内部网）"></a>6. Internet与Intranet（企业内部网）</h4><p>在公网上需要注意平台兼容性与安全性 在Intranet需要注意代码质量，并且在发现bug后进行修复（？？？）</p>
<h3 id="1-13-3-服务器端编程"><a href="#1-13-3-服务器端编程" class="headerlink" title="1.13.3 服务器端编程"></a>1.13.3 服务器端编程</h3><p>Java成功的因素之一。</p>
<p>对服务器提出请求后，一般发送文件之类的浏览器会进行解释。但是更复杂的对于数据库操作的请求会执行一些程序之后返回一个HTML界面给客户端。</p>
<h2 id="1-14-总结"><a href="#1-14-总结" class="headerlink" title="1.14 总结"></a>1.14 总结</h2><ul>
<li>要知道过程型语言看起来像什么样子：数据定义和函数调用。</li>
<li>要通读函数调用和低层概念，以在脑海里建立一个模型。</li>
</ul>
<p>这正是我们过程式程序，需要中间表示形式的原因。<br>因为OOP在你能够在过程型语言中找到的概念的基础上，又添加了许多新概念<br>编写良好的Java程序通常比过程型程序要简单得多，而且也易于理解得多。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">十早九木</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.szjm.online/2022/08/22/hwcd/学习/Java编程思想/1.对象导论/">https://www.szjm.online/2022/08/22/hwcd/学习/Java编程思想/1.对象导论/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.szjm.online">十早九木のBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/hwcd/">hwcd</a><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a><a class="post-meta__tags" href="/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">Java编程思想</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="../../../../../../../wx.jpg"><div class="post-qr-code__desc">来杯奶茶吧</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="../../../../../../../zfb.jpg"><div class="post-qr-code__desc">圣代我也喜欢</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/08/23/hwcd/%E5%AD%A6%E4%B9%A0/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/2.%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/"><i class="fa fa-chevron-left">  </i><span>一切都是对象</span></a></div><div class="next-post pull-right"><a href="/2022/08/20/JAVA/06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A113_instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"><span>instanceof和类型转换</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By 十早九木</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>